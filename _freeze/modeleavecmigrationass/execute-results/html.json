{
  "hash": "deeeee3b1b16a83b2d64649ca4af5fe2",
  "result": {
    "markdown": "---\ntitle: Modèle logistique structuré avec migration assymétrique\n---\n\n*Modules à importer :*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\n## Définition du modèle\n\nLe but d'un augmentorium est de confiner les ravageurs dans un espace clos qui ne laisse pas (ou peu) s'échapper ceux-ci.  \nAinsi, il s'établit une migration assymétrique entre les deux structures qu'on peut modéliser en établissant le modèle suivant d'après @arditi2018 : \n\n$$ \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n$$ {#eq-modamig}\n\navec :  \n- $x$ la population de ravageurs dans la culture,  \n- $y$ la population de ravageurs dans l'augmentorium,  \n- $r_x$ et $r_y$ le taux de croissance dans la culture et dans l'augmentorium,  \n- $K_x$ et $K_y$ les capacités de charges de la culture de de l'augmentorium,  \n- $\\beta$ la force de migration entre les structures,  \n- $\\gamma_x$ et $\\gamma_y$ caractérisant l'assymétrie de migration.\n\n### Nouvelles hypothèses propres à l'augmentorium\n\nCe modèle est plus proche de celui d'un augmentorium.  \nComme les ravageurs se reproduisent mieux dans l'augmentorium que dans la culture on peut dire que $r_x<r_y$.  \nOn peut aussi dire que le taux de fuite des ravageurs ($\\frac{1}{\\gamma_y}$) se doit d'être beaucoup plus petit que le taux de migration ($\\frac{1}{\\gamma_x}$).  \nOn a donc $\\gamma_x << \\gamma_y$.\n\n## Dynamique du modèle\n\nEncore une fois on simule la dynamique des deux populations en fonction du temps en codant comme dans la première partie\n\nOn définit le système sous [Python](https://www.python.org/):\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b, gx, gy = param\n    x, y = etat\n    s=[rx * x * (1 - x/Kx) + b * (y/gy - x/gx),\n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s\n```\n:::\n\n\nEt on définit les paramètres, le temps d'intégration etc. :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\n# Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n# Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0, y0]\n\n# Paramètres: \n\nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\ngx = 0.5\ngy = 3\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n```\n:::\n\n\nOn trace la figure :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nfig,ax = plt.subplots(1, 1)\nfig.suptitle('Dynamique des ravageurs dans le temps avec augmentorium')\n\nax.plot(ti, s[ :, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[ :, 1], color = 'C0', label = 'augmentorium')\n\n# Ajout d'élements:\nax.grid()\nax.legend()\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-5-output-1.png){width=598 height=477}\n:::\n:::\n\n\nCette dynamique, comme en première partie, présente un équilibre de maintien de la population.  \nNéanmoins on observe que, pour les mêmes paramètres que dans la première partie, la population dans la culture est bien plus faible.    \nLa migration assymétrique vers l'augmentorium semble être bénéfique à la culture.\n\n## Plan de phase \n\n### Equilibres et leur stabilité \n\nA l'équilibre on a le système suivant :\n\n$$ \n\\left\\{\\begin{array}{l}\n\\dot x = 0 \\Leftrightarrow 0 = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = 0 \\Leftrightarrow 0 = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n$${#eq-pdpamig0}\n$$\n\\Leftrightarrow\n$$\n$$ \n\\left\\{\\begin{array}{l}\ny^*=\\gamma_y\\left(\\frac{x}{\\gamma_x}-\\frac{r_xx}{\\beta}\\left(1-\\frac{x}{K_x}\\right)\\right)\\\\\nx^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)\n\\end{array}\\right.\n$${#eq-pdpamig}\n\nOn voit tout de suite qu'on a deux paraboles qui se croisent en $(0,0)$ et en $(x^*,y^*)$.  \nOn va donc avoir deux équilibres, ceux-ci vivent sur une ellipse de même équation qu'en première partie.   \n\nEn fonction des racines des paraboles on va avoir des plans de phases différents qu'on va tracer via les mêmes techniques qu'en première partie :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\n#On crée la figure avec les 3 sous figures:\nfig2, (ax2, ax3, ax4) = plt.subplots(1, 3, figsize = (9, 4))\n\nfig2.suptitle('Plan de phase de la population')\nax2.set_title('β=1')\nax3.set_title('β=10')\nax4.set_title('β=0.1')\n\n#Plan de phase 1:#\n# Paramètres: \nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\nb1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam_aug1 = np.array([rx1, ry1, Kx1, Ky1, b1, gx1, gy1])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy1 * (xt/gx1 - rx1 * xt/b1 * (1 - xt/Kx1)), color = 'C2', label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax2.plot(gx1 * (yt/gy1 - ry1 * yt/b1 * (1 - yt/Ky1)), yt, color = 'C3', label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax2.set_xlim(left = -0.03, right = 0.5)\nax2.set_ylim(top = 1.5, bottom = -0.06)\n\nax2.set_xlabel('Ravageur dans la culture', fontsize = '12');\nax2.set_ylabel('Ravageur dans l\\'augmentorium', fontsize = '12');\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\nX, Y = np.meshgrid(xg, yg)\n\n#On utilise quiver:\ndx, dy = aug([X, Y], 0, param_aug1)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 15, width = 0.0035);\n\n#Plan de phase 2:#\n#Paramètres: \nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\nb2 = 10\ngx2 = 0.5\ngy2 = 3\n\nparam_aug2 = np.array([rx2, ry2, Kx2, Ky2, b2, gx2, gy2])  \n\n#Isocline nulles:\n#xdot = 0\nax3.plot(xt, gy2 * (xt/gx2 - rx2 * xt/b2 * (1 - xt/Kx2)), color = 'C2', label = '$\\dot x=0$')\nax3.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax3.plot(gx2 * (yt/gy2 - ry2 * yt/b2 * (1 - yt/Ky2)), yt, color = 'C3', label = '$\\dot y=0$')\nax3.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax3.set_xlim(left = -0.02, right = 0.35)\nax3.set_ylim(top = 1.4, bottom = -0.06)\n\nax3.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\n\nX, Y = np.meshgrid(xg, yg)\n\n#On utilise quiver:\ndx, dy = aug([X, Y], 0, param_aug2)\nax3.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 40, width = 0.003);\n\n#Plan de phase 3:\n#Paramètres: \nrx3 = 0.5\nry3 = 1\nKx3 = 2\nKy3 = 1\nb3 = 0.1\ngx3 = 0.5\ngy3 = 3\n\nparam_aug3=np.array([rx3, ry3, Kx3, Ky3, b3, gx3, gy3])\n\n#Isocline nulles:\n#xdot = 0 \nax4.plot(xt, gy3 * (xt/gx3 - rx3 * xt/b3 * (1 - xt/Kx3)), color = 'C2', label = '$\\dot x=0$')\nax4.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0 \nax4.plot(gx3 * (yt/gy3 - ry3 * yt/b3 * (1 - yt/Ky3)), yt, color = 'C3', label = '$\\dot y=0$')\nax4.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration:\nax4.set_xlim(left = -0.08, right = 1.9)\nax4.set_ylim(top=1.5, bottom = -0.06)\n\nax4.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n# Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.18)\nyg = np.arange(-0.5, 3, 0.18)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug3)\nax4.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 10, width = 0.0035);\n\n#On légende:\nax4.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-6-output-1.png){width=740 height=396}\n:::\n:::\n\n\nEn fonction des valeurs de $\\beta$ on observe des profils différents de plan de phase. Pour mieux le visualiser on pourra utiliser l'animation [Geogebra](@fig-anim) mise à disposition à la fin de l'analyse.\n\nD'après le champ de vecteurs on voit clairement que l'équilibre en $(0,0)$ est instable et l'équilibre $(x^*,y^*)$ est stable.  \n\nPour calculer l'équilibre on procède de la même manière que dans la première partie, c'est à dire en croisant les deux paraboles $\\dot =0 $ et $\\dot y =0$ :\nOn a $x^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)$.  \nDonc :\n$$\\small\ny^*=\\gamma_y\\left(\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\gamma_x}-\\frac{r_x\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\beta}\\left[1-\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{K_x}\\right]\\right)\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n-\\frac{r_y\\gamma_yy^*}{\\beta} + \\frac{r_y \\gamma_y {y^*}^2}{\\beta K_y} - \\frac{r_x\\gamma_xy^*}{\\beta} + \\frac{r_xr_y\\gamma_x \\gamma_y y^*}{\\beta^2} \\\\\n- \\frac{r_xr_y\\gamma_x\\gamma_y{y^*}^2}{\\beta^2K_y} + \\frac{r_x\\gamma_x^2{y^*}^2}{\\beta K_x\\gamma_y} - \\frac{r_xr_y\\gamma_x^2{y^*}^2}{\\beta^2K_x} \\\\\n+ 2\\frac{r_xr_y\\gamma_x^2{y^*}^3}{\\beta^2K_xK_y} + \\frac{r_xr_y^2\\gamma_x^2 \\gamma_y {y^*}^2}{\\beta^3K_x} - 2\\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^3}{\\beta^3K_xK_y} \\\\\n+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^4}{\\beta^3K_xK_y^2}\n$$\n\nCe qui donne, en mettant les monomes $y^*$ en facteur et en simplifiant ensuite par $\\frac{y^*}{\\beta}$ :  \n$$\n\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta}-\\gamma_yr_y-\\gamma_xr_x +\\\\ y\\left[\\frac{r_y\\gamma_y}{K_y}-\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta K_y}+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y}{\\beta^2K_x}+\\frac{r_x\\gamma_x^2}{\\gamma_yK_x}-\\frac{2r_xr_y\\gamma_x^2}{\\beta K_x}   \\right] +\\\\[.2cm]\n\\frac{2r_yr_x\\gamma_x^2y^2}{\\beta K_xK_y}\\left(1-\\frac{r_y\\gamma_y}{\\beta}\\right) + \\frac{r_xr_y^2\\gamma_x^2\\gamma_yy^3}{\\beta^2K_xK_y^2} = 0\n$${#eq-pol}\n\nCe polynôme est résoluble par `numpy` similairement à la première partie :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\n# Paramètres pour calculer le polynôme\nrx = 0.5\nry = 1\nKx = 2.5\nKy = 2\nb = 1\ngx = 1.5\ngy = 3\n\n#Points d'équilibres, utilisation de numpy : monome, polynome et racines:\n#Calcul:\n#Monome y\nx = np.polynomial.Polynomial([0, 1])\n\n#Polynome :\npol = -gy * ry - gx * rx + (rx * ry * gx * gy)/b + x * ((ry * gy)/(Ky) - (ry * rx * gy * gx)/(b * Ky) + \\\n rx * ry**2 * gx**2 * gy/(b**2 * Kx) + rx * gx**2/(gy * Kx) - 2 * rx * ry * gx**2/(b * Kx)) + \\\n (x**2) * 2 * (ry * rx *gx**2)/(b * Kx * Ky) * (1 - ry * gy/b) + (x**3) * gy * rx * ((ry * gx)**2)/(b**2 * Kx * Ky**2)\n\n#Solution\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() > 0)]\nyeq = sol[0].real\n\n#Calcul de x avec sa définition:\nxeq = gx * (yeq/gy - ry * yeq/b * (1 - yeq/Ky))\n```\n:::\n\n\n### Analyse du plan de phase\n\nOn va tracer le plan de phase complet et l'analyser d'après la méthode d'@arditi2018 :  \n\nDans cette analyse on va considérer, sans perte de généralité, que $r_x < r_y$ (on prend l'ellipse dans un seul sens, voir l'[animation](@fig-anim)).\n\nPour cela on trace l'ellipse de la même manière que dans la première figure, l'équation de cette ellipse n'ayant pas de terme de migration dans le premier modèle elle est la même dans celui-ci aussi.  \n\nEnsuite on va tracer la droite $d$ correspondant à $K_x+K_y=x^*+y^*$ car ceci va permettre de voir si le système subit une [inflation](contexte.qmd) ou une déflation.  \n\nEnfin, similairement à la partie prédédente on va tracer les droites données par $\\beta = 0$ et $\\beta = +\\infty$ dans la parabole définie par $\\dot x =0$ (parabole verte sur le plan de phase).  \nLes droites sont différentes du modèle précédent donc on va les recalculer :\n\nLorsque $\\beta = 0$ on a exactement les mêmes deux droites que dans le modèle précédent en $x^* =0$ et en $x^*=K_x$ car le fait que le nouveau modèle ajoute de l'assymétrie dans les migrations est effacé par une migration nulle. On les appelle respectivement $P_{10}$ et $P_{20}$.\n\nLorsque $\\beta = +\\infty$ on a d'après ([-@eq-pdpamig]) : \n$$\ny^* = \\frac{\\gamma_y}{\\gamma_x}x^*\n$$\n\nOn appellera cette droite $P_{\\infty}$.  \n\n\nIntroduisons les mêmes points que précédemment c'est à dire : \n\n- $A$, l'intersection entre $P_{20}$  et l'ellipse, c'est à dire la valeur de l'équilibre quand $\\beta = 0$.\n\n- $B$, l'intersection entre $P_{\\infty}$ et l'ellipse, c'est à dire la valeur de l'équilibre quand $\\beta = +\\infty$.\n\n- $C$, l'intersection entre $P_{20}$ et $P_{\\infty}$.\n\n- $D$, l'intersection entre la droite $d$ et l'ellipse qui n'est pas le point $A$.\n\nReprésentons le plan de phase avec ces éléments :\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\n#On crée la figure:\nfig2, ax2 = plt.subplots(1, 1, figsize = (8, 5))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase:\n# Paramètres égaux à ceux utilisés pour calculer les équilibres:\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy * (xt/gx - rx * xt/b * (1 - xt/Kx)), color = 'C2', label = '$\\dot x = 0$')\n\n#ydot = 0\nax2.plot(gx * (yt/gy - ry * yt/b * (1 - yt/Ky)), yt, color = 'C3', label = '$\\dot y = 0$')\n\n#Cadrage:\nax2.set_xlim(left = -0.30, right = 4.5)\nax2.set_ylim(top = 6, bottom = -0.70)\n\nax2.set_xlabel('$x^*$', fontsize = '12')\nax2.set_ylabel('$y^*$', fontsize = '12')\n\n#Axe x et y:\nax2.plot(xt, np.zeros_like(xt), color = 'k', linestyle = 'dashed')\nax2.plot(np.zeros_like(yt), yt, color = 'k', linestyle = 'dashed')\n\n#Droite capacité:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = \"0.8\")\n\n#Plot des équilibres:\nax2.plot(xeq, yeq, marker = '.', markersize = 12)\nax2.plot(0, 0, marker = '.', markersize = 12, color = 'C5')\n\n#Ellipse:\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole β = 0')\nax2.plot(np.zeros_like(xt), xt, color = 'C9')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt, xt * gy/gx, color = 'C6', label = 'Parabole β = $+\\infty$')\n\n#A:\nax2.plot(Kx, Ky, color = 'black', marker = '.')\nax2.text(Kx - 0.1, Ky - 0.1, '$A$')\n\n#C:\nax2.plot(Kx, gy * Kx/gx, color = 'black', marker = '.')\nax2.text(Kx, gy * Kx/gx - 0.1, 'C')\n\n#B:\nax2.plot(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky),((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) \\\n                                        , color = 'black', marker = '.')\n\nax2.text(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) - 0.1, ((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) + 0.1 \\\n                                        , '$B$')\n\n#D:\nax2.plot(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx), rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx), color = 'black', marker = '.')\nax2.text(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx) + 0.1, '$D$')\n\n## On place des textes indiquant les trois droites:\nax2.text(0.1, yeq, \"$P_{10}$\")\nax2.text(Kx + 0.05, 4, \"$P_{20}$\")\nax2.text(3, 5.5, \"$P_\\infty$\")\n\n#Légende:\nax2.legend(loc=\"upper left\");\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-8-output-1.png){width=658 height=482}\n:::\n:::\n\n\n#### a) Première condition de déflation\n\nLa première condition d'inflation est exactement la même que dans le modèle précédent et la preuve est en tout point égale (elle repose sur une analyse de l'équation de l'ellipse qui est la même dans les deux modèles). On ne détaillera pas ici cette preuve mais on sait donc que :\n\n**Si $r_x = r_y$ alors le système est tout le temps déflationiste.**\n\n#### b) Deuxième condition de déflation\n\nNous allons faire une preuve graphique de cette condition similaire à l'ancien modèle.  \n\nL'équilibre vit sur l'ellipse et parcourt l'arc orange entre $A$ et $B$ au fur et à mesure que $\\beta$ augmente.   \nAinsi pour avoir déflation on va vouloir avoir cet arc entièrement sous la droite $d$ en gris.  \nIl est alors facile de voir que pour cela on veut que la coordonnée en $y$ de $C$ soit plus grande que celle de $A$ ($C$ est plus haut sur la droite cyan que $A$), entraînant que la coordonnée en $x$ de $B$ est plus petite que celle de $A$ ($B$ se trouve plus à gauche sur l'ellipse que $A$).  \n\nPour cela on a besoin de connaître les coordonnées de $A$ et $C$.  \n\nLe point $A$ est défini comme la valeur de l'équilibre sans migration. Il est alors facile de constater que dans ce cas nous sommes face à un système avec une croissance logistique seulement et donc l'équilibre est atteint pour les capacités de charge.  \nOn a donc $A = (K_x,K_y)$.\n\nPour $C$ on sait que c'est l'intersection entre $P_{20}$ et $P_{\\infty}$, ainsi comme $P_{20}$ est défini par $x^* = K_x$ et $P_{\\infty}$ par $y^* =\\frac{\\gamma_y}{\\gamma_x}x^*$ on a :\n\n$C = (K_x,\\frac{\\gamma_yK_x}{\\gamma_x})$.\n\nLa condition mathématique qui en découle est donc que le système est déflationiste si $\\frac{\\gamma_yK_x}{\\gamma_x} > K_y$.\n\n**Si $\\frac{\\gamma_y}{\\gamma_x} > \\frac{K_y}{K_x}$ alors le système ([-@eq-modamig]) est toujours déflationiste.**\n\n#### c) Conditions d'inflation et/ou de déflation\n\nSimilairement à la première partie on va avoir des conditions sur l'inflation.  \nEn effet, on voit bien sur le plan de phase que si $B$ est entre $A$ et $D$ alors l'arc d'ellipse que parcourt les équilibres en fonction de $\\beta$ est constamment inflationiste.  \n\nAinsi on veut que $B$ soit à droite de $A$ ce qui revient à prendre la condition inverse de celle énoncée plus haut (c'est à dire la coordonées $y$ de $C$ plus petite que celle de $A$), c'est à dire $\\frac{\\gamma_y}{\\gamma_x} < \\frac{K_y}{K_x}$.  \n\nEnsuite pour avoir $B$ entre $A$ et $D$ on va vouloir que la pente de $P_{\\infty}$ soit plus haute que celle de la droite passant par $(0,0)$ et $D$ qu'on appellera $\\aleph$.  \nPour voir ceci on va ajouter la droite $\\aleph$ au plan de phase précédent :\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\n## Ajout de la droite :\nax2.plot(xt, (rx * Ky)/(ry * Kx) * xt, color = 'C5', label = \"Droite א\")\n\nax2.legend(loc=\"upper left\")\n\ndisplay(fig2)\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-9-output-1.png){width=658 height=482}\n:::\n:::\n\n\nNous avons calculé dans la partie précédente que $D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} )$ ce qui ne change pas dans cette partie car on considère des quantités indépendantes des taux de migration.  \n\nLa pente de la droite passant par $D$ et $(0,0)$ est donc égale à $\\frac{r_xK_y}{r_yK_x}$ ce qui donne la condition suivante $\\frac{\\gamma_y}{\\gamma_x} > \\frac{r_xK_y}{r_yK_x}$.\n\n**Si $\\frac{r_xK_y}{r_yK_x} < \\frac{\\gamma_y}{\\gamma_x} < \\frac{K_y}{K_x}$ on a un système inflationiste.**\n\nIl est alors aisé de voir que si la pente de $P_{\\infty}$ est plus petite que celle de $\\aleph$ on a les équilibres qui parcourent d'abord des valeurs au dessus de $d$ puis en dessous (pour aller de $A$ à $C$). \n\nLa condition mathématique est donc la suivante :\n\n**Si $\\frac{\\gamma_y}{\\gamma_x} < \\frac{r_xK_y}{r_yK_x}$ alors le système est d'abord inflationiste puis déflationiste.**  \n\n### Animation\n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\nimport IPython.display as display\nfig01 = \"\"\"\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \" style=\"border: 1px solid black\"></iframe>\n\"\"\"\ndisplay.HTML(fig01)\n```\n\n::: {#fig-anim .cell-output .cell-output-display execution_count=9}\n```{=html}\n\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \" style=\"border: 1px solid black\"></iframe>\n```\n\nAnimation Geogebra permettant de voir quels paramètres influencent le système.\n:::\n:::\n\n\n## Somme des équilibres en fonction de la migration\n\n### Illustration des propositions précédentes\n\nOn va illustrer les propositions précédentes en traçant la somme des équilibres en fonction de $\\beta$.\nPour cela on va simuler avec `odeint` (pendant un temps assez large pour atteindre l'équilibre) pour chaque valeur de $\\beta$. \n\nOn définit une fonction qui dépend de $\\beta$ : \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, gy = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n```\n:::\n\n\net on pose le temps d'intégration, les paramètres et les conditions initiales :\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\n\n#4:\nrx4 = 1\nry4 = 2\nKx4 = 2\nKy4 = 1.5\ngx4 = 2\ngy4 = 0.8\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4, gx4, gy4])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 100, 0.01)\n\n#Condition initiale:\ne0 = [1, 1]\n```\n:::\n\n\nEt enfin on trace les quatre figures :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nfig, (ax, ax1, ax2, ax3) = plt.subplots(1, 4, figsize = (9, 4))\nplt.subplots_adjust(wspace = 0.5)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i)) #On calcule pour chaque beta l'équilibre\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n\nfor i in np.arange(0, 10, 0.01):\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n    s3 = odeint(aug2, e0, t, args = (param4, i))\n    ax3.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n#Plot de la droite Kx+Ky:    \nxt = np.arange(0, 4, 0.01)\nxt2 = np.arange(0, 10, 0.001)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt2, (Kx2 + Ky2) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.10, Kx2 + Ky2 + 0.006, '$K_x+K_y$')\n\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.12, Kx3 + Ky3 + 0.006, '$K_x+K_y$')\n\nax3.plot(xt2, (Kx4 + Ky4) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax3.text(3.12, Kx4 + Ky4 + 0.006, '$K_x+K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax2.set_xlabel('β')\nax3.set_xlabel('β')\nax.set_ylabel('Population')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\n\n#On déplace la légende hors de la figure:\nax.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5))\n\n#Titres:\nax.set_title('Déflation');\nax1.set_title('Les deux');\nax2.set_title('Inflation');\nax3.set_title('Inflation');\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-13-output-1.png){width=741 height=411}\n:::\n:::\n\n\nOn obtient 4 profils de courbe. Le premier profil montre une déflation du système et a été obtenu pour la condition décrite plus haut de $\\frac{\\gamma_y}{\\gamma_x} > \\frac{K_y}{K_x}$.  \n\nLe deuxième profil correspond à une inflation du système puis une déflation quand $\\beta$ augmente, cette courbe a bien été obtenue en respectant la condition de $\\frac{\\gamma_y}{\\gamma_x} < \\frac{r_xK_y}{r_yK_x}$.  \n\nLes deux derniers profils, correspondant à une inflation permanente du système, sont obtenus en respectant les conditions décrites plus haut. On obtient deux profils différents, un avec une inflation croissante quand $\\beta$ augmente et l'autre avec une inflation croissante puis décroissante (et qui atteint un plateau).  \nCe phénomène se voit graphiquement sur l'animation ou le plan de phase. En effet, on a dans le premier cas \n$P_{\\infty}$ qui coupe l'ellipse dans sa phase montante (l'écart entre l'ellipse et la droite $d$ augmente) alors que dans le second cas $P_{\\infty}$ coupe l'ellipse alors que l'écart entre celle-ci et $d$ diminue.\n\n### Cas de l'augmentorium \n  \nDans le cas de l'augmentorium il est important de considérer l'équilibre $x^*$ seule par rapport à $K_x$ (sa valeur s'il n'y a pas de migration).  \nEn effet même si on a inflation dans le système, si $x^*<K_x$ alors on considère l'augmentorium comme efficace.\n\nAvec les hyptohèses énoncées plus haut sur la situation de l'augmentorium il n'est pas possible d'obtenir un système inflationiste (indépendamment de si $K_x>K_y$ ou l'inverse). Il est facile de voir ceci grâce à notre animation.\n\nNéanmoins avec des hypothèses plus souples (mais en gardant que $r_x<r_y$), par exemple que les taux de fuites sont plus forts que les taux de migration vers l'augmentorium (dus à une fuite du dispositif par exemple) on va voir que l'augmentorium n'est pas forcément bénéfique.  \nEn effet, on peut, sur le plan de phase tracé plus haut voir que dès que nous sommes dans un cas où on a de l'inflation (et même si on revient sur de la déflaton après) alors on a $x^* > K_x$ ce qui est mauvais pour la culture. \n\nOn va tracer l'équilibre $x^*$ en fonction de $\\beta$ en considérant un cas où le système était déflationiste et un cas où le système était inflationiste (pour la somme des équilibres) :\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"true\"}\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#2:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\nfig, (ax, ax1, ax2) = plt.subplots(1, 3, figsize = (9, 4))\nplt.subplots_adjust(wspace= 0.4)\n\nax.set_title('Equilibre de la culture ($x^*$) avec déflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\nax1.set_title('Equilibre de la culture ($x^*$) avec déflation et inflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\nax2.set_title('Equilibre de la culture ($x^*$)  avec inflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\n\n#Boucle en fonction de beta\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0], marker = '.', color = 'C0')\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0], marker = '.', color = 'C0')\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0], marker = '.', color = 'C0')\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n#Droite Kx:\nxt = np.arange(0, 4, 0.01)\nax.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 - 0.15, '$K_x$')\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 + Ky1 - 0.15, '$K_x + K_y$')\n\nax1.plot(xt, Kx2 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 - 0.15, '$K_x$')\nax1.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 + Ky2 - 0.15, '$K_x + K_y$')\n\nax2.plot(xt, Kx3 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.5, Kx3 - 0.15, '$K_x$')\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.5, Kx3 + Ky3 - 0.15, '$K_x + K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\nax2.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\n\nax.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\nax1.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\nax2.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\n\n# On limite le cadre :\nax1.set_ylim(bottom=1)\nax2.set_ylim(bottom=1)\n\n#On déplace la légende hors de la figure:\nax.legend(bbox_to_anchor = (1, -0.65, 0.5, 0.5))\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n<matplotlib.legend.Legend at 0x7fbe96a8ef80>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-14-output-2.png){width=805 height=434}\n:::\n:::\n\n\nEn bleu on observe le comportement de l'équilibre dans la culture seulement et en gris on retrouve les courbes tracées juste au dessus. On voit bien que dès que le système subit une inflation des équilibres totaux la situation devient mauvaise pour la culture.  \nEn revanche quand on a déflation des équilibres totaux alors la situtaion est bénéfique à la culture.  \n\nIl faut garder en tête que ceci n'est vrai que pour $r_x<r_y$.  \n\n\n\nEnsuite, le taux de fuite est un paramètre clé de notre méthode. On va donc tracer la somme des équilibres et l'équilibre $x^*$ en fonction de $\\gamma_y$.\n\nAttention ! Un fort taux de fuite correspond à un $\\gamma_y$ faible.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code code-fold=\"true\"}\n#Définition d'un nouveau modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\nb = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx1 - 0.1, '$K_x$')\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.01):\n    s = odeint(aug3, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax1.plot(i, s[-1][0], marker = '.', color = 'C0')\n\n#Légendes:\nax1.set_xlabel('Ɣy, Fuite')\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture')\n\nax.set_title('Somme des équilibres en fonction du taux de fuite', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de fuite', fontsize = 7)   \nax.legend();\nax1.legend();\nax.set_ylabel(\"Densité de pop.\");\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-15-output-1.png){width=739 height=372}\n:::\n:::\n\n\nDans la figure gauche on a représenté la somme des équilibres ($x^*+y^*$) de la même manière que précédemment mais cette fois en faisant varier le taux de fuite.  \nOn observe alors un nouveau profil qui correspond à une déflation, puis une inflation puis enfin une déflation au fur et à mesure que $\\gamma_y$ augmente.\n\nDans la figure droite on a cette fois uniquement l'équilibre dans la culture ($x^*$). On observe que pour des $\\gamma_y$ petits on a inflation puis on retourne à une déflation.  \n\nPour interpréter ceci il faut comprendre que les des petites valeurs de $\\gamma_y$ correspondent à de grandes valeurs de taux de fuite.  \nAinsi quand $\\gamma_y \\to 0$ l'augmentorium se vide en ravageurs et on a ainsi toute la population dans la culture et l'équilibre dans culture tend vers sa capacité de charge car on est seulement face à une croissance logistique.  \nC'est pourquoi, lorsque les taux de fuite sont grands on observe une inflation de la culture car on a, des populations de ravageurs qui viennent de l'augmentorium qui s'ajoutent aux ravageurs déjà présents dans la culture.  \nLa somme des équilibres est donc trompeuse dans ce cas là, en effet le système subit une déflation car l'augmentorium n'est presque plus occupé pour de forts taux de fuite mais il ne faut pas croire que c'en est bénéfique pour la culture.\n\n\nCe modèle considère uniquement la population de ravageurs. Or, la méthode de l'augmentorium repose énormément sur l'action des prédateurs on va donc considérer [maintenant](modelaug.qmd) un modèle qui prend en compte ces prédateurs.\n\n",
    "supporting": [
      "modeleavecmigrationass_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}