{
  "hash": "4a2b4a0158c67b89a679fe0ac2f6c969",
  "result": {
    "markdown": "---\ntitle: Modèle logistique structuré avec migration assymétrique\n---\n\n*Modules à importer :*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\n## Définition du modèle\n\nLe but d'un augmentorium est de confiner les ravageurs dans un espace clos qui ne laisse pas (ou peu) s'échapper ceux-ci.  \nAinsi, il s'établit une migration assymétrique entre les deux structures qu'on peut modéliser en établissant le modèle suivant d'après @arditi2018 : \n\n$$ \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n$$ {#eq-modamig}\n\navec :  \n- $x$ la population de ravageurs dans la culture,  \n- $y$ la population de ravageurs dans l'augmentorium,  \n- $r_x$ et $r_y$ le taux de croissance dans la culture et dans l'augmentorium,  \n- $K_x$ et $K_y$ les capacités de charges de la culture de de l'augmentorium,  \n- $\\beta$ la force de migration entre les structures,  \n- $\\gamma_x$ et $\\gamma_y$ caractérisant l'assymétrie de migration.\n\n### Nouvelles hypothèses propres à l'augmentorium\n\nCe modèle est plus proche de celui d'un augmentorium.  \nComme les ravageurs se reproduisent mieux dans l'augmentorium que dans la culture on peut dire que $r_x<r_y$.  \nOn peut aussi dire que le taux de fuite des ravageurs ($\\frac{1}{\\gamma_y}$) se doit d'être beaucoup plus petit que le taux de migration ($\\frac{1}{\\gamma_x}$).  \nOn a donc $\\gamma_x << \\gamma_y$.\n\n## Dynamique du modèle\n\nEncore une fois on simule la dynamique des deux populations en fonction du temps en codant comme dans la première partie\n\nOn définit le système sous [Python](https://www.python.org/):\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b, gx, gy = param\n    x, y = etat\n    s=[rx * x * (1 - x/Kx) + b * (y/gy - x/gx),\n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s\n```\n:::\n\n\nEt on définit les paramètres, le temps d'intégration etc. :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\n# Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n# Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0, y0]\n\n# Paramètres: \n\nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\ngx = 0.5\ngy = 3\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n```\n:::\n\n\nOn trace la figure :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nfig,ax = plt.subplots(1, 1)\nfig.suptitle('Dynamique des ravageurs dans le temps avec augmentorium')\n\nax.plot(ti, s[ :, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[ :, 1], color = 'C0', label = 'augmentorium')\n\n# Ajout d'élements:\nax.grid()\nax.legend()\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-5-output-1.png){width=598 height=477}\n:::\n:::\n\n\nCette dynamique, comme en première partie, présente un équilibre de maintien de la population.  \nNéanmoins on observe que, pour les mêmes paramètres que dans la première partie, la population dans la culture est bien plus faible.    \nLa migration assymétrique vers l'augmentorium semble être bénéfique à la culture.\n\n## Plan de phase \n\n### Equilibres et leur stabilité \n\nA l'équilibre on a le système suivant :\n\n$$ \n\\left\\{\\begin{array}{l}\n\\dot x = 0 \\Leftrightarrow 0 = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = 0 \\Leftrightarrow 0 = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n$${#eq-pdpamig0}\n$$\n\\Leftrightarrow\n$$\n$$ \n\\left\\{\\begin{array}{l}\ny^*=\\gamma_y\\left(\\frac{x}{\\gamma_x}-\\frac{r_xx}{\\beta}\\left(1-\\frac{x}{K_x}\\right)\\right)\\\\\nx^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)\n\\end{array}\\right.\n$${#eq-pdpamig}\n\nOn voit tout de suite qu'on a deux paraboles qui se croisent en $(0,0)$ et en $(x^*,y^*)$.  \nOn va donc avoir deux équilibres, ceux-ci vivent sur une ellipse de même équation qu'en première partie.   \n\nEn fonction des racines des paraboles on va avoir des plans de phases différents qu'on va tracer via les mêmes techniques qu'en première partie :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\n#On crée la figure avec les 3 sous figures:\nfig2, (ax2, ax3, ax4) = plt.subplots(1, 3, figsize = (9, 4))\n\nfig2.suptitle('Plan de phase de la population')\nax2.set_title('β=1')\nax3.set_title('β=10')\nax4.set_title('β=0.1')\n\n#Plan de phase 1:#\n# Paramètres: \nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\nb1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam_aug1 = np.array([rx1, ry1, Kx1, Ky1, b1, gx1, gy1])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy1 * (xt/gx1 - rx1 * xt/b1 * (1 - xt/Kx1)), color = 'C2', label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax2.plot(gx1 * (yt/gy1 - ry1 * yt/b1 * (1 - yt/Ky1)), yt, color = 'C3', label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax2.set_xlim(left = -0.03, right = 0.5)\nax2.set_ylim(top = 1.5, bottom = -0.06)\n\nax2.set_xlabel('Ravageur dans la culture', fontsize = '12');\nax2.set_ylabel('Ravageur dans l\\'augmentorium', fontsize = '12');\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\nX, Y = np.meshgrid(xg, yg)\n\n#On utilise quiver:\ndx, dy = aug([X, Y], 0, param_aug1)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 15, width = 0.0035);\n\n#Plan de phase 2:#\n#Paramètres: \nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\nb2 = 10\ngx2 = 0.5\ngy2 = 3\n\nparam_aug2 = np.array([rx2, ry2, Kx2, Ky2, b2, gx2, gy2])  \n\n#Isocline nulles:\n#xdot = 0\nax3.plot(xt, gy2 * (xt/gx2 - rx2 * xt/b2 * (1 - xt/Kx2)), color = 'C2', label = '$\\dot x=0$')\nax3.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax3.plot(gx2 * (yt/gy2 - ry2 * yt/b2 * (1 - yt/Ky2)), yt, color = 'C3', label = '$\\dot y=0$')\nax3.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax3.set_xlim(left = -0.02, right = 0.35)\nax3.set_ylim(top = 1.4, bottom = -0.06)\n\nax3.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\n\nX, Y = np.meshgrid(xg, yg)\n\n#On utilise quiver:\ndx, dy = aug([X, Y], 0, param_aug2)\nax3.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 40, width = 0.003);\n\n#Plan de phase 3:\n#Paramètres: \nrx3 = 0.5\nry3 = 1\nKx3 = 2\nKy3 = 1\nb3 = 0.1\ngx3 = 0.5\ngy3 = 3\n\nparam_aug3=np.array([rx3, ry3, Kx3, Ky3, b3, gx3, gy3])\n\n#Isocline nulles:\n#xdot = 0 \nax4.plot(xt, gy3 * (xt/gx3 - rx3 * xt/b3 * (1 - xt/Kx3)), color = 'C2', label = '$\\dot x=0$')\nax4.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0 \nax4.plot(gx3 * (yt/gy3 - ry3 * yt/b3 * (1 - yt/Ky3)), yt, color = 'C3', label = '$\\dot y=0$')\nax4.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration:\nax4.set_xlim(left = -0.08, right = 1.9)\nax4.set_ylim(top=1.5, bottom = -0.06)\n\nax4.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n# Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.18)\nyg = np.arange(-0.5, 3, 0.18)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug3)\nax4.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 10, width = 0.0035);\n\n#On légende:\nax4.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-6-output-1.png){width=740 height=396}\n:::\n:::\n\n\nEn fonction des valeurs de $\\beta$ on observe des profils différents de plan de phase. Pour mieux le visualiser on pourra utiliser l'animation [Geogebra](@fig-anim) mise à disposition à la fin de l'analyse.\n\nD'après le champ de vecteurs on voit clairement que l'équilibre en $(0,0)$ est instable et l'équilibre $(x^*,y^*)$ est stable.  \n\nPour calculer l'équilibre on procède de la même manière que dans la première partie, c'est à dire en croisant les deux paraboles $\\dot =0 $ et $\\dot y =0$ :\nOn a $x^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)$.  \nDonc :\n$$\\small\ny^*=\\gamma_y\\left(\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\gamma_x}-\\frac{r_x\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\beta}\\left[1-\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{K_x}\\right]\\right)\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n-\\frac{r_y\\gamma_yy^*}{\\beta} + \\frac{r_y \\gamma_y {y^*}^2}{\\beta K_y} - \\frac{r_x\\gamma_xy^*}{\\beta} + \\frac{r_xr_y\\gamma_x \\gamma_y y^*}{\\beta^2} \\\\\n- \\frac{r_xr_y\\gamma_x\\gamma_y{y^*}^2}{\\beta^2K_y} + \\frac{r_x\\gamma_x^2{y^*}^2}{\\beta K_x\\gamma_y} - \\frac{r_xr_y\\gamma_x^2{y^*}^2}{\\beta^2K_x} \\\\\n+ 2\\frac{r_xr_y\\gamma_x^2{y^*}^3}{\\beta^2K_xK_y} + \\frac{r_xr_y^2\\gamma_x^2 \\gamma_y {y^*}^2}{\\beta^3K_x} - 2\\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^3}{\\beta^3K_xK_y} \\\\\n+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^4}{\\beta^3K_xK_y^2}\n$$\n\nCe qui donne, en mettant les monomes $y^*$ en facteur et en simplifiant ensuite par $\\frac{y^*}{\\beta}$ :  \n$$\n\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta}-\\gamma_yr_y-\\gamma_xr_x +\\\\ y\\left[\\frac{r_y\\gamma_y}{K_y}-\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta K_y}+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y}{\\beta^2K_x}+\\frac{r_x\\gamma_x^2}{\\gamma_yK_x}-\\frac{2r_xr_y\\gamma_x^2}{\\beta K_x}   \\right] +\\\\[.2cm]\n\\frac{2r_yr_x\\gamma_x^2y^2}{\\beta K_xK_y}\\left(1-\\frac{r_y\\gamma_y}{\\beta}\\right) + \\frac{r_xr_y^2\\gamma_x^2\\gamma_yy^3}{\\beta^2K_xK_y^2} = 0\n$${#eq-pol}\n\nCe polynôme est résoluble par `numpy` similairement à la première partie :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\n# Paramètres pour calculer le polynôme\nrx = 0.5\nry = 1\nKx = 2.5\nKy = 2\nb = 1\ngx = 1.5\ngy = 3\n\n#Points d'équilibres, utilisation de numpy : monome, polynome et racines:\n#Calcul:\n#Monome y\nx = np.polynomial.Polynomial([0, 1])\n\n#Polynome :\npol = -gy * ry - gx * rx + (rx * ry * gx * gy)/b + x * ((ry * gy)/(Ky) - (ry * rx * gy * gx)/(b * Ky) + \\\n rx * ry**2 * gx**2 * gy/(b**2 * Kx) + rx * gx**2/(gy * Kx) - 2 * rx * ry * gx**2/(b * Kx)) + \\\n (x**2) * 2 * (ry * rx *gx**2)/(b * Kx * Ky) * (1 - ry * gy/b) + (x**3) * gy * rx * ((ry * gx)**2)/(b**2 * Kx * Ky**2)\n\n#Solution\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() > 0)]\nyeq = sol[0].real\n\n#Calcul de x avec sa définition:\nxeq = gx * (yeq/gy - ry * yeq/b * (1 - yeq/Ky))\n```\n:::\n\n\n### Analyse du plan de phase\n\nOn va tracer le plan de phase complet et l'analyser d'après la méthode de @arditi2018 :  \n\nDans cette analyse on va considérer, sans perte de généralité, que $r_x < r_y$ (on prend l'ellipse dans un seul sens, voir l'[animation](@fig-anim)).\n\nPour cela on trace l'ellipse de la même manière que dans la première figure, l'équation de cette ellipse n'ayant pas de terme de migration dans le premier modèle elle est la même dans celui-ci aussi.  \n\nEnsuite on va tracer la droite $d$ correspondant à $K_x+K_y=x^*+y^*$ car ceci va permettre de voir si le système subit une [inflation](contexte.qmd) ou une déflation.  \n\nEnfin, similairement à la partie prédédente on va tracer les droites données par $\\beta = 0$ et $\\beta = +\\infty$ dans la parabole définie par $\\dot x =0$ (parabole verte sur le plan de phase).  \nLes droites sont différentes du modèle précédent donc on va les recalculer :\n\nLorsque $\\beta = 0$ on a exactement les mêmes deux droites que dans le modèle précédent en $x^* =0$ et en $x^*=K_x$ car le fait que le nouveau modèle ajoute de l'assymétrie dans les migrations est effacé par une migration nulle. On les appelle respectivement $P_{10}$ et $P_{20}$.\n\nLorsque $\\beta = +\\infty$ on a d'après ([-@eq-pdpamig]) : \n$$\ny^* = \\frac{\\gamma_y}{\\gamma_x}x^*\n$$\n\nOn appellera cette droite $P_{\\infty}$.  \n\n\nIntroduisons les mêmes points que précédemment c'est à dire : \n\n- $A$, l'intersection entre $P_{20}$  et l'ellipse, c'est à dire la valeur de l'équilibre quand $\\beta = 0$.\n\n- $B$, l'intersection entre $P_{\\infty}$ et l'ellipse, c'est à dire la valeur de l'équilibre quand $\\beta = +\\infty$.\n\n- $C$, l'intersection entre $P_{20}$ et $P_{\\infty}$.\n\n- $D$, l'intersection entre la droite $d$ et l'ellipse qui n'est pas $A$.\n\nReprésentons le plan de phase avec ces éléments :\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\n#On crée la figure:\nfig2, ax2 = plt.subplots(1, 1, figsize = (8, 5))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase:\n# Paramètres égaux à ceux utilisés pour calculer les équilibres:\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy * (xt/gx - rx * xt/b * (1 - xt/Kx)), color = 'C2', label = '$\\dot x = 0$')\n\n#ydot = 0\nax2.plot(gx * (yt/gy - ry * yt/b * (1 - yt/Ky)), yt, color = 'C3', label = '$\\dot y = 0$')\n\n#Cadrage:\nax2.set_xlim(left = -0.30, right = 4.5)\nax2.set_ylim(top = 6, bottom = -0.70)\n\nax2.set_xlabel('$x^*$', fontsize = '12')\nax2.set_ylabel('$y^*$', fontsize = '12')\n\n#Axe x et y:\nax2.plot(xt, np.zeros_like(xt), color = 'k', linestyle = 'dashed')\nax2.plot(np.zeros_like(yt), yt, color = 'k', linestyle = 'dashed')\n\n#Droite capacité:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = \"0.8\")\n\n#Plot des équilibres:\nax2.plot(xeq, yeq, label = 'Equilibre stable', marker = '.', markersize = 12)\nax2.plot(0, 0, label = 'Equilibre Instable', marker = '.', markersize = 12, color = 'C5')\n\n#Ellipse:\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole β = 0')\nax2.plot(np.zeros_like(xt), xt, color = 'C9')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt, xt * gy/gx, color = 'C6', label = 'Parabole β = $+\\infty$')\n\n#A:\nax2.plot(Kx, Ky, color = 'black', marker = '.')\nax2.text(Kx - 0.1, Ky - 0.1, '$A$')\n\n#C:\nax2.plot(Kx, gy * Kx/gx, color = 'black', marker = '.')\nax2.text(Kx, gy * Kx/gx - 0.1, 'C')\n\n#B:\nax2.plot(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky),((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) \\\n                                        , color = 'black', marker = '.')\n\nax2.text(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) - 0.1, ((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) + 0.1 \\\n                                        , '$B$')\n\n#D:\nax2.plot(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx), rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx), color = 'black', marker = '.')\nax2.text(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, '$D$')\n\n#Légende:\nax2.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-8-output-1.png){width=658 height=482}\n:::\n:::\n\n\n#### a) Première condition de déflation\n\nLa première condition d'inflation est exactement la même que dans le modèle précédent et la preuve est en tout point égale (elle repose sur une analyse de l'équation de l'ellipse qui est la même dans les deux modèles). On ne détaillera pas ici cette preuve mais on sait donc que :\n\nSi $r_x = r_y$ alors le système est tout le temps déflationiste.\n\n#### b) Deuxième condition de déflation\n\nNous allons faire une preuve graphique de cette condition similaire à l'ancien modèle.  \n\nL'équilibre vit sur l'ellipse et parcourt l'arc orange entre $A$ et $B$ au fur et à mesure que $\\beta$ augmente.   \nAinsi pour avoir déflation on va vouloir avoir cet arc entièrement sous la droite $d$ en gris.  \nIl est alors facile de voir que pour cela on veut que la coordonnée en $y$ de $C$ soit plus grande que celle de $A$ ($C$ est plus haut sur la droite cyan que $A$), entraînant que la coordonnée en $x$ de $B$ est plus petite que celle de $A$ ($B$ se trouve plus à gauche sur l'ellipse que $A$).  \n\nPour cela on a besoin de connaître les coordonnées de $A$ et $C$.  \n\n\n\n\n\n\n\n\n\n- Si on note $A$ l'intersection entre la parabole en $0$ et l'ellipse et $B$ l'intersection entre la parabole en $0$ et en $+\\infty$ alors pour que $x^* < K_x$ (ce que l'on veut) il faut que la coordonnée en $y$ de $B$ soit supérieur à celle de $A$.\n\n    Le point $A$ est défini par :\n    $A=(K_x,K_y)$\n\n    Le point $B$ est défini par :\n    $B=\\left(K_x,\\frac{\\gamma_yK_x}{\\gamma_x}\\right)$\n\nAutrement dit, **si** $\\frac{\\gamma_y}{\\gamma_x}>\\frac{K_y}{K_x}$ alors on a toujours l'augmentorium qui est efficace, ie le système est déflationiste quelque soit le taux de migration $\\beta$.\n\n---   \n\n- Si on note $C$ l'intersection entre l'ellipse et la parabole en $+\\infty$ on a alors la valeur de l'équilibre en $\\beta =+\\infty$.\n  \n    Le point $C$ est défini par :\n    $C=\\left(\\frac{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)r_x + r_y}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} , \\frac{\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)r_y + r_x}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} \\right)$\n  \n    Maintenant notons $D$ la valeur de l'intersection entre le droite des capacités et l'ellipse.\n  \n    Le point $D$ est défini par :\n    $D=\\left(\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xKy+r_yK_x}\\right)$  \n  \n    Ainsi, quand $\\beta$ augmente le point d'équilibre se déplace entre $A$ et $C$. On voit donc que l'équilibre peut soit être tout le temps déflationiste si $C$ est avant $A$ (point précédent) sur l'ellipse soit être constamment inflationiste si $C$ est entre $A$ et $D$ soit être les deux si $C$ est après $D$.\n  \n    Voyons ceci en terme de coefficient de droite, on a alors les exactes mêmes conditions mais sur les pentes des droites passant par ces points, qu'on peut calculer.\n    On a déja par le premier point la condition sur les paramètres pour avoir le système déflationiste.\n  \n**Si** $\\frac{\\gamma_y}{\\gamma_x} < \\frac{r_xK_y}{r_yK_x}$ alors on a des équilibres à la fois inflationiste et déflationiste. En effet ceci traduit que C est après D, graphiquement on voit que l'équilibre est au début au dessus de la droite cyan et à la fin en dessous (après avoir passé D).   \n\n**Si** $\\frac{r_xK_y}{r_yK_x} < \\frac{\\gamma_y}{\\gamma_x} < \\frac{K_y}{K_x}$ alors les équilibres sont constamment inflationiste. \n\n---\n\n-  Enfin on observe que si la droite cyan est tangente à l'ellipse alors on a que le système est constamment déflationiste. Ceci correspond au même calcul que dans la première partie et on trouve que **si** $r_x=r_y$ le système est tout le temps déflationiste pour tout $\\beta$.\n\n---\n\nMaintenant si on prend $r_x>r_y$ on a un autre cas qui apparaît d'après @gao2022\nEn effet, et on le voit bien sur l'animation, on peut alors avoir $C$ entre $D$ et $A$ avec $C$ plus haut que $A$ et ainsi on peut avoir un cas où le système est complètement inflationiste avec des valeurs de la somme des équilibres plus grands que $C$.\nCette situation ne nous intéresse que peu car ce n'est pas un cas qui est biologiquement réaliste.\n\n##### Preuves: \n\n- Point $B$:  \n  La première coordonnée est forcément $K_x$ car on considère le croisement avec la parabole en $\\beta = 0$.  \n  On sait que la parabole en $\\beta = +\\infty$ est définie par $y = \\frac{\\gamma_y}{\\gamma_x}x$.  \n  On a le résultat pour $x=K_x$.\n  \n- Point $C$:  \n  La parabole en $\\beta = +\\infty$\n est définie par $y = \\frac{\\gamma_y}{\\gamma_x}x$ et l'ellipse par $r_xx\\left(1-\\frac{x}   {K_x}\\right) + r_yy\\left(1-\\frac{y}{K_y}\\right) = 0$. Il suffit de remplacer dans l'expression de l'ellipse la valeur de y donnée par la parabole pour trouver la première coordonnée.   \n  Pour trouver la deuxième on utilise l'expression de la parabole.\n\n- Point $D$:\n  On fait la même que précédemment. La droite des capacités est définie par $y= -x +K_x+K_y$ qu'on remplace dans l'expression de l'ellipse pour trouver la première coordonnée (après simplification). La deuxième est déduite de la la première grâce à l'expression de la droite. \n  \nPour les conditions sur les équilibres on se rappelle que la pente de la parabole en $\\beta = +\\infty$ est définie par $\\frac{\\gamma_y}{\\gamma_x}$.   \nAinsi, quand cette pente est inférieure à celle de la droite passant par le point $D$ (qui a une pente de $\\frac{r_xK_y}{r_yK_x}$) on a soit déflationiste soit inflationiste. \nOn a donc pour condition $\\frac{\\gamma_y}{\\gamma_x} < \\frac{r_xK_y}{r_yK_x}$.  \n  \nEnsuite pour que le système soit entièrement inflationiste on veut que la pente de $\\beta = +\\infty$ soit entre celle de la droite passant par $D$ et celle passant par $A$ (première condition détaillée au premier point de l'analyse.) \nCeci donne le résultat.\n\n### Animation\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nimport IPython.display as display\nfig01 = \"\"\"\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \" style=\"border: 1px solid black\"></iframe>\n\"\"\"\ndisplay.HTML(fig01)\n```\n\n::: {#fig-anim .cell-output .cell-output-display execution_count=8}\n```{=html}\n\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \" style=\"border: 1px solid black\"></iframe>\n```\n\nAnimation Geogebra permettant de voir quels paramètres influencent le système.\n:::\n:::\n\n\n## Somme des équilibres en fonction de la migration\n\n### Illustration des propositions précédentes\n\nOn va illustrer les propositions précédentes en traçant la somme des équilibres en fonction de $\\beta$.\nPour cela on va simuler avec `odeint` (pendant un temps assez large pour atteindre l'équilibre) pour chaque valeur de $\\beta$. \n\nOn définit une fonction qui dépend de $\\beta$ : \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, gy = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n```\n:::\n\n\net on pose le temps d'intégration, les paramètres et les conditions initiales :\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\n\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4, gx4, gy4])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 100, 0.01)\n\n#Condition initiale:\ne0 = [1, 1]\n```\n:::\n\n\nEt enfin on trace les quatre figures :\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfig, (ax, ax1, ax2, ax3) = plt.subplots(1, 4, figsize = (9, 4))\nplt.subplots_adjust(wspace = 0.5)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i)) #On calcule pour chaque beta l'équilibre\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n    s3 = odeint(aug2, e0, t, args = (param4, i))\n    ax3.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n    \n    \nfor i in np.arange(0, 4, 0.001):\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n\n#Plot de la droite Kx+Ky:    \nxt = np.arange(0, 4, 0.01)\nxt2 = np.arange(0, 4, 0.001)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt2, (Kx2 + Ky2) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.10, Kx2 + Ky2 + 0.006, '$K_x+K_y$')\n\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.12, Kx3 + Ky3 + 0.006, '$K_x+K_y$')\n\nax3.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax3.text(3.12, Kx4 + Ky4 + 0.006, '$K_x+K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax2.set_xlabel('β')\nax3.set_xlabel('β')\nax.set_ylabel('Population')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\n\n#On déplace la légende hors de la figure:\nax.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5))\n\n#Titres:\nax.set_title('Déflation')\nax1.set_title('Les deux')\nax2.set_title('Inflation')\nax3.set_title('Inflation')\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nText(0.5, 1.0, 'Inflation')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-12-output-2.png){width=754 height=411}\n:::\n:::\n\n\nOn voit donc que la structuration de l'espace peut causer dans plusieurs cas une inflation. C'est ce que l'on souhaite éviter à tout prix avec l'augmentorium.   \n\nMais, les hypothèses sur l'augmentorium limitent les situations qu'on peut atteindre.   \nEn effet, comme $r_x<r_y$ la quatrième situation est impossible. \nDe plus, comme $\\gamma_x << \\gamma_y$ on a $\\frac{\\gamma_y}{\\gamma_x}>>1$. Et, puisque la capacité K entre l'augmentorium et la culture diffère en fonction des types de cultures mais reste généralement proche entre les deux.   \nAinsi le rapport entre ces deux capacités est proche de 1 que ce soit inférieurement ou supérieurement.   \nOn a donc en permanence dans les cultures la condition $\\frac{\\gamma_y}{\\gamma_x}>\\frac{K_y}{K_x}$ ce qui implique une déflation de la somme des équilibres par rapport à la capacité totale.\n\n### Cas de l'augmentorium \n  \nDans le cas de l'augmentorium il est important de considérer l'équilibre $x^*$ seule par rapport à $K_x$ (sa valeur s'il n'y a pas de migration). En effet même si on a inflation dans le système si $x^*<K_x$ alors on considère l'augmentorium comme efficace.\n\nOn va donc tracer l'équilibre $x^*$ en fonction de $\\beta$ en considérant que soit $K_x < K_y$ soit $K_x > K_y$ :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code code-fold=\"true\"}\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 1\nKy2 = 2\ngx2 = 0.5\ngy2 = 3\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\nax.set_title('Equilibre de la culture en fonction du taux de migration avec $K_x>K_y$', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de migration avec $K_x<K_y$', fontsize = 7)\n\n#Boucle en fonction de beta\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0], marker = '.', color = 'C0')\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0], marker = '.', color = 'C0')\n\n#Droite Kx:\nxt = np.arange(0, 4, 0.01)\nax.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 - 0.1, '$K_x$')\n\nax1.plot(xt, Kx2 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 - 0.1, '$K_x$')\n\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax.plot(0, 0, color = 'C0', label = 'Eq. culture')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture')\n\nax.legend()\nax1.legend()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n<matplotlib.legend.Legend at 0x7f9b974377c0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-13-output-2.png){width=736 height=372}\n:::\n:::\n\n\nOn observe que quelque soit le type de culture on a efficacité de l'augmentorium. \n\n\nEnsuite, comme le taux de fuite est un paramètre clé de notre méthode. On va donc tracer la somme des équilibres et l'équilibre $x^*$ en fonction de $\\gamma_y$.  \n\nAttention, un fort taux de fuite correspond à un $\\gamma_y$ faible.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"true\"}\n#Définition d'un nouveau modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\nb = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx1 - 0.1, '$K_x$')\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.01):\n    s = odeint(aug3, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax1.plot(i, s[-1][0], marker = '.', color = 'C0')\n\n#Légendes:\nax1.set_xlabel('Ɣy, Fuite')\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture')\n\nax.set_title('Somme des équilibres en fonction du taux de fuite', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de fuite', fontsize = 7)   \nax.legend()\nax1.legend()\nax.set_ylabel(\"Densité de pop.\")\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nText(0, 0.5, 'Densité de pop.')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-14-output-2.png){width=739 height=372}\n:::\n:::\n\n\nOn observe que la somme des équilibres de la population de ravageurs en fonction du taux de fuite a une forme que nous n'avions pas eu.   \nIl est possible en passant par l'animation geogebra de voir ceci en modifiant le taux de fuite. \nOn a pour des fortes fuites un système déflationiste, puis une petite zone inflationiste et enfin de nouveau une zone déflationiste. Ceci est paradoxal car on est entrain de dire que un fort taux de fuite encourage une déflation du système et donc une efficacité de la technique de l'augmentorium. \n    \nIl faut donc chercher plus en détail et exprimer l'équilibre dans la culture en fonction de la fuite. En effet, c'est ce qui nous intéresse le plus car l'équilibre dans l'augmentorium n'est pas important pour la lutte biologique.  \nOn voit que l'équilibre dans la culture est d'abord inflationiste pour des forts taux de fuites et ensuite déflationiste pour des taux de fuites faibles. On a ici le résultat logique auquel on s'attendait qui est que l'augmentorium n'est pas efficace si la fuite est trop forte. \n\nDonc si le taux de fuite est très mal géré l'augmentorium peut être négatif pour la culture. \n\n\n## Conclusion\n\nCe modèle considère uniquement la population de ravageurs. Or, la méthode de l'augmentorium repose énormément sur l'action des prédateurs on va donc considérer [maintenant](modelaug.qmd) un modèle qui prend en compte ces prédateurs.\n\n",
    "supporting": [
      "modeleavecmigrationass_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}