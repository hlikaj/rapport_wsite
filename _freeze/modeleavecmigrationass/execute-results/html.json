{
  "hash": "ba0ab67afc86d5b5f29b3c737103b84c",
  "result": {
    "markdown": "---\ntitle: Modèle logistique structuré avec migration asymétrique\n---\n\n*Modules à importer :*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\n## Définition du modèle\n\nLe but d'un augmentorium est de confiner les ravageurs dans un espace clos qui ne laisse pas (ou peu) s'échapper ceux-ci.  \nAinsi, il s'établit une migration asymétrique entre les deux structures que nous pouvons modéliser en établissant le modèle suivant d'après @arditi2018 : \n\n$$ \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n$$ {#eq-modamig}\n\navec :  \n- $x$ la population de ravageurs dans la culture,  \n- $y$ la population de ravageurs dans l'augmentorium,  \n- $r_x$ et $r_y$ le taux de croissance dans la culture et dans l'augmentorium,  \n- $K_x$ et $K_y$ les capacités de charges de la culture de de l'augmentorium,  \n- $\\beta$ la force de migration entre les structures,  \n- $\\gamma_x$ et $\\gamma_y$ caractérisant l'asymétrie de migration.\n\n### Nouvelles hypothèses propres à l'augmentorium\n\nCe modèle est plus proche de celui d'un augmentorium.  \nComme les ravageurs se reproduisent mieux dans l'augmentorium que dans la culture nous pouvons dire que $r_x<r_y$.  \nNous pouvons aussi dire que le taux de fuite des ravageurs ($\\frac{1}{\\gamma_y}$) se doit d'être beaucoup plus petit que le taux de migration ($\\frac{1}{\\gamma_x}$).  \nNous avons donc $\\gamma_x << \\gamma_y$.\n\n## Dynamique du modèle\n\nEncore une fois nous simulons la dynamique des deux populations en fonction du temps en codant comme dans la première partie\n\nNous définissons le système sous [Python](https://www.python.org/):\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b, gx, gy = param\n    x, y = etat\n    s=[rx * x * (1 - x/Kx) + b * (y/gy - x/gx),\n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s\n```\n:::\n\n\nEt nous définissons les paramètres, le temps d'intégration etc. :\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\n# Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n# Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0, y0]\n\n# Paramètres: \n\nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\ngx = 0.5\ngy = 3\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n```\n:::\n\n\nNous traçons la figure :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nfig,ax = plt.subplots(1, 1)\nfig.suptitle('Dynamique des ravageurs dans le temps avec augmentorium')\n\nax.plot(ti, s[ :, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[ :, 1], color = 'C0', label = 'augmentorium')\n\n# Ajout d'élements:\nax.grid()\nax.legend()\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n```\n\n::: {.cell-output .cell-output-display}\n![Dynamique du modèle](modeleavecmigrationass_files/figure-html/figdyn-output-1.png){#figdyn width=598 height=477}\n:::\n:::\n\n\nCette dynamique, comme en première partie, présente un équilibre de maintien de la population.  \nNéanmoins nous observons que, pour les mêmes paramètres que dans la première partie, la population dans la culture est bien plus faible.    \nLa migration asymétrique vers l'augmentorium semble être bénéfique à la culture.\n\n## Plan de phase \n\n### Equilibres et leur stabilité \n\nA l'équilibre nous avons le système suivant :\n\n$$ \n\\left\\{\\begin{array}{l}\n\\dot x = 0 \\Leftrightarrow 0 = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = 0 \\Leftrightarrow 0 = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n$${#eq-pdpamig0}\n$$\n\\Leftrightarrow\n$$\n$$ \n\\left\\{\\begin{array}{l}\ny^*=\\gamma_y\\left(\\frac{x}{\\gamma_x}-\\frac{r_xx}{\\beta}\\left(1-\\frac{x}{K_x}\\right)\\right)\\\\\nx^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)\n\\end{array}\\right.\n$${#eq-pdpamig}\n\nNous voyons tout de suite que nous avons deux paraboles qui se croisent en $(0,0)$ et en $(x^*,y^*)$.  \nNous allons donc avoir deux équilibres, ceux-ci vivent sur une ellipse de même équation qu'en première partie.   \n\nEn fonction des racines des paraboles nous allons avoir des plans de phases différents que nous allons tracer via les mêmes techniques qu'en première partie :\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\n#Nous créons la figure avec les 3 sous figures:\nfig2, (ax2, ax3, ax4) = plt.subplots(1, 3, figsize = (9, 4))\n\nfig2.suptitle('Plan de phase de la population')\nax2.set_title('β=1')\nax3.set_title('β=10')\nax4.set_title('β=0.1')\n\n#Plan de phase 1:#\n# Paramètres: \nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\nb1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam_aug1 = np.array([rx1, ry1, Kx1, Ky1, b1, gx1, gy1])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy1 * (xt/gx1 - rx1 * xt/b1 * (1 - xt/Kx1)), color = 'C2', label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax2.plot(gx1 * (yt/gy1 - ry1 * yt/b1 * (1 - yt/Ky1)), yt, color = 'C3', label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax2.set_xlim(left = -0.03, right = 0.5)\nax2.set_ylim(top = 1.5, bottom = -0.06)\n\nax2.set_xlabel('Ravageur dans la culture', fontsize = '12');\nax2.set_ylabel('Ravageur dans l\\'augmentorium', fontsize = '12');\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\nX, Y = np.meshgrid(xg, yg)\n\n#Nous utilisons quiver:\ndx, dy = aug([X, Y], 0, param_aug1)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 15, width = 0.0035);\n\n#Plan de phase 2:#\n#Paramètres: \nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\nb2 = 10\ngx2 = 0.5\ngy2 = 3\n\nparam_aug2 = np.array([rx2, ry2, Kx2, Ky2, b2, gx2, gy2])  \n\n#Isocline nulles:\n#xdot = 0\nax3.plot(xt, gy2 * (xt/gx2 - rx2 * xt/b2 * (1 - xt/Kx2)), color = 'C2', label = '$\\dot x=0$')\nax3.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax3.plot(gx2 * (yt/gy2 - ry2 * yt/b2 * (1 - yt/Ky2)), yt, color = 'C3', label = '$\\dot y=0$')\nax3.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax3.set_xlim(left = -0.02, right = 0.35)\nax3.set_ylim(top = 1.4, bottom = -0.06)\n\nax3.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\n\nX, Y = np.meshgrid(xg, yg)\n\n#Nous utilisons quiver:\ndx, dy = aug([X, Y], 0, param_aug2)\nax3.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 40, width = 0.003);\n\n#Plan de phase 3:\n#Paramètres: \nrx3 = 0.5\nry3 = 1\nKx3 = 2\nKy3 = 1\nb3 = 0.1\ngx3 = 0.5\ngy3 = 3\n\nparam_aug3=np.array([rx3, ry3, Kx3, Ky3, b3, gx3, gy3])\n\n#Isocline nulles:\n#xdot = 0 \nax4.plot(xt, gy3 * (xt/gx3 - rx3 * xt/b3 * (1 - xt/Kx3)), color = 'C2', label = '$\\dot x=0$')\nax4.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0 \nax4.plot(gx3 * (yt/gy3 - ry3 * yt/b3 * (1 - yt/Ky3)), yt, color = 'C3', label = '$\\dot y=0$')\nax4.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration:\nax4.set_xlim(left = -0.08, right = 1.9)\nax4.set_ylim(top=1.5, bottom = -0.06)\n\nax4.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n# Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.18)\nyg = np.arange(-0.5, 3, 0.18)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug3)\nax4.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 10, width = 0.0035);\n\n#Nous légendons:\nax4.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-6-output-1.png){width=740 height=396}\n:::\n:::\n\n\nEn fonction des valeurs de $\\beta$ nous observons des profils différents de plan de phase. Pour mieux le visualiser nous pourrons utiliser l'animation Geogebra mise à disposition à la fin de l'analyse.\n\nD'après le champ de vecteurs nous voyons clairement que l'équilibre en $(0,0)$ est instable et l'équilibre $(x^*,y^*)$ est stable.  \n\nPour calculer l'équilibre nous procédons de la même manière que dans la première partie, c'est à dire en croisant les deux paraboles $\\dot =0 $ et $\\dot y =0$ :\nNous avons $x^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)$.  \nDonc :\n$$\\small\ny^*=\\gamma_y\\left(\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\gamma_x}-\\frac{r_x\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\beta}\\left[1-\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{K_x}\\right]\\right)\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n-\\frac{r_y\\gamma_yy^*}{\\beta} + \\frac{r_y \\gamma_y {y^*}^2}{\\beta K_y} - \\frac{r_x\\gamma_xy^*}{\\beta} + \\frac{r_xr_y\\gamma_x \\gamma_y y^*}{\\beta^2} \\\\\n- \\frac{r_xr_y\\gamma_x\\gamma_y{y^*}^2}{\\beta^2K_y} + \\frac{r_x\\gamma_x^2{y^*}^2}{\\beta K_x\\gamma_y} - \\frac{r_xr_y\\gamma_x^2{y^*}^2}{\\beta^2K_x} \\\\\n+ 2\\frac{r_xr_y\\gamma_x^2{y^*}^3}{\\beta^2K_xK_y} + \\frac{r_xr_y^2\\gamma_x^2 \\gamma_y {y^*}^2}{\\beta^3K_x} - 2\\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^3}{\\beta^3K_xK_y} \\\\\n+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^4}{\\beta^3K_xK_y^2}\n$$\n\nCe qui donne, en mettant les monomes $y^*$ en facteur et en simplifiant ensuite par $\\frac{y^*}{\\beta}$ :  \n$$\n\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta}-\\gamma_yr_y-\\gamma_xr_x +\\\\ y\\left[\\frac{r_y\\gamma_y}{K_y}-\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta K_y}+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y}{\\beta^2K_x}+\\frac{r_x\\gamma_x^2}{\\gamma_yK_x}-\\frac{2r_xr_y\\gamma_x^2}{\\beta K_x}   \\right] +\\\\[.2cm]\n\\frac{2r_yr_x\\gamma_x^2y^2}{\\beta K_xK_y}\\left(1-\\frac{r_y\\gamma_y}{\\beta}\\right) + \\frac{r_xr_y^2\\gamma_x^2\\gamma_yy^3}{\\beta^2K_xK_y^2} = 0\n$${#eq-pol}\n\nCe polynôme est résoluble par `numpy` similairement à la première partie :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\n# Paramètres pour calculer le polynôme\nrx = 0.5\nry = 1\nKx = 2.5\nKy = 2\nb = 1\ngx = 1.5\ngy = 3\n\n#Points d'équilibres, utilisation de numpy : monome, polynome et racines:\n#Calcul:\n#Monome y\nx = np.polynomial.Polynomial([0, 1])\n\n#Polynome :\npol = -gy * ry - gx * rx + (rx * ry * gx * gy)/b + x * ((ry * gy)/(Ky) - (ry * rx * gy * gx)/(b * Ky) + \\\n rx * ry**2 * gx**2 * gy/(b**2 * Kx) + rx * gx**2/(gy * Kx) - 2 * rx * ry * gx**2/(b * Kx)) + \\\n (x**2) * 2 * (ry * rx *gx**2)/(b * Kx * Ky) * (1 - ry * gy/b) + (x**3) * gy * rx * ((ry * gx)**2)/(b**2 * Kx * Ky**2)\n\n#Solution\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() > 0)]\nyeq = sol[0].real\n\n#Calcul de x avec sa définition:\nxeq = gx * (yeq/gy - ry * yeq/b * (1 - yeq/Ky))\n```\n:::\n\n\n### Analyse du plan de phase\n\nNous allons tracer le plan de phase complet et l'analyser d'après la méthode d'@arditi2018 :  \n\nDans cette analyse nous allons considérer, sans perte de généralité, que $r_x < r_y$ (nous prenons l'ellipse dans un seul sens, voir l'animation).\n\nPour cela nous traçons l'ellipse de la même manière que dans la première figure, l'équation de cette ellipse n'ayant pas de terme de migration dans le premier modèle elle est la même dans celui-ci aussi.  \n\nEnsuite nous allons tracer la droite $d$ correspondant à $K_x+K_y=x^*+y^*$ car ceci va permettre de voir si le système subit une [inflation](contexte.qmd) ou une déflation.  \n\nEnfin, similairement à la partie prédédente nous allons tracer les droites données par $\\beta = 0$ et $\\beta \\to +\\infty$ dans la parabole définie par $\\dot x =0$ (parabole verte sur le plan de phase).  \nLes droites sont différentes du modèle précédent donc nous allons les recalculer :\n\nLorsque $\\beta = 0$ nous avons exactement les mêmes deux droites que dans le modèle précédent en $x^* =0$ et en $x^*=K_x$ car le fait que le nouveau modèle ajoute de l'asymétrie dans les migrations est effacé par une migration nulle. Nous les appellerons respectivement $P_{10}$ et $P_{20}$.\n\nLorsque $\\beta \\to +\\infty$ nous avons d'après ([-@eq-pdpamig]) : \n$$\ny^* = \\frac{\\gamma_y}{\\gamma_x}x^*\n$$\n\nNous appellerons cette droite $P_{\\infty}$.  \n\n\nIntroduisons les mêmes points que précédemment c'est à dire : \n\n- $A$, l'intersection entre $P_{20}$  et l'ellipse, c'est à dire la valeur de l'équilibre quand $\\beta = 0$.\n\n- $B$, l'intersection entre $P_{\\infty}$ et l'ellipse, c'est à dire la valeur de l'équilibre quand $\\beta \\to +\\infty$.\n\n- $C$, l'intersection entre $P_{20}$ et $P_{\\infty}$.\n\n- $D$, l'intersection entre la droite $d$ et l'ellipse qui n'est pas le point $A$.\n\nReprésentons le plan de phase avec ces éléments :\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"true\"}\n#Nous créons la figure:\nfig2, ax2 = plt.subplots(1, 1, figsize = (8, 5))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase:\n# Paramètres égaux à ceux utilisés pour calculer les équilibres:\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy * (xt/gx - rx * xt/b * (1 - xt/Kx)), color = 'C2', label = '$\\dot x = 0$')\n\n#ydot = 0\nax2.plot(gx * (yt/gy - ry * yt/b * (1 - yt/Ky)), yt, color = 'C3', label = '$\\dot y = 0$')\n\n#Cadrage:\nax2.set_xlim(left = -0.30, right = 4.5)\nax2.set_ylim(top = 6, bottom = -0.70)\n\nax2.set_xlabel('$x^*$', fontsize = '12')\nax2.set_ylabel('$y^*$', fontsize = '12')\n\n#Axe x et y:\nax2.plot(xt, np.zeros_like(xt), color = 'k', linestyle = 'dashed')\nax2.plot(np.zeros_like(yt), yt, color = 'k', linestyle = 'dashed')\n\n#Droite capacité:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = \"0.8\")\n\n#Plot des équilibres:\nax2.plot(xeq, yeq, marker = '.', markersize = 12)\nax2.plot(0, 0, marker = '.', markersize = 12, color = 'C5')\n\n#Ellipse:\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole β = 0')\nax2.plot(np.zeros_like(xt), xt, color = 'C9')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt, xt * gy/gx, color = 'C6', label = 'Parabole β = $+\\infty$')\n\n#A:\nax2.plot(Kx, Ky, color = 'black', marker = '.')\nax2.text(Kx - 0.1, Ky - 0.1, '$A$')\n\n#C:\nax2.plot(Kx, gy * Kx/gx, color = 'black', marker = '.')\nax2.text(Kx, gy * Kx/gx - 0.1, 'C')\n\n#B:\nax2.plot(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky),((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) \\\n                                        , color = 'black', marker = '.')\n\nax2.text(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) - 0.1, ((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) + 0.1 \\\n                                        , '$B$')\n\n#D:\nax2.plot(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx), rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx), color = 'black', marker = '.')\nax2.text(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx) + 0.1, '$D$')\n\n## Nous plaçons des textes indiquant les trois droites:\nax2.text(0.1, yeq, \"$P_{10}$\")\nax2.text(Kx + 0.05, 4, \"$P_{20}$\")\nax2.text(3, 5.5, \"$P_\\infty$\")\n\n#Légende:\nax2.legend(loc=\"upper left\");\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-8-output-1.png){width=658 height=482}\n:::\n:::\n\n\n#### Première condition de déflation\n\nLa première condition d'inflation est exactement la même que dans le modèle précédent et la preuve est en tout point égale (elle repose sur une analyse de l'équation de l'ellipse qui est la même dans les deux modèles). Nous ne détaillerons pas ici cette preuve mais nous savons donc que :\n\n**Si $r_x = r_y$ alors le système est tout le temps déflationniste.**\n\n#### Deuxième condition de déflation\n\nNous allons faire une preuve graphique de cette condition similaire à l'ancien modèle.  \n\nL'équilibre vit sur l'ellipse et parcourt l'arc orange entre $A$ et $B$ au fur et à mesure que $\\beta$ augmente.   \nAinsi pour avoir déflation nous allons vouloir avoir cet arc entièrement sous la droite $d$ en gris.  \nIl est alors facile de voir que pour cela nous voulons que la coordonnée en $y$ de $C$ soit plus grande que celle de $A$ ($C$ est plus haut sur la droite cyan que $A$), entraînant que la coordonnée en $x$ de $B$ est plus petite que celle de $A$ ($B$ se trouve plus à gauche sur l'ellipse que $A$).  \n\nPour cela nous avons besoin de connaître les coordonnées de $A$ et $C$.  \n\nLe point $A$ est défini comme la valeur de l'équilibre sans migration. Il est alors facile de constater que dans ce cas nous sommes face à un système avec une croissance logistique seulement et donc l'équilibre est atteint pour les capacités de charge.  \nNous avons donc $A = (K_x,K_y)$.\n\nPour $C$ nous savons que c'est l'intersection entre $P_{20}$ et $P_{\\infty}$, ainsi comme $P_{20}$ est défini par $x^* = K_x$ et $P_{\\infty}$ par $y^* =\\frac{\\gamma_y}{\\gamma_x}x^*$ nous avons :\n\n$C = (K_x,\\frac{\\gamma_yK_x}{\\gamma_x})$.\n\nLa condition mathématique qui en découle est donc que le système est déflationniste si $\\frac{\\gamma_yK_x}{\\gamma_x} > K_y$.\n\n**Si $\\frac{\\gamma_y}{\\gamma_x} > \\frac{K_y}{K_x}$ alors le système ([-@eq-modamig]) est toujours déflationniste.**\n\n#### Conditions d'inflation et/ou de déflation\n\nSimilairement à la première partie nous allons avoir des conditions sur l'inflation.  \nEn effet, nous voyons bien sur le plan de phase que si $B$ est entre $A$ et $D$ alors l'arc d'ellipse que parcourt les équilibres en fonction de $\\beta$ est constamment inflationiste.  \n\nAinsi nous voulons que $B$ soit à droite de $A$ ce qui revient à prendre la condition inverse de celle énoncée plus haut (c'est à dire la coordonnées $y$ de $C$ plus petite que celle de $A$), c'est à dire $\\frac{\\gamma_y}{\\gamma_x} < \\frac{K_y}{K_x}$.  \n\nEnsuite pour avoir $B$ entre $A$ et $D$ nous allons vouloir que la pente de $P_{\\infty}$ soit plus haute que celle de la droite passant par $(0,0)$ et $D$ que nous appellerons $\\aleph$.  \nPour voir ceci nous allons ajouter la droite $\\aleph$ au plan de phase précédent :\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\n## Ajout de la droite :\nax2.plot(xt, (rx * Ky)/(ry * Kx) * xt, color = 'C5', label = \"Droite א\")\n\nax2.legend(loc=\"upper left\")\n\ndisplay(fig2)\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-9-output-1.png){width=658 height=482}\n:::\n:::\n\n\nNous avons calculé dans la partie précédente que $D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} )$ ce qui ne change pas dans cette partie car nous considérons des quantités indépendantes des taux de migration.  \n\nLa pente de la droite passant par $D$ et $(0,0)$ est donc égale à $\\frac{r_xK_y}{r_yK_x}$ ce qui donne la condition suivante $\\frac{\\gamma_y}{\\gamma_x} > \\frac{r_xK_y}{r_yK_x}$.\n\n**Si $\\frac{r_xK_y}{r_yK_x} < \\frac{\\gamma_y}{\\gamma_x} < \\frac{K_y}{K_x}$ nous avons un système inflationiste.**\n\nIl est alors aisé de voir que si la pente de $P_{\\infty}$ est plus petite que celle de $\\aleph$ nous avons les équilibres qui parcourent d'abord des valeurs au dessus de $d$ puis en dessous (pour aller de $A$ à $C$). \n\nLa condition mathématique est donc la suivante :\n\n**Si $\\frac{\\gamma_y}{\\gamma_x} < \\frac{r_xK_y}{r_yK_x}$ alors le système est d'abord inflationiste puis déflationniste.**  \n\n### Animation\n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\nimport IPython.display as display\nfig01 = \"\"\"\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \"border: 1px solid black\"></iframe>\n\"\"\"\n\ndisplay.HTML(fig01)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \"border: 1px solid black\"></iframe>\n```\n:::\n:::\n\n\n## Somme des équilibres en fonction de la migration\n\n### Illustration des propositions précédentes\n\nNous allons illustrer les propositions précédentes en traçant la somme des équilibres en fonction de $\\beta$.\nPour cela nous allons simuler avec `odeint` (pendant un temps assez large pour atteindre l'équilibre) pour chaque valeur de $\\beta$. \n\nNous définissons une fonction qui dépend de $\\beta$ : \n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, gy = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n```\n:::\n\n\net nous posons le temps d'intégration, les paramètres et les conditions initiales :\n\n::: {.cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\n\n#4:\nrx4 = 1\nry4 = 2\nKx4 = 2\nKy4 = 1.5\ngx4 = 2\ngy4 = 0.8\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4, gx4, gy4])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 100, 0.01)\n\n#Condition initiale:\ne0 = [1, 1]\n```\n:::\n\n\nEt enfin nous traçons les quatre figures :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code code-fold=\"true\"}\nfig, (ax, ax1, ax2, ax3) = plt.subplots(1, 4, figsize = (9, 4))\nplt.subplots_adjust(wspace = 0.5)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i)) #Nous calculons pour chaque beta l'équilibre\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n\nfor i in np.arange(0, 10, 0.01):\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n    s3 = odeint(aug2, e0, t, args = (param4, i))\n    ax3.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n#Plot de la droite Kx+Ky:    \nxt = np.arange(0, 4, 0.01)\nxt2 = np.arange(0, 10, 0.001)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt2, (Kx2 + Ky2) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.10, Kx2 + Ky2 + 0.006, '$K_x+K_y$')\n\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.12, Kx3 + Ky3 + 0.006, '$K_x+K_y$')\n\nax3.plot(xt2, (Kx4 + Ky4) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax3.text(3.12, Kx4 + Ky4 + 0.006, '$K_x+K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax2.set_xlabel('β')\nax3.set_xlabel('β')\nax.set_ylabel('Population')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5))\n\n#Titres:\nax.set_title('Déflation');\nax1.set_title('Les deux');\nax2.set_title('Inflation');\nax3.set_title('Inflation');\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-13-output-1.png){width=741 height=411}\n:::\n:::\n\n\nNous obtenons 4 profils de courbe. Le premier profil montre une déflation du système et a été obtenu pour la condition décrite plus haut de $\\frac{\\gamma_y}{\\gamma_x} > \\frac{K_y}{K_x}$.  \n\nLe deuxième profil correspond à une inflation du système puis une déflation quand $\\beta$ augmente, cette courbe a bien été obtenue en respectant la condition de $\\frac{\\gamma_y}{\\gamma_x} < \\frac{r_xK_y}{r_yK_x}$.  \n\nLes deux derniers profils, correspondant à une inflation permanente du système, sont obtenus en respectant les conditions décrites plus haut. Nous obtenons deux profils différents, un avec une inflation croissante quand $\\beta$ augmente et l'autre avec une inflation croissante puis décroissante (et qui atteint un plateau).  \nCe phénomène se voit graphiquement sur l'animation ou le plan de phase. En effet, nous avons dans le premier cas \n$P_{\\infty}$ qui coupe l'ellipse dans sa phase montante (l'écart entre l'ellipse et la droite $d$ augmente) alors que dans le second cas $P_{\\infty}$ coupe l'ellipse alors que l'écart entre celle-ci et $d$ diminue.\n\n### Cas de l'augmentorium \n  \nDans le cas de l'augmentorium il est important de considérer l'équilibre $x^*$ seule par rapport à $K_x$ (sa valeur s'il n'y a pas de migration).  \nEn effet même si nous avons inflation dans le système, si $x^*<K_x$ alors nous considérons l'augmentorium comme efficace.\n\nAvec les hyptohèses énoncées plus haut sur la situation de l'augmentorium il n'est pas possible d'obtenir un système inflationiste (indépendamment de si $K_x>K_y$ ou l'inverse). Il est facile de voir ceci grâce à notre animation.\n\nNéanmoins avec des hypothèses plus souples (mais en gardant que $r_x<r_y$), par exemple que les taux de fuites sont plus forts que les taux de migration vers l'augmentorium (dus à une fuite du dispositif par exemple) nous allons voir que l'augmentorium n'est pas forcément bénéfique.  \nEn effet, nous pouvons, sur le plan de phase tracé plus haut, voir que dès que nous sommes dans un cas où nous avons de l'inflation (et même si nous revenons sur de la déflation après) alors nous avons $x^* > K_x$ ce qui est mauvais pour la culture. \n\nNous allons tracer l'équilibre $x^*$ en fonction de $\\beta$ en considérant un cas où le système était déflationniste et un cas où le système était inflationiste (pour la somme des équilibres) :\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"true\"}\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#2:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\nfig, (ax, ax1, ax2) = plt.subplots(1, 3, figsize = (9, 4))\nplt.subplots_adjust(wspace= 0.4)\n\nax.set_title('Equilibre de la culture ($x^*$) avec déflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\nax1.set_title('Equilibre de la culture ($x^*$) avec déflation et inflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\nax2.set_title('Equilibre de la culture ($x^*$)  avec inflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\n\n#Boucle en fonction de beta\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0], marker = '.', color = 'C0')\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0], marker = '.', color = 'C0')\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0], marker = '.', color = 'C0')\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n#Droite Kx:\nxt = np.arange(0, 4, 0.01)\nax.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 - 0.15, '$K_x$')\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 + Ky1 - 0.15, '$K_x + K_y$')\n\nax1.plot(xt, Kx2 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 - 0.15, '$K_x$')\nax1.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 + Ky2 - 0.15, '$K_x + K_y$')\n\nax2.plot(xt, Kx3 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.5, Kx3 - 0.15, '$K_x$')\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.5, Kx3 + Ky3 - 0.15, '$K_x + K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\nax2.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\n\nax.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\nax1.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\nax2.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\n\n# Nous limitons le cadre :\nax1.set_ylim(bottom=1)\nax2.set_ylim(bottom=1)\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (1, -0.65, 0.5, 0.5))\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n<matplotlib.legend.Legend at 0x7f8eb8cff040>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-14-output-2.png){width=805 height=434}\n:::\n:::\n\n\nEn bleu nous observons le comportement de l'équilibre dans la culture seulement et en gris nous retrouvons les courbes tracées juste au dessus. Nous voyons bien que dès que le système subit une inflation des équilibres totaux la situation devient mauvaise pour la culture.  \nEn revanche quand nous avons déflation des équilibres totaux alors la situtaion est bénéfique à la culture.  \n\nIl faut garder en tête que ceci n'est vrai que pour $r_x<r_y$.  \n\nEnsuite, le taux de fuite est un paramètre clé de notre méthode. Nous allons donc tracer la somme des équilibres et l'équilibre $x^*$ en fonction de $\\gamma_y$.\n\nAttention ! Un fort taux de fuite correspond à un $\\gamma_y$ faible.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code code-fold=\"true\"}\n#Définition d'un nouveau modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1  \nKx1 = 1\nKy1 = 2\ngx1 = 0.5\nb = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx1 - 0.1, '$K_x$')\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.01):\n    s = odeint(aug3, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax1.plot(i, s[-1][0], marker = '.', color = 'C0')\n\n#Légendes:\nax1.set_xlabel('Ɣy, Fuite')\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, Kx1 + Ky1, color = 'C0', label = 'Somme des équilibres')\nax1.plot(0, Kx1, color = 'C0', label = 'Eq. culture')\n\nax.set_title('Somme des équilibres en fonction du taux de fuite', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de fuite', fontsize = 7)   \nax.legend();\nax1.legend();\nax.set_ylabel(\"Densité de pop.\");\n```\n\n::: {.cell-output .cell-output-display}\n![](modeleavecmigrationass_files/figure-html/cell-15-output-1.png){width=747 height=372}\n:::\n:::\n\n\nDans la figure gauche nous avons représenté la somme des équilibres ($x^*+y^*$) de la même manière que précédemment mais cette fois en faisant varier le taux de fuite.  \nNous observons alors un nouveau profil qui correspond à une déflation, puis une inflation puis enfin une déflation au fur et à mesure que $\\gamma_y$ augmente.\n\nDans la figure droite nous avons cette fois uniquement l'équilibre dans la culture ($x^*$). Nous observons que pour des $\\gamma_y$ petits nous avons inflation puis nous retournons à une déflation.  \n\nPour représenter cette figure nous avons considéré que $r_x<r_y$ et $K_x<K_y$ sans perte de généralité.\n\nPour interpréter ceci il faut comprendre que les des petites valeurs de $\\gamma_y$ correspondent à de grandes valeurs de taux de fuite.  \nAinsi quand $\\gamma_y \\to 0$ l'augmentorium se vide en ravageurs et nous avons ainsi toute la population dans la culture et l'équilibre dans culture tend vers sa capacité de charge car nous sommes seulement face à une croissance logistique.  \nC'est pourquoi, lorsque les taux de fuite sont grands nous observons une inflation de la culture car nous avons, des populations de ravageurs qui viennent de l'augmentorium qui s'ajoutent aux ravageurs déjà présents dans la culture.  \nLa somme des équilibres est donc trompeuse dans ce cas là, en effet le système subit une déflation car l'augmentorium n'est presque plus occupé pour de forts taux de fuite mais il ne faut pas croire que c'en est bénéfique pour la culture.\n\n\nCe modèle considère uniquement la population de ravageurs. Or, la méthode de l'augmentorium repose énormément sur l'action des prédateurs nous allons donc considérer [maintenant](modelaug.qmd) un modèle qui prend en compte ces prédateurs.\n\n",
    "supporting": [
      "modeleavecmigrationass_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}