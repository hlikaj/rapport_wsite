{
  "hash": "6b824bbde16965a54c1aac376e98744b",
  "result": {
    "markdown": "---\ntitle: Modèle logistique structuré sans migration asymétrique\n---\n\n---\n\n*Modules à importer :*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\n## Définition du modèle\n\nNous posons le modèle suivant d'après @arditi2015 :\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta(y-x)\\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta(x-y).\n\\end{array}\\right.\n$$ {#eq-modsmig}\n\navec :   \n- $x$ la population dans la première structure,  \n- $y$ la population dans la seconde structure,  \n- $r_x$ et $r_y$ le taux de croissance dans les deux structures,  \n- $K_x$ et $K_y$ les capacités de charge des deux structures,  \n- $\\beta$ la force de migration entre les structures.  \n\nCe modèle ressemble peu à notre situation d'augmentorium car celui-ci est caractérisé par une migration asymétrique, il permet néanmoins de situer la démarche et les outils que nous allons utiliser pour étudier des modèles plus complexes.  \n\n## Dynamique du modèle\n\nNous allons tracer la dynamique de la population en fonction du temps pour se faire une première idée de comment se comporte la population.\n\nNous définissons le modèle sous [`Python`](https://www.python.org/) :\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b = param\n    x, y = etat\n    s = [ rx * x * ( 1 - x/Kx ) + b * ( y - x ), \n    ry * y * ( 1 - y/Ky ) + b * ( x - y )]\n    return s \n```\n:::\n\n\nNous allons utiliser `odeint` de [`Scipy`](https://scipy.org/) afin de simuler une solution en fonction du temps. \nIl faut donc définir un temps d'intégration, des conditions initiales et les paramètres du modèle : \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n## Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n## Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0 ,y0]\n\n## Paramètres: \nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\n\nparam_aug = np.array([rx, ry, Kx, Ky, b])\n\n## Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n```\n:::\n\n\nMaintenant que nous avons la simulation nous pouvons réprésenter la figure avec [`matplotlib`](https://matplotlib.org/) :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfig, ax = plt.subplots(1, 1, figsize = (7, 4 ))\n\nfig.suptitle('Dynamique des ravageurs dans le temps')\nax.plot(ti, s[:, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[:, 1], color = 'C0', label = 'augmentorium')\n\nax.grid() #Nous ajoutons la grille\nax.legend() #Nous ajoutons la légende\n\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n```\n\n::: {.cell-output .cell-output-display}\n![Dynamique du modèle](modelesansmigrationass_files/figure-html/fig-dyn-output-1.png){#fig-dyn width=598 height=394}\n:::\n:::\n\n\nCette simulation nous montre une hausse de la population dans l'augmentorium et une baisse de la population dans la culture.  \nLes deux populations atteignent un équilibre qui semble stable (il se maintient dans le temps).  \n\nDans le cas d'un augmentorium, nous voyons que le simple fait de débarasser les fruits et de les mettre dans un espace séparé de la culture ammène à une baisse de la population de ravageurs dans la culture.\n\n## Plan de phase\n\n### Equilibres et stabilités\n\nNous allons tracer le plan de phase associé à ce système pour voir les équilibres et leurs stabilités.\n\nA l'équilibre nous avons par définition $\\dot x = 0$ et $\\dot y =0$ ce qui donne : \n\n$$\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta(y^*-x^*) \\Leftrightarrow  y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right)\\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta(x^*-y^*) \\Leftrightarrow  x^*=r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\n\\end{array}\\right.\n$${#eq-pdpsmig}\n\navec $x^*$ et $y^*$ la valeur des équilibres.\n\nAinsi, les deux isoclines correspondent à des paraboles. Celles-ci se croisent trivialement en $(0,0)$ et dans le quadrant positif en $(x^*,y^*)$. \n\nPour calculer $(x^*,y^*)$ nous allons utiliser l'expression de $x^*$ trouvée en ([-@eq-pdpsmig]) que nous allons rentrer dans l'équation de $y^*$ :  \n\nComme $x^* = r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)$ nous avons:  \n$$\ny^* = r_x\\left[r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\\right]\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)}{\\beta K_x}\\right)\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^* = y^* - \\frac{r_yy^*}{\\beta} + \\frac{r_y{y^*}^2}{\\beta K_y} - \\frac{r_xy^*}{\\beta} + \\frac{r_xr_yy^*}{\\beta^2} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_y} + \\\\[.2cm]\n\\frac{r_x{y^*}^2}{\\beta K_x} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\\\[.2cm] \n \\frac{r_xr_y^2{y^*}^2}{\\beta^3 K_x} - \\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_x K_y} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\\\[.2cm]\n \\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_xK_y} + \\frac{r_xr_y^2{y^*}^4}{\\beta^3K_xK_y^2} \n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^*\\left(- \\frac{r_y}{\\beta} - \\frac{r_x}{\\beta} + \\frac{r_xr_y}{\\beta^2}\\right) + \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y} - \\frac{r_xr_y}{\\beta^2 K_y} + \\frac{r_x}{\\beta K_x} - 2\\frac{r_xr_y}{\\beta^2 K_x} + \\frac{r_xr_y^2}{\\beta^3 K_x} \\right) + \\\\[.2cm]\n2{y^*}^3\\left( \\frac{r_xr_y}{\\beta^2 K_xK_y} - \\frac{r_xr_y^2}{\\beta^3 K_xK_y} \\right) + \n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_xK_y^2} = 0\n$$\n\nCe qui donne après réarrangement : \n$$ \ny^*\\left(\\frac{1}{\\beta}\\left[\\frac{r_xr_y}{\\beta} - r_y -r_x\\right]\\right)+ \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y}\\left[1-\\frac{r_x}{\\beta}\\right]+\\frac{r_x}{\\beta K_x}\\left[1-2\\frac{r_y}{\\beta}+\\frac{r_y^2}{\\beta^2}\\right]\\right)+\\\\[.2cm]\n2{y^*}^3\\left(\\frac{r_xr_y}{\\beta^2 K_xK_y}\\left[1-\\frac{r_y}{\\beta}\\right]\\right) + \n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_y^2K_x} = 0\n$${#eq-polsmig}\n\nCe polynôme est résoluble via [`numpy`](https://numpy.org/) pour obtenir $y^*$:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n## Nous définissons un monome y, un polynôme p et nous prenons ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol = y * ((1/b) * (-rx - ry + rx*ry/b)) + \\\n(y**2) * (ry/(Ky * b) * (1 - (rx/b)) + rx/(b * Kx) * (1 - (2*ry/b) + ry**2 /(b**2))) + \\\n2 * (y**3) * ((rx * ry)/((b**2) * Kx * Ky)) * (1 - (ry/b)) + \\\n(y**4) * ((rx * (ry**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution que nous obtenons avec un masque booléen qui sélectionne les racines réelles et strictement positives:\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() > 0)]\nyeq=sol[0].real\n```\n:::\n\n\nNous déduisions $x^*$ via sa définition par le système ([-@eq-pdpsmig]) :\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nxeq = (ry * yeq * ((1/ry) - (1/b) + (yeq/(b * Ky)))).real\n```\n:::\n\n\nAvec la valeur des équilibres nous allons maintenant tracer le plan de phase : \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfig, ax = plt.subplots(1, 1)\nfig.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax.plot(xt,xt * (1/b) * (rx * ((xt/Kx) - 1) + b), \n                    color = 'C2', label = '$\\dot x=0$')\nax.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax.plot(xt * (1/b) * (ry * ((xt/Ky) - 1) + b), xt,\n                    color = 'C3', label = '$\\dot y=0$')\nax.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## Nous réduisons la vue à ce qui nous intéresse:\nax.set_xlim(left = -.3, right = 3)\nax.set_ylim(top = 3, bottom = -.3)\n\n## Nous traçons la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## Nous nommons les axes:\nax.set_xlabel('$x$', fontsize = '12') ;\nax.set_ylabel('$y$', fontsize = '12') ;\n\n## Nous représentons les deux équilibres:\nax.plot(xeq.real, yeq.real, label = '$(x^*,y^*)$', marker = '.', markersize = 6, color = 'k')\nax.plot(0, 0, label = '$(0,0)$',\n                    marker = '.', markersize = 6, color = 'k')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax.quiver(X, Y, dx, dy, angles = 'xy', \n                    color = 'grey', scale = 80, width = 0.003);\n```\n\n::: {.cell-output .cell-output-display}\n![Plan de phase du modèle](modelesansmigrationass_files/figure-html/fig-pdp0-output-1.png){#fig-pdp0 width=602 height=480}\n:::\n:::\n\n\nComme dit plus haut nous avons bien un croisement dans le quadrant positif qui correspond à l'équilibre $(x^*,y^*)$. \n\nLes paraboles, en fonction des valeurs de leurs racines, peuvent croiser de différentes manières les axes des abscisses et des ordonnées.  \nLe plan de phase peut donc présenter plusieurs profils, autres que celui tracé ici. Néanmoins, le croisement des paraboles dans le quadrant positif (l'équilibre non nul) est toujours présent quelque soit le profil.\n\nEn faisant apparaître le champ de vecteur nous pouvons déduire que l'équilibre en $(0,0)$ est instable et l'équilibre en $(x^*,y^*)$ est stable.\n\n#### Stabilité mathématique des équilibres\n\nIl est clair que $(0,0)$ est instable et $(x^*,y^*)$ est stable (par le champ de vecteur).  \nMathématiquement considérons la jacobienne de ([-@eq-modsmig]): \n$$ \n\\mathbb{J}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy}{K_y}-\\beta\n\\end{pmatrix}\n$${#eq-jacob}\n\net donc **pour $(0,0)$**:  \n\n$$\n\\mathbb{J_{\\vec{0}}}=\\begin{pmatrix}\n\\ r_x-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\beta\n\\end{pmatrix}\n$$\n\nLes valeurs propres $\\lambda _1$ et $\\lambda _2$ de cette matrice sont les solutions du polynôme caractéristique définit par : \n$$\n\\begin{vmatrix}\nr_x-\\beta-\\lambda & \\beta \\\\\n\\beta & r_y -\\beta -\\lambda \\\n\\end{vmatrix} = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n(r_x-\\beta-\\lambda)(r_y-\\beta - \\lambda) - \\beta^2 = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n\\lambda^2 + \\lambda\\left(2\\beta - r_x - r_y\\right) + r_xr_y - \\beta(r_x+r_y) = 0\n$$\n\nLe discriminant $\\Delta$ est donc définit par :  \n$$\n\\Delta = \\left(2\\beta - r_x - r_y\\right)^2 - 4(r_xr_y - \\beta[r_x+r_y]) \\\\\n= 4\\beta^2 -4\\beta(r_x +r_y) + r_x^2 +r_y^2 +2r_xr_y -4r_xr_y +4\\beta(r_x +r_y) \\\\ = 4\\beta^2 + (r_x-r_y)^2\n$$\n\nEt donc le spectre $\\sigma$ de la jacobienne est :  \n$$\n\\sigma_\\mathbb{J} = \\left(\\lambda_1 = \\frac{r_x+r_y-2\\beta-2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2},\\lambda_2=\\frac{r_x+r_y-2\\beta+2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2}\\right)\n$$\n\net nous avons ainsi,\n\n$$\n\\lambda_2 > 0\n$$\n\nDonc $(0,0)$ est bien instable.  \n\n**Pour $(x^*,y^*)$** nous avons:\n$$ \n\\mathbb{J_{x^*,y^*}}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx^*}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy^*}{K_y}-\\beta\n\\end{pmatrix}\n$${#eq-jacob}\n\nor, nous avons aussi d'après ([-@eq-pdpsmig]): \n\n$$\n\\left\\{\\begin{array}{l}\n\\frac{y^*\\beta}{x^*} = \\beta - r_x + \\frac{r_xx^*}{K_x}   \\\\\n\\frac{x^*\\beta}{y^*} = \\beta - r_y + \\frac{r_yy^*}{K_y}  \n\\end{array}\\right.\n$$\n\nce qui simplifie la jacobienne en $(x^*,y^*)$ à l'expression suivante :\n\n$$ \\mathbb{J_{x^*,y^*}} = \\begin{pmatrix}\n\\ -\\frac{\\beta y^*}{x^*}-\\frac{r_xx^*}{K_x} & \\beta \\\\\n\\ \\beta & -\\frac{\\beta x^*}{y^*}-\\frac{r_yy^*}{K_y}\n\\end{pmatrix}\n$$\n\nIl est alors facile de vérifier que la trace de cette matrice est négative.  \n\nLe déterminant quant à lui est donné par: \n$$\n\\alpha = \\left(\\frac{\\beta y^*}{x^*}+\\frac{r_xx^*}{K_x}\\right)\\left(\\frac{\\beta x^*}{y^*}+\\frac{r_yy^*}{K_y}\\right) - \\beta^2 \\\\\n= \\frac{\\beta r_y{y^*}^2}{x^*K_y} + \\frac{\\beta r_x {x^*}^2}{y^*K_x} + \\frac{r_xr_yx^*y^*}{K_xK_y} > 0\n$$\n\nLe déterminant est lui positif et $(x^*,y^*)$ est donc stable.\n\n\n### Analyse du plan de phase\n\nNous remarquons sur la @fig-pdp0 que l'équilibre atteint n'est pas sur la droite $x^*+y^*=K_x+K_y$ (en gris), nous appellerons cette droite $d$.  \nSi le croisement des isoclines est au dessus de cette droite le système ([-@eq-modsmig]) subit une inflation et si le croisement est en dessous de cette droite il subit une déflation (voir [contexte](contexte.qmd)).  \n\nNous voyons que la structuration de l'espace, et les migrations qui s'en suivent, perturbent les équilibres qui auraient dû, sans migration, être la somme de l'équilibre dans chaque strucuture qui est $K_x+K_y$ (car les populations ont une croissance logistique).   \n\n\nPlus généralement, nous pouvons montrer qu'en cas de mixité parfaite entre les deux structures ($\\beta \\to \\infty$) nous avons d'après @arditi2015:\n\n$$\nx^*+y^* = K_x + K_y + (K_x-K_y)\\frac{r_xK_y-r_yK_x}{r_xK_y+r_yK_x}\n$${#eq-inf}\n\nCe qui montre qu'en général nous n'avons pas $x^*+y^* = K_x + K_x$.  \nDe plus par ([-@eq-inf]), si $K_y<K_x$ et si $r_xK_y<r_yK_x$ alors $x^*+y^* < K_x+K_y$ ce qui nous intéresse particulièrement pour la lutte biologique.  \n\nEnsuite, en faisant $\\dot x + \\dot y = 0$, dans le cas de l'équilibre, nous avons:\n$$ \nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+r_yy^*\\left(1-\\frac{y^*}{K_y}\\right) = 0 \n$${#eq-ell}\n\nAutrement dit les points d'équilibres vivent sur une ellipse (si nous ne modifions que $\\beta$ ), que nous allons tracer avec `contour` :\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\n\nax.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left', fontsize = 8)\n\n## Nous plaçons les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et nous les relions aux axes:\nxc = np.arange(0, Kx, 0.01)\nax.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#Nous nommons les points:\nax.text(-0.2, Ky, '$K_y$')\nax.text(Kx, -0.2, '$K_x$')\n\n#Nous plaçons les points d'équilibres :\nys = np.arange(0, yeq, 0.01)\nxs = np.arange(0, xeq, 0.01)\n\nax.plot(xeq * np.ones_like(ys), ys, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\nax.plot(xs, yeq * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax.text(-0.2, yeq, '$y^*$')\nax.text(xeq, -0.2, '$x^*$')\n\ndisplay(fig)\n```\n\n::: {.cell-output .cell-output-display}\n![Plan de phase avec ellipse](modelesansmigrationass_files/figure-html/fig-pdp2-output-1.png){#fig-pdp2 width=602 height=480}\n:::\n:::\n\n\nLes conditions d'inflations et de déflations suivantes proviennent de l'article d'@arditi2018.\n\n#### Première condition à un système déflationniste \nNous remarquons que le point $(K_x,K_y)$ est en permanence sur la droite $d$ qui coupe en permanence l'ellipse (en deux points) sauf pour une situation où $d$ est tangente à l'ellipse.  \n\nCe cas nous intéresse car il rend compte d'un système entièrement déflationniste en effet, l'équilibre étant necessairement sur l'ellipse, si celle-ci est tangente à la droite $d$, l'ensemble de l'ellipse est située dans la zone où $x^*+y^*<K_x+K_y$.  \n\nReprésentons le sur le plan de phase :\n\n\nNous redéfinissons les paramètres pour être dans le cas qui nous intéresse :\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n## Paramètres: \nrxnew = 0.5\nrynew = 0.5\nKx = 2\nKy = 1\nb = 1\n```\n:::\n\n\nEt nous traçons de la même manière que précédemment le plan de phase :\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nfig2, ax2 = plt.subplots(1, 1)\nfig2.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax2.plot(xt,xt * (1/b) * (rxnew * ((xt/Kx) - 1) + b), color = 'C2', \n                label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax2.plot(xt * (1/b) * (rynew * ((xt/Ky) - 1) + b), xt, color = 'C3', \n                label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## Nous réduisons la vue à ce qui nous intéresse:\nax2.set_xlim(left = -.3, right = 3)\nax2.set_ylim(top = 3, bottom = -.3)\n\n## Nous traçons la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## Nous nommons les axes:\nax2.set_xlabel('$x$', fontsize = '12') ;\nax2.set_ylabel('$y$', fontsize = '12') ;\n\n## Nous recalculons les équilibres avec les nouveaux paramètres:\n## Nous définissons un monome y, un polynôme p et nous prenons ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol2 =  y * ((1/b) * (-rxnew - rynew + rxnew * rynew/b)) + \\\n(y**2) * (rynew/(Ky * b) * (1 - (rxnew/b)) + rxnew/(b * Kx) * (1 - (2*rynew/b) + rynew**2 /(b**2))) + \\\n2 * (y**3) * ((rxnew * rynew)/((b**2) * Kx * Ky)) * (1 - (rynew/b)) + \\\n(y**4) * ((rxnew * (rynew**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution que nous obtenons avec un masque booléen qui sélectionne les \n## racines réelles et strictement positives:\nsol2 = pol2.roots()[ (np.isreal( pol2.roots() )) * (pol2.roots() > 0)]\nyeq2=sol2[0].real\n\n## Nous calculons calcule x*\nxeq2 = (rynew * yeq2 * ((1/rynew) - (1/b) + (yeq2/(b * Ky)))).real\n\n## Nous représentons les deux équilibres:\nax2.plot(xeq2.real, yeq2.real, label = '$(x^*,y^*)$', marker = '.', \n                markersize = 6, color = 'k')\nax2.plot(0, 0, label = '$(0,0)$', marker = '.', markersize = 6, \n                color = 'k')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', \n                scale = 80, width = 0.003) ;\n\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rxnew * X2 * (1 - X2/Kx)\nY = rynew * Y2 * (1 - Y2/Ky)\n\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left', fontsize = 8)\n\n## Nous plaçons les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax2.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et nous les relions aux axes:\nxc = np.arange(0, Kx, 0.01)\nax2.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax2.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#Nous nommons les points:\nax2.text(-0.2, Ky, '$K_y$')\nax2.text(Kx, -0.2, '$K_x$')\n\n#Nous plaçons les points d'équilibres :\nys = np.arange(0, yeq2, 0.01)\nxs = np.arange(0, xeq2, 0.01)\n\nax2.plot(xeq2 * np.ones_like(ys), ys, linestyle = 'dashed',\n                color = 'k', linewidth = 0.5)\nax2.plot(xs, yeq2 * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax2.text(-0.2, yeq2, '$y^*$');\nax2.text(xeq2, -0.2, '$x^*$');\n```\n\n::: {.cell-output .cell-output-display}\n![Plan de phase déflationiste](modelesansmigrationass_files/figure-html/fig-pdp3-output-1.png){#fig-pdp3 width=602 height=480}\n:::\n:::\n\n\nL'ellipse, d'équation $f(x,y)=r_xx\\left(1-\\frac{x}{K_x}\\right)+r_yy\\left(1-\\frac{y}{K_y}\\right) = 0$  ,peut être vue comme la ligne de niveau de $f$ en $0$. \n\nAinsi, une équation de la tangente au point $(x_0,y_0)$ est donnée par:   \n$$\n\\frac{\\partial f}{\\partial x}(x_0,y_0)(x-x_0)+ \\frac{\\partial f}{\\partial y}(x_0,y_0)(y-y_0) = 0\n$${#eq-eqa}\n\nautrement dit:\n$$\n\\left(r_x - 2\\frac{r_xx_0}{K_x}\\right)(x-x_0) + \\left(r_y -2\\frac{r_yy_0}{K_y}\\right)(y-y_0) = 0\n$$\n\nDans le cas où $x_0=K_x$ et $y_0=K_y$ nous avons alors:\n$$\n-r_x(x-K_x) -r_y(y-K_y) = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny = -\\frac{r_x}{r_y}\\left(x-K_x\\right) + K_y\n$${#eq-tang}\n\nqui est donc l'équation de la tangente à l'ellipse au point $(K_x,K_y)$.\n\nSi maintenant nous prenons $r_x=r_y$ alors nous remarquons que ([-@eq-tang]) est égale à l'équation de la droite $d$ ce qui implique que toute l'ellipse est en dessous de $d$ et donc que tous les équilibres sont déflationnistes.\n\n**Donc : si $r_x=r_y$ nous avons ([-@eq-modsmig]) qui est déflationniste quelque soit le taux de migration.**\n\nNous allons effectuer une simulation avec les paramètres déduits à l'instant pour illustrer ce que nous venons de dire.  \nPour cela nous allons, pour chaque $\\beta$, simuler un temps suffisament large pour atteindre l'équilibre et représenter la somme des deux équilibres.\n\n:::{.callout-note}\nNous aurions pu utiliser les racines du polynôme calculé plus haut afin de simuler la somme des équilibres.\n:::\n\nIl faut donc définir une fonction qui prend en compte le changement de $\\beta$ :\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n```\n:::\n\n\nAinsi qu'un temps d'intégration large, des conditions initiales et des paramètres :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n## Temps d'intégration :\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \nrx1 = 0.5\nry1 = 0.5 # Nous prenons rx1=rx2\nKx1 = 2\nKy1 = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Condition initiale:\nc10 = [2, 0]\n```\n:::\n\n\nEt enfin nous simulons avec `odeint` et nous faisons une boucle pour simuler que $\\beta$ va de $0$ à $4$ (suffisant pour avoir une courbe intéressante):\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n## Nous créons la figure et l'axe:\nfig3, ax3 = plt.subplots(1, 1)\nfig3.suptitle(\"Somme des équilibres en fonction de β quand $r_x = r_y$\")\n\n## Boucle ou i prend les valeurs de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param1, i)) #Nous calculons pour chaque beta l'équilibre\n    ax3.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\nxt = np.arange(0, 4, 0.01)\n\nax3.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax3.text(3.2, Kx + Ky + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax3.set_xlabel('β')\nax3.set_ylabel('Population')\nax3.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\n\n## Nous adaptons la fenêtre:\nax3.set_ylim(2.2, 3.2)\n\nax3.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![Somme des équilibres déflationiste](modelesansmigrationass_files/figure-html/fig-sommeeg-output-1.png){#fig-sommeeg width=589 height=477}\n:::\n:::\n\n\nNous voyons que la courbe bleue représentant la somme des équilibres est en permanence en dessous de la droite $K_x+K_y$. Nous avons bien un système entièrement déflationniste quand $r_x = r_y$.  \n\n\n#### Deuxième condition à un système déflationniste\n\nNous allons maintenant considérer le cas où $r_x < r_y$ c'est à dire nous allons prendre l'ellipse dans le sens horizontal (voir sur l'animation Geogebra pour plus de clarté).\n\nNous allons analyser graphiquement le plan de phase.  Nous aurons besoin de tracer les droites définies par $\\beta = 0$ et $\\beta \\to +\\infty$ dans l'équation $y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right)$  (la parabole verte dans le plan de phase définie par $\\dot x =0$).\n\nEn effet, ceci va permettre d'encadrer l'équilibre $(x^*,y^*)$ en fonction du taux de migration.\n:::{.callout-note}\nL'équilibre est encadré car nous voyons que graphiquement, en déterminant l'équilibre sur l'ellipse pour $\\beta = 0$ et pour $\\beta \\to +\\infty$, alors si $\\beta$ augmente nous restons entre ces deux points (voir animation).\n:::\n\nLorsque $\\beta = 0$ nous avons, par la première équation de ([-@eq-pdpsmig]) :\n$$\n0 = r_xx^*(1-\\frac{x^*}{K_x})\n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^*=K_x \\vee x^* = 0\n$$\n\nDonc lorsque le taux de migration est nul la \"parabole\" \"correspondant à $\\dot x = 0$ a pour équation les droites $x^*=0$ et $x^*=K_x$ que nous appellerons respectivement $P_{10}$ et $P_{20}$. \n\n\nLorsque $\\beta \\to + \\infty$ nous avons, encore une fois par la première équation de ([-@eq-pdpsmig]):\n\n$$\ny^* = r_xx^*\\frac{1}{r_x} = x^*\n$$ \n\nAinsi quand le taux de migration tend vers l'infini la \"parabole\" $\\dot x = 0$ correspond à la droite $y^*=x^*$ que nous apellons $P_\\infty$.\n\nNous noterons dans la suite $A=(K_x,K_y)$, $B$ l'intersection non trivial (pas $(0,0)$) entre $P_\\infty$ et l'ellipse et $C$ l'intersection non triviale (pas $(K_x,0)$) entre $P_{20}$ et $P_\\infty$. \n\nPour calculer les coordonnées de $B$ nous utilisons que $y^*=x^*$ et nous le rentrons dans ([-@eq-ell]) ce qui donne :\n$$\nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right)+r_y\\left(1-\\frac{x^*}{K_y}\\right)\\right) = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^* = \\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}}\n$$ \n\n$$\nB = (\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}},\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}})\n$$\n\nPour calculer les coordonnées de $C$ nous utilisons que $y^*=x^*$ dans la définition de $P_{20}$, ie comme $P_{20}$ est défini par $x^* =K_x$ alors $y^*=K_x$ et donc nous avons:\n$$\nC=(K_x,K_x)\n$$\n\nReprésentons le tout sur le premier plan de phase:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n## Parabole xdot=0 b=0:\nax.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole $b=0$')\nax.plot(np.zeros_like(xt), xt, color = 'C9')\n\n## Parabole xdot=0 b=+inf:\nax.plot(xt, xt, color = 'C6', label = 'Parabole b=$+\\infty$')\n\n## Nous plaçons des textes indiquant les trois droites:\nax.text(0.05, yeq + 0.4, \"$P_{10}$\")\nax.text(Kx + 0.05, 2.8, \"$P_{20}$\")\nax.text(2.65, 2.45, \"$P_\\infty$\")\n\n## Nous plaçons les trois points:\n## A :\nax.plot(Kx, Ky, marker = '.',color = 'C0', markersize = 7)\nax.text(Kx + 0.1, Ky + 0.1, \"$A$\")\n\n## B :\nax.plot((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky), \n            marker = '.', color = 'C0', markersize = 7)\n\nax.text((rx + ry)/(rx/Kx + ry/Ky) - 0.1, (rx + ry)/(rx/Kx + ry/Ky) + 0.1, \"$B$\")\n\n## C : \nax.plot(Kx, Kx, marker = '.', color = 'C0', markersize = 7)\nax.text(Kx - 0.1, Kx + 0.1, \"$C$\")\n\nax.legend(loc = \"upper left\", fontsize = 6.5)\n\ndisplay(fig)\n```\n\n::: {.cell-output .cell-output-display}\n![Plan de phase complet](modelesansmigrationass_files/figure-html/fig-pdp-output-1.png){#fig-pdp width=602 height=480}\n:::\n:::\n\n\nLorsque $\\beta$ augmente de $0$ à $+\\infty$ nous avons l'équilibre qui parcourt l'ellipse de $A$ à $B$.  \nPour que le système soit déflationniste nous voulons que la portion de l'ellipse de $A$ à $B$ soit complètement en dessous de la droite $d$ (grise).  \nPour ce faire nous pouvons voir sur notre plan de phase qu'il faut que $C$ ait une coordonnée $y$ plus grande que $A$ afin que $B$ soit toujours à gauche de $A$ (et donc en dessous de $d$). \n\nMathématiquement nous voulons donc que $K_x > K_y$. \n\nAinsi si nous avons $r_x < r_y$ et $K_x>K_y$ nous aurons tout le temps un modèle déflationniste pour les ravageurs.\n\nCeci est intéressant pour l'augmentorium, si nous avons la capacité de charge l'augmentorium qui est plus faible que celle de la culture alors le système est toujours répréssif pour la population totale de ravageurs. \n\nNous pouvons aussi voir graphiquement que dans ce cas là nous avons toujours $x^* < K_x$, c'est ce que nous cherchons à obtenir. \n\nNous pouvons illustrer notre condition avec une simulation similaire à la partie précédente : \n\nNous utilisons le même modèle, nous changeons uniquement les paramètres :\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n## Paramètres : \nrx2 = 0.5\nry2 = 1  #Nous avons bien rx2 < ry2 \nKx2 = 2\nKy2 = 1  #Nous avons bien Kx2>Ky2\n\n## En l'occurence il s'agit des paramètres de base que nous ##avions utilisé pour la simulation du premier plan de phase ##expliquant que nous nous retrouvions avec un équilibre ##déflationniste.\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n```\n:::\n\n\nEt nous simulons à nouveau :\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"true\"}\n## Nous créons la figure et l'axe:\n\nfig4, ax4 = plt.subplots(1, 1)\nfig4.suptitle(\"Somme des équilibres en fonction de β quand $r_x < r_y$ et $K_x > K_y$\")\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param2, i)) #Nous calculons pour chaque beta l'équilibre\n    ax4.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax4.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax4.text(3.2, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax4.set_xlabel('β')\nax4.set_ylabel('Population')\nax4.plot(Kx2+Ky2, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\n\n## Nous adaptons la fenêtre:\nax4.set_ylim(2.2, 3.2)\n\nax4.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![Somme des équilibres déflationiste](modelesansmigrationass_files/figure-html/fig-sommeeq2-output-1.png){#fig-sommeeq2 width=589 height=477}\n:::\n:::\n\n\nNous observons que nous avons bien une déflation du système quelque soit le taux de migration.\n\n#### Conditions pour une inflation et/ou une déflation\n\nSur la base de la @fig-pdp nous pouvons aussi déduire quand est-ce que nous pouvons avoir inflation selon les paramètres.  \n\nIl s'agit de la même idée de preuve graphique qu'avant mais en complexifiant un peu.  Pour cela nous allons avoir besoin d'un quatrième point que nous appellerons $D$ et qui correspond à l'autre intersection entre l'ellipse et la droite $d$ (pas $(K_x,K_y)$).\n\nPour trouver les coordonnées de $D$ nous avons simplement que comme $D$ est sur $d$ alors nous avons $y^* = -x^* + K_x + K_y$ et nous remplaçons $y^*$ dans ([-@eq-ell]) ce qui donne : \n$$\nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right) +r_y(-x^*+K_x+K_y)\\left(1-\\frac{-x^*+K_x+K_y}{K_y} \\right) = 0 \n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{r_yK_x}{K_y}\\left(1-\\frac{x^*}{K_x} \\right) \\right) + \\frac{r_y(K_x+K_y)}{K_y}(x^*-K_x) = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n\\left(1-\\frac{x^*}{K_x}\\right)\\left(x^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right]-\\frac{r_yK_x(K_x+K_y)}{K_y}\\right) = 0\n$$\n\nCe qui donne soit $x^* = K_x$ et nous retrouvons alors $A$, soit :  \n$$\nx^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right] = \\frac{r_yK_x(K_x+K_y)}{K_y}\n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^* = \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n$$\n\nEt donc d'après la définition de $y^*$ :\n$$\ny^* = - \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} + K_x + K_y\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^* = \\frac{(K_x+K_y)(r_xK_y+r_yK_x)-r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^*=\\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x}\n$$\n\n\nAinsi, $D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} )$ .\n\nAjoutons $D$ à un nouveau plan de phase :\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n## Temps d'intégration :\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \nrx = 0.5\nry = 1.5\nKx = 1\nKy = 2\nb = 1\n\nparam1 = np.array([rx, ry, Kx, Ky, b])\n\n## Condition initiale:\nc10 = [2, 0]\n\n## Nous définissons un monome y, un polynôme p et nous prenons ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol = y * ((1/b) * (-rx - ry + rx*ry/b)) + \\\n(y**2) * (ry/(Ky * b) * (1 - (rx/b)) + rx/(b * Kx) * (1 - (2*ry/b) + ry**2 /(b**2))) + \\\n2 * (y**3) * ((rx * ry)/((b**2) * Kx * Ky)) * (1 - (ry/b)) + \\\n(y**4) * ((rx * (ry**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution que nous obtenons avec un masque booléen qui sélectionne les racines réelles et strictement positives:\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() > 0)]\nyeq = sol[0].real\n\nxeq = (ry * yeq * ((1/ry) - (1/b) + (yeq/(b * Ky)))).real\n\nfig2, ax = plt.subplots(1, 1, figsize = (8,5))\nfig2.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax.plot(xt,xt * (1/b) * (rx * ((xt/Kx) - 1) + b), \n                    color = 'C2', label = '$\\dot x=0$')\nax.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax.plot(xt * (1/b) * (ry * ((xt/Ky) - 1) + b), xt,\n                    color = 'C3', label = '$\\dot y=0$')\nax.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## Nous réduisons la vue à ce qui nous intéresse:\nax.set_xlim(left = -.3, right = 3)\nax.set_ylim(top = 3, bottom = -.3)\n\n## Nous traçons la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## Nous nommons les axes:\nax.set_xlabel('$x$', fontsize = '12') ;\nax.set_ylabel('$y$', fontsize = '12') ;\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\n\nax.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left', fontsize = 8)\n\n## Nous plaçons les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et nous les relions aux axes:\nxc = np.arange(0, Kx, 0.01)\nax.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#Nous nommons les points:\nax.text(-0.2, Ky, '$K_y$')\nax.text(Kx, -0.2, '$K_x$')\n\n#Nous plaçons les points d'équilibres :\nys = np.arange(0, yeq, 0.01)\nxs = np.arange(0, xeq, 0.01)\n\nax.plot(xeq * np.ones_like(ys), ys, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\nax.plot(xs, yeq * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax.text(-0.2, yeq, '$y^*$')\nax.text(xeq, -0.2, '$x^*$')\n\n## Parabole xdot=0 b=0:\nax.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole $b=0$')\nax.plot(np.zeros_like(xt), xt, color = 'C9')\n\n## Parabole xdot=0 b=+inf:\nax.plot(xt, xt, color = 'C6', label = 'Parabole b=$+\\infty$')\n\n## Nous plaçons des textes indiquant les trois droites:\nax.text(0.05, yeq + 0.4, \"$P_{10}$\")\nax.text(Kx + 0.05, 2.8, \"$P_{20}$\")\nax.text(2.65, 2.45, \"$P_\\infty$\")\n\n## Nous plaçons les trois points:\n## A :\nax.plot(Kx, Ky, marker = '.',color = 'C0', markersize = 7)\nax.text(Kx + 0.1, Ky + 0.1, \"$A$\")\n\n## B :\nax.plot((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky), \n            marker = '.', color = 'C0', markersize = 7)\n\nax.text((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky) + 0.1, \"$B$\")\n\n## C : \nax.plot(Kx, Kx, marker = '.', color = 'C0', markersize = 7)\nax.text(Kx - 0.1, Kx + 0.1, \"$C$\")\n\n## Nous ajoutons D:\nax.plot((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx), \n        (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx),\n        color = 'C0', marker = '.', markersize = 7)\n\nax.text((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx) + 0.07, \n        0.08 + (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx), \"$D$\")\n\n## Nous représentons les deux équilibres:\nax.plot(xeq.real, yeq.real, label = '$(x^*,y^*)$', marker = '.', markersize = 6, color = 'k')\nax.plot(0, 0, label = '$(0,0)$',\n                    marker = '.', markersize = 6, color = 'k')\n\nax.legend(loc = \"lower right\", fontsize = 6.5);\n```\n\n::: {.cell-output .cell-output-display}\n![Plan de phase complet](modelesansmigrationass_files/figure-html/fig-pdp4-output-1.png){#fig-pdp4 width=676 height=480}\n:::\n:::\n\n\nNous voyons maintenant aisément que si $B$ est entre $A$ et $D$ alors les équilibres vont parcourir des valeurs inflationistes seulement (arc orange au dessus de la droite grise).  \n\nSi $B$ est en dessous de $D$ (la coordonnée y de $B$ est plus petite que celle de $D$) alors nous avons d'abord des équilibres inflationistes (de $A$ à $D$) puis déflationnistes (de $D$ à $B$).\n\nMathématiquement nous avons donc : \n\nSi $K_y > K_x$ (la coordonnée $y$ de $B$ est plus grande que celle de $A$) et $K_xr_y > K_yr_x$ (la coordonnée $y$ de $B$ est plus grande que celle de $D$) alors le système est toujours inflationniste.\n\nSi $K_xr_y < K_yr_x$ (la coordonnée $y$ de $B$ est plus petite que celle de $D$) alors le système est d'abord inflationniste puis déflationniste.\n\nNous pouvons vérifier ces deux assertions avec des simulations similaires à la partie précédente : \n\nNous utilisons le même modèle, nous changeons uniquement les paramètres :\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n## Paramètres condition 1: \nrx3 = 0.4\nry3 = 1  #Nous avons bien rx3 < ry3 \nKx3 = 1\nKy3 = 2  #Nous avons bien Ky3>Kx3\n\n#Nous avons la première condition de Kxry > Kyrx\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres condition 2: \nrx4 = 0.6\nry4 = 1  #Nous avons bien rx4 < ry4 \nKx4 = 1  \nKy4 = 2  \n\n#Nous avons la deuxième condition de Kxry > Kyrx\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n```\n:::\n\n\nEt nous simulons à nouveau :\n\n::: {.cell execution_count=19}\n``` {.python .cell-code code-fold=\"true\"}\n## Nous créons la figure et l'axe:\n\nfig5, (ax5, ax6) = plt.subplots(1, 2, figsize = (7, 5))\nax5.set_title(\"Somme des équilibre en fonction de β quand $r_x < r_y$ et $K_y > K_x$ et $K_xr_y > K_yr_x$\", fontsize = 6)\nax6.set_title(\"Somme des équilibre en fonction de β quand $r_x < r_y$ et $K_xr_y < K_yr_x$\", fontsize = 6)\n\nplt.subplots_adjust(wspace = 0.4) #Nous ajustons l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param3, i)) #Nous calculons pour chaque beta l'équilibre\n    ax5.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, c10, t1, args = (param4, i))\n    ax6.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt=np.arange(0, 4, 0.01)\n\nax5.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax5.text(3.2, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\nax6.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax6.text(3.2, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax5.set_xlabel('β')\nax5.set_ylabel('Population')\nax5.plot(Kx3 + Ky3, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\nax6.set_xlabel('β')\nax6.plot(Kx4 + Ky4, 0, color = 'C0', label = 'Somme des équilibres')\n\n## Nous adaptons la fenêtre:\nax5.set_ylim(2.9, 3.2)\nax6.set_ylim(2.9, 3.1)\n\nax5.legend();\nax6.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![Somme des équilibres avec inflation et/ou déflation](modelesansmigrationass_files/figure-html/fig-somme-output-1.png){#fig-somme width=620 height=445}\n:::\n:::\n\n\nNous observons que nous avons bien dans la partie gauche tout le temps inflation et dans la partie droite d'abord inflation puis déflation.\n\n## Animation \n\nPour mieux comprendre comment se déplace le système en fonction des paramètres :\n\n::: {.cell execution_count=20}\n``` {.python .cell-code code-fold=\"true\"}\n#Technique pour utiliser une fenêtre geogebra:\n\nimport IPython.display as display\nfig01 = \"\"\"\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/ajaycvqe\" style = \"border: 1px solid black\"></iframe>\n\"\"\"\n\ndisplay.HTML(fig01)\n```\n\n::: {#fig-anim .cell-output .cell-output-display execution_count=20}\n```{=html}\n\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/ajaycvqe\" style = \"border: 1px solid black\"></iframe>\n```\n\nAnimation Geogebra\n:::\n:::\n\n\n## Inflation et déflation du système en fonction de la migration\n\nDans cette partie nous allons s'intéresser aux sommes des équilibres en fonction de $\\beta$.  \nNous avons déja plus ou moins tracé les différents profils de courbe que nous pouvons obtenir pour cette partie (quand nous avons vérifié les propositions de conditions d'inflation/déflation) mais il existe un quatrième profil de courbe.  \n\nNous allons utiliser les mêmes méthodes que précédemment :\n\n::: {.cell execution_count=21}\n``` {.python .cell-code code-fold=\"false\"}\n#Nous redéfinissons la même fonction:\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n\n## Temps d'intégration :\n\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \n#Paramètres de la condition b):\nrx1 = 0.5\nry1 = 1  \nKx1 = 2\nKy1 = 1  \n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Paramètres condition c.1): \nrx2 = 0.4\nry2 = 1  \nKx2 = 1\nKy2 = 2  \n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n\n## Paramètres condition c.2): \nrx3 = 0.6\nry3 = 1  \nKx3 = 1  \nKy3 = 2  \n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres nouveau profil: \nrx4 = 0.5\nry4 = 2  \nKx4 = 0.5  \nKy4 = 1  \n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n\n## Condition initiale:\n\nc10 = [2, 0]\n\n## Nous créons la figure et l'axe:\n\nfig6, (ax7, ax8, ax9, ax10) = plt.subplots(1, 4, figsize = (9, 5))\nax7.set_title(\"Déflation\", fontsize = 8)\nax8.set_title(\"Inflation\", fontsize = 8)\nax9.set_title(\"Les deux\", fontsize = 8)\nax10.set_title(\"Inflation\", fontsize = 8)\n\nplt.subplots_adjust(wspace = 0.45) #Nous ajustons l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param1, i)) \n    ax7.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n\n    s2 = odeint(aug2, c10, t1, args = (param2, i))\n    ax8.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n    s3 = odeint(aug2, c10, t1, args = (param3, i))\n    ax9.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n    s4 = odeint(aug2, c10, t1, args = (param4, i))\n    ax10.plot(i, s4[-1][0] + s4[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax7.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax7.text(2.5, Kx1 + Ky1 + 0.01, '$K_x+K_y$')\n\nax8.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax8.text(2.5, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\nax9.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax9.text(2.5, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\n\nax10.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax10.text(2.5, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n\n## Légendes:\nax7.set_xlabel('β')\nax7.set_ylabel('Population')\nax7.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\n\nax8.set_xlabel('β')\n\nax9.set_xlabel('β')\n\nax10.set_xlabel('β')\n\n\n## Nous adaptons la fenêtre:\nax7.set_ylim(2.4, 3.1)\nax8.set_ylim(2.95, 3.15)\nax9.set_ylim(2.9, 3.1)\nax10.set_ylim(1.25, 1.75)\n\n#Nous déplaçons la légende hors de la figure:\nax7.legend(bbox_to_anchor = (1, -0.65, 0.5, 0.5));\n```\n\n::: {.cell-output .cell-output-display}\n![4 profils de somme d'équilibre](modelesansmigrationass_files/figure-html/fig-sommeeq-output-1.png){#fig-sommeeq width=738 height=492}\n:::\n:::\n\n\nNous observons quatre profils différents. Les trois premiers ont déjà été obtenus précédemment.   \nLe quatrième correspond à un système inflationniste où le maximum d'inflation est atteint pour $\\beta \\to +\\infty$ contrairement à l'autre profil d'inflation.  \n\nNous pouvons donc observer quatres profils mais en réalité il n'existe que trois possibilités : Déflation, inflation puis déflation et enfin inflation.  Les deux profils d'inflations correspondent au même cas mais avec le point $B$ qui croise l'ellipse à des endroits différents (cette remarque sera détaillée plus tard dans le rapport).\n\nCe modèle nous a permis de poser les bases de la modélisation que nous allons utiliser.  \nNous allons [maintenant passer](modeleavecmigrationass.qmd) à un modèle qui prend en compte que les migrations peuvent être assymétriques et donc nous allons nous rapprocher du cas de l'augmentorium.      \n\n",
    "supporting": [
      "modelesansmigrationass_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}