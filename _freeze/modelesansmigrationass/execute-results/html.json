{
  "hash": "9fa00886aa66934749a84285c92ea073",
  "result": {
    "markdown": "---\ntitle: Modèle logistique structuré avec migration symétrique\n---\n\n---\n\n*Modules à importer :*\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n```\n:::\n\n\n## Définition du modèle\n\nOn pose le modèle suivant d'après @arditi2015 :\n$$\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta(y-x)\\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta(x-y).\n\\end{array}\\right.\n$$ {#eq-modsmig}\n\navec :   \n- $x$ la population dans la première structure,  \n- $y$ la population dans la seconde structure,  \n- $r_x$ et $r_y$ le taux de croissance dans les deux structures,  \n- $K_x$ et $K_y$ les capacités de charge des deux structures,  \n- $\\beta$ la force de migration entre les structures.  \n\nCe modèle est un modèle ressemblant peu à notre situation d'augmentorium car celui-ci est caractérisé par une migration assymétrique, il permet néanmoins de situer la démarche et les outils que nous allons utiliser pour étudier des modèles plus complexes.  \n\n## Dynamique du modèle\n\nOn va tracer la dynamique de la population en fonction du temps pour se faire une première idée de comment se comporte la population.\n\nOn définit le modèle sous [`Python`](https://www.python.org/) :\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b = param\n    x, y = etat\n    s = [ rx * x * ( 1 - x/Kx ) + b * ( y - x ), \n    ry * y * ( 1 - y/Ky ) + b * ( x - y )]\n    return s \n```\n:::\n\n\nOn va utiliser `odeint` de [`Scipy`](https://scipy.org/) afin de simuler une solution en fonction du temps. \nIl faut donc définir un temps d'intégration, des conditions initiales et les paramètres du modèle : \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n## Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n## Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0 ,y0]\n\n## Paramètres: \nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\n\nparam_aug = np.array([rx, ry, Kx, Ky, b])\n\n## Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n```\n:::\n\n\nMaintenant qu'on a la simulation on peut réprésenter la figure avec [`matplotlib`](https://matplotlib.org/) :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfig, ax = plt.subplots(1, 1, figsize = (7, 4 ))\n\nfig.suptitle('Dynamique des ravageurs dans le temps')\nax.plot(ti, s[:, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[:, 1], color = 'C0', label = 'augmentorium')\n\nax.grid() #on ajoute la grille\nax.legend() #on ajoute la légende\n\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-5-output-1.png){width=598 height=394}\n:::\n:::\n\n\nCette simulation nous montre une hausse de la population dans l'augmentorium et une baisse de la population dans la culture.  \nLes deux populations atteignent un équilibre qui semble stable (il se maintient dans le temps).  \n\nDans le cas d'un augmentorium, on voit que le simple fait de débarasser les fruits et de les mettre dans un espace séparé de la culture ammène à une baisse de la population de ravageurs dans la culture.\n\n## Plan de phase\n\n### Equilibres et stabilités\n\nNous allons tracer le plan de phase associé à ce système pour voir les équilibres et leurs stabilités.\n\nA l'équilibre on a par définition $\\dot x = 0$ et $\\dot y =0$ ce qui donne : \n\n$$\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta(y^*-x^*) \\Leftrightarrow  y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right)\\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta(x^*-y^*) \\Leftrightarrow  x^*=r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\n\\end{array}\\right.\n$${#eq-pdpsmig}\n\navec $x^*$ et $y^*$ la valeur des équilibres.\n\nAinsi, les deux isoclines correspondent à des paraboles. Celles-ci se croisent trivialement en $(0,0)$ et dans le quadrant positif en $(x^*,y^*)$. \n\nPour calculer $(x^*,y^*)$ on va utiliser l'expression de $x^*$ trouvée en ([-@eq-pdpsmig]) qu'on va rentrer dans l'équation de $y^*$ :  \n\nComme $x^* = r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)$ on a :  \n$$\ny^* = r_x\\left[r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\\right]\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)}{\\beta K_x}\\right)\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^* = y^* - \\frac{r_yy^*}{\\beta} + \\frac{r_y{y^*}^2}{\\beta K_y} - \\frac{r_xy^*}{\\beta} + \\frac{r_xr_yy^*}{\\beta^2} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_y} + \\\\[.2cm]\n\\frac{r_x{y^*}^2}{\\beta K_x} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\\\[.2cm] \n \\frac{r_xr_y^2{y^*}^2}{\\beta^3 K_x} - \\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_x K_y} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\\\[.2cm]\n \\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_xK_y} + \\frac{r_xr_y^2{y^*}^4}{\\beta^3K_xK_y^2} \n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^*\\left(- \\frac{r_y}{\\beta} - \\frac{r_x}{\\beta} + \\frac{r_xr_y}{\\beta^2}\\right) + \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y} - \\frac{r_xr_y}{\\beta^2 K_y} + \\frac{r_x}{\\beta K_x} - 2\\frac{r_xr_y}{\\beta^2 K_x} + \\frac{r_xr_y^2}{\\beta^3 K_x} \\right) + \\\\[.2cm]\n2{y^*}^3\\left( \\frac{r_xr_y}{\\beta^2 K_xK_y} - \\frac{r_xr_y^2}{\\beta^3 K_xK_y} \\right) + \n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_xK_y^2} = 0\n$$\n\nCe qui donne après réarrangement : \n$$ \ny^*\\left(\\frac{1}{\\beta}\\left[\\frac{r_xr_y}{\\beta} - r_y -r_x\\right]\\right)+ \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y}\\left[1-\\frac{r_x}{\\beta}\\right]+\\frac{r_x}{\\beta K_x}\\left[1-2\\frac{r_y}{\\beta}+\\frac{r_xr_y}{\\beta^2}\\right]\\right)+\\\\[.2cm]\n2{y^*}^3\\left(\\frac{r_xr_y}{\\beta^2 K_xK_y}\\left[1-\\frac{r_y}{\\beta}\\right]\\right) + \n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_y^2K_x} = 0\n$${#eq-polsmig}\n\nCe polynôme est résoluble via [`numpy`](https://numpy.org/) pour obtenir $y^*$:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n## On défnit un monome y, un polynôme p et on prend ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol = y * (rx * ry * ((1/b) * ((1/b) - (1/rx) - (1/ry)) + 1/(rx * ry)) - 1) + \\\n(y**2) * ((rx*ry)/b) * ((1/Ky) * ((1/rx) - (1/b)) + (1/Kx) * ((1/ry) - (2/b) + (ry/(b**2)))) + \\\n2 * (y**3) * ((rx * ry)/((b**2) * Kx * Ky)) * (1 - (ry/b)) + \\\n(y**4) * ((rx * (ry**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution qu'on obtient avec un masque booléen qui sélectionne les racines réelles et strictement positives:\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() > 0)]\nyeq=sol[0].real\n```\n:::\n\n\nOn déduit $x^*$ via sa définition par le système [(-@eq-pdpsmig)]:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nxeq = (ry * yeq * ((1/ry) - (1/b) + (yeq/(b * Ky)))).real\n```\n:::\n\n\nAvec la valeur des équilibres on va maintenant tracer le plan de phase : \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfig, ax = plt.subplots(1, 1)\nfig.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax.plot(xt,xt * (1/b) * (rx * ((xt/Kx) - 1) + b), \n                    color = 'C2', label = '$\\dot x=0$')\nax.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax.plot(xt * (1/b) * (ry * ((xt/Ky) - 1) + b), xt,\n                    color = 'C3', label = '$\\dot y=0$')\nax.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## On réduit la vue à ce qui nous intéresse:\nax.set_xlim(left = -.3, right = 3)\nax.set_ylim(top = 3, bottom = -.3)\n\n## On trace la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## On nomme les axes:\nax.set_xlabel('$x$', fontsize = '12') ;\nax.set_ylabel('$y$', fontsize = '12') ;\n\n## On plot les deux équilibres:\nax.plot(xeq.real, yeq.real, label = '$(x^*,y^*)$', marker = '.', markersize = 6, color = 'k')\nax.plot(0, 0, label = '$(0,0)$',\n                    marker = '.', markersize = 6, color = 'k')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax.quiver(X, Y, dx, dy, angles = 'xy', \n                    color = 'grey', scale = 80, width = 0.003);\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-8-output-1.png){width=602 height=480}\n:::\n:::\n\n\nComme dit plus haut on a bien un croisement dans le quadrant positif qui correspond à l'équilibre $(x^*,y^*)$. \n\nLes paraboles, en fonction des valeurs de leurs racines, peuvent croiser de différentes manières les axes des abssices et des ordonnées.  \nLe plan de phase peut donc présenter plusieurs profils, autre que \ncelui tracé ici. Néanmoins, le croisement des paraboles dans le quadrant positif (l'équilibre non nul) est toujours présent quelque soit le profil.\n\nEn faisant apparaître le champ de vecteur on peut déduire que l'équilibre en $(0,0)$ est instable et l'équilibre en $(x^*,y^*)$ est stable.\n\n#### Stabilité mathématique des équilibres\n\nIl est clair que $(0,0)$ est instable et $(x^*,y^*)$ est stable (par le champ de vecteur).  \nMathématiquement considérons la jacobienne de ([-@eq-modsmig]): \n$$ \n\\mathbb{J}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy}{K_y}-\\beta\n\\end{pmatrix}\n$${#eq-jacob}\n\net donc **pour $(0,0)$**:  \n\n$$\n\\mathbb{J_{\\vec{0}}}=\\begin{pmatrix}\n\\ r_x-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\beta\n\\end{pmatrix}\n$$\n\nLes valeurs propres $\\lambda _1$ et $\\lambda _2$ de cette matrice sont les solutions du polynôme caractéristique définit par : \n$$\n\\begin{vmatrix}\nr_x-\\beta-\\lambda & \\beta \\\\\n\\beta & r_y -\\beta -\\lambda \\\n\\end{vmatrix} = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n(r_x-\\beta-\\lambda)(r_y-\\beta - \\lambda) - \\beta^2 = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n\\lambda^2 + \\lambda\\left(2\\beta - r_x - r_y\\right) + r_xr_y - \\beta(r_x+r_y) = 0\n$$\n\nLe discriminant $\\Lambda$ est donc définit par :  \n$$\n\\Lambda = \\left(2\\beta - r_x - r_y\\right)^2 - 4(r_xr_y - \\beta[r_x+r_y]) \\\\\n= 4\\beta^2 -4\\beta(r_x +r_y) + r_x^2 +r_y^2 +2r_xr_y -4r_xr_y +4\\beta(r_x +r_y) \\\\ = 4\\beta^2 + (r_x-r_y)^2\n$$\n\nEt donc le spectre $\\sigma$ de la jacobienne est :  \n$$\n\\sigma_\\mathbb{J} = \\left(\\lambda_1 = \\frac{r_x+r_y-2\\beta-2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2},\\lambda_2=\\frac{r_x+r_y-2\\beta+2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2}\\right)\n$$\n\net on a ainsi,\n\n$$\n\\lambda_2 > 0\n$$\n\nDonc $(0,0)$ est bien instable.  \n\n**Pour $(x^*,y^*)$** on a :\n$$ \n\\mathbb{J_{x^*,y^*}}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx^*}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy^*}{K_y}-\\beta\n\\end{pmatrix}\n$${#eq-jacob}\n\nor, on a aussi d'après ([-@eq-pdpsmig]) : \n\n$$\n\\left\\{\\begin{array}{l}\n\\frac{y^*\\beta}{x^*} = \\beta - r_x + \\frac{r_xx^*}{K_x}   \\\\\n\\frac{x^*\\beta}{y^*} = \\beta - r_y + \\frac{r_yy^*}{K_y}  \n\\end{array}\\right.\n$$\n\nce qui simplifie la jacobienne en $(x^*,y^*)$ à l'expression suivante :\n\n$$ \\mathbb{J_{x^*,y^*}} = \\begin{pmatrix}\n\\ -\\frac{\\beta y^*}{x^*}-\\frac{r_xx^*}{K_x} & \\beta \\\\\n\\ \\beta & -\\frac{\\beta x^*}{y^*}-\\frac{r_yy^*}{K_y}\n\\end{pmatrix}\n$$\n\nIl est alors facile de vérifier que la trace de cette matrice est négative.  \n\nLe déterminant quant à lui est donné par : \n$$\n\\alpha = \\left(\\frac{\\beta y^*}{x^*}+\\frac{r_xx^*}{K_x}\\right)\\left(\\frac{\\beta x^*}{y^*}+\\frac{r_yy^*}{K_y}\\right) - \\beta^2 \\\\\n= \\frac{\\beta r_y{y^*}^2}{x^*K_y} + \\frac{\\beta r_x {x^*}^2}{y^*K_x} + \\frac{r_xr_yx^*y^*}{K_xK_y} > 0\n$$\n\nLe déterminant est lui positif, d'après la classification des portaits de plan de phase dans $\\mathbb{R}^2$ on a que $(x^*,y^*)$ est stable.\n\n\n### Analyse du plan de phase\n\nOn remarque sur le plan de phase du système tracé précédemment que l'équilibre atteint n'est pas sur la droite $x^*+y^*=K_x+K_y$ (en gris), on appellera cette droite $d$.  \nSi le croisement des isoclines est au dessus de cette droite le système ([-@eq-modsmig]) subit une inflation et si le croisement est en dessous de cette droite il subit une déflation (voir [contexte](contexte.qmd)).  \n\nOn voit que la structuration de l'espace, et les migrations qui en découle, perturbent les équilibres qui auraient dû être la somme des équilires des deux régions (la logistique tend vers la capacité maximale à l'équilibre).   \n\n\nPlus généralement, on peut montrer qu'en cas de mixité parfaite entre les deux structures ($\\beta \\to \\infty$) on a d'après @arditi2015:\n\n$$\nx^*+y^* = K_x + K_y + (K_x-K_y)\\frac{r_xK_y-r_yK_x}{r_xK_y+r_yK_x}\n$${#eq-inf}\n\nCe qui montre qu'en général on a pas $x^*+y^* = K_x + K_x$.  \nDe plus par ([-@eq-inf]), si $K_y<K_x$ et si $r_xK_y<r_yK_x$ alors $x^*+y^* < K_x+K_y$ ce qui nous intéresse particulièrement pour la lutte biologique.  \n\nEnsuite, en faisant $\\dot x + \\dot y = 0$, dans le cas de l'équilibre, on a:\n$$ \nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+r_yy^*\\left(1-\\frac{y^*}{K_y}\\right) = 0 \n$${#eq-ell}\n\nAutrement dit les points d'équilibres vivent sur une ellipse (si on ne modifie que $\\beta$ ), qu'on va tracer avec `contour` :\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\n\nax.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left', fontsize = 8)\n\n## On place les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et on les relie aux axes:\nxc = np.arange(0, Kx, 0.01)\nax.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#On nomme les points:\nax.text(-0.2, Ky, '$K_y$')\nax.text(Kx, -0.2, '$K_x$')\n\n#On place les points d'équilibres :\nys = np.arange(0, yeq, 0.01)\nxs = np.arange(0, xeq, 0.01)\n\nax.plot(xeq * np.ones_like(ys), ys, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\nax.plot(xs, yeq * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax.text(-0.2, yeq, '$y^*$')\nax.text(xeq, -0.2, '$x^*$')\n\ndisplay(fig)\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-9-output-1.png){width=602 height=480}\n:::\n:::\n\n\nLes conditions d'inflations et de déflations suivantes proviennent de l'article d'@arditi2018.\n\n#### Première condition à un système déflationiste \nOn remarque que le point $(K_x,K_y)$ est en permanence sur la droite $d$ qui coupe en permanence l'ellipse (en deux points) sauf pour une situation où $d$ est tangente à l'ellipse.  \nCe cas nous intéresse car il rend compte d'un système entièrement déflationiste. Représentons le sur le plan de phase :\n\n\nOn redéfinit les paramètres pour être dans le cas qui nous intéresse :\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n## Paramètres: \nrxnew = 0.5\nrynew = 0.5\nKx = 2\nKy = 1\nb = 1\n```\n:::\n\n\nEt on trace de la même manière que précédemment le plan de phase :\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nfig2, ax2 = plt.subplots(1, 1)\nfig2.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax2.plot(xt,xt * (1/b) * (rxnew * ((xt/Kx) - 1) + b), color = 'C2', \n                label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax2.plot(xt * (1/b) * (rynew * ((xt/Ky) - 1) + b), xt, color = 'C3', \n                label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## On réduit la vue à ce qui nous intéresse:\nax2.set_xlim(left = -.3, right = 3)\nax2.set_ylim(top = 3, bottom = -.3)\n\n## On trace la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## On nomme les axes:\nax2.set_xlabel('$x$', fontsize = '12') ;\nax2.set_ylabel('$y$', fontsize = '12') ;\n\n## On recalcule les équilibres avec les nouveaux paramètres:\n## On défnit un monome y, un polynôme p et on prend ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol2 = y * (rxnew * rynew * ((1/b) * ((1/b) - (1/rxnew) - (1/rynew)) + 1/(rxnew * rynew)) - 1) + \\\n(y**2) * ((rxnew*rynew)/b) * ((1/Ky) * ((1/rxnew) - (1/b)) + (1/Kx) * ((1/rynew) - (2/b) + (rynew/(b**2)))) + \\\n2 * (y**3) * ((rxnew * rynew)/((b**2) * Kx * Ky)) * (1 - (rynew/b)) + \\\n(y**4) * ((rx * (rynew**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution qu'on obtient avec un masque booléen qui sélectionne les \n## racines réelles et strictement positives:\nsol2 = pol2.roots()[ (np.isreal( pol2.roots() )) * (pol2.roots() > 0)]\nyeq2=sol2[0].real\n\n## On calcule x*\nxeq2 = (rynew * yeq2 * ((1/rynew) - (1/b) + (yeq2/(b * Ky)))).real\n\n## On plot les deux équilibres:\nax2.plot(xeq2.real, yeq2.real, label = '$(x^*,y^*)$', marker = '.', \n                markersize = 6, color = 'k')\nax2.plot(0, 0, label = '$(0,0)$', marker = '.', markersize = 6, \n                color = 'k')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', \n                scale = 80, width = 0.003) ;\n\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rxnew * X2 * (1 - X2/Kx)\nY = rynew * Y2 * (1 - Y2/Ky)\n\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left', fontsize = 8)\n\n## On place les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax2.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et on les relie aux axes:\nxc = np.arange(0, Kx, 0.01)\nax2.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax2.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#On nomme les points:\nax2.text(-0.2, Ky, '$K_y$')\nax2.text(Kx, -0.2, '$K_x$')\n\n#On place les points d'équilibres :\nys = np.arange(0, yeq2, 0.01)\nxs = np.arange(0, xeq2, 0.01)\n\nax2.plot(xeq2 * np.ones_like(ys), ys, linestyle = 'dashed',\n                color = 'k', linewidth = 0.5)\nax2.plot(xs, yeq2 * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax2.text(-0.2, yeq2, '$y^*$');\nax2.text(xeq2, -0.2, '$x^*$');\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-11-output-1.png){width=602 height=480}\n:::\n:::\n\n\nL'ellipse, d'équation $f(x,y)=r_xx\\left(1-\\frac{x}{K_x}\\right)+r_yy\\left(1-\\frac{y}{K_y}\\right) = 0$  , peut être vue comme la ligne de niveau de $f$ en $0$. \n\nAinsi, une équation de la tangente au point $(x_0,y_0)$ est donnée par:   \n$$\n\\frac{\\partial f}{\\partial x}(x_0,y_0)(x-x_0)+ \\frac{\\partial f}{\\partial y}(x_0,y_0)(y-y_0) = 0\n$${#eq-eqa}\n\nautrement dit :\n$$\n\\left(r_x - 2\\frac{r_xx_0}{K_x}\\right)(x-x_0) + \\left(r_y -2\\frac{r_yy_0}{K_y}\\right)(y-y_0) = 0\n$$\n\nDans le cas où $x_0=K_x$ et $y_0=K_y$ on a alors :\n$$\n-r_x(x-K_x) -r_y(y-K_y) = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny = -\\frac{r_x}{r_y}\\left(x-K_x\\right) + K_y\n$${#eq-tang}\n\nqui est donc l'équation de la tangente à l'ellipse au point $(K_x,K_y)$.\n\nSi maintenant on prend $r_x=r_y$ alors on remarque que ([-@eq-tang]) est égale à l'équation de la droite $d$ ce qui implique que toute l'ellipse est en dessous de $d$ et donc que tous les équilibres sont déflationistes.\n\n**Donc : si $r_x=r_y$ on a ([-@eq-modsmig]) qui est déflationiste quelque soit le taux de migration.**\n\nOn va effectuer une simulation avec les paramètres déduits à l'instant pour confirmer ce qu'on vient de dire.  \nPour cela on va, pour chaque $\\beta$, simuler un temps suffisament large pour atteindre l'équilibre et représenter la somme des deux équilibres.\n\nIl faut donc définir une fonction qui prend en compte le changement de $\\beta$ :\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n```\n:::\n\n\nAinsi qu'un temps d'intégration large, des conditions initiales et des paramètres :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n## Temps d'intégration :\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \nrx1 = 0.5\nry1 = 0.5 # =on prend rx1=rx2\nKx1 = 2\nKy1 = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Condition initiale:\nc10 = [2, 0]\n```\n:::\n\n\nEt enfin on simule avec `odeint` et on fait une boucle pour simuler que $\\beta$ va de $0$ à $4$ (suffisant pour avoir une courbe intéressante):\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n## On crée la figure et l'axe:\nfig3, ax3 = plt.subplots(1, 1)\nfig3.suptitle(\"Somme des équilibres en fonction de β quand $r_x = r_y$\")\n\n## Boucle ou i prend les valeurs de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param1, i)) #On calcule pour chaque beta l'équilibre\n    ax3.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\nxt = np.arange(0, 4, 0.01)\n\nax3.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax3.text(3.2, Kx + Ky + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax3.set_xlabel('β')\nax3.set_ylabel('Population')\nax3.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\n\n## On adapte la fenêtre:\nax3.set_ylim(2.2, 3.2)\n\nax3.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-14-output-1.png){width=589 height=477}\n:::\n:::\n\n\nOn voit que la courbe bleu représentant la somme des équilibres est en permanence en dessous de la droite $K_x+K_y$. On a bien un système entièrement déflationiste quand $r_x = r_y$.  \n\n\n#### Deuxième condition à un système déflationiste\n\nOn va maintenant considérer le cas où $r_x < r_y$ c'est à dire qu'on va prendre l'ellipse dans un seul sens (voir sur l'animation Geogebra).\n\nOn va analyser graphiquement le plan de phase.  On aura besoin de tracer les droites définies par $\\beta = 0$ et $\\beta = +\\infty$ dans l'équation $y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right)$  (la parabole verte dans le plan de phase définie par $\\dot x =0$).\n\nEn effet, ceci va permettre d'encadrer l'équilibre $(x^*,y^*)$ en fonction du taux de migration.\n\nLorsque $\\beta = 0$ on a, par la première équation de ([-@eq-pdpsmig]) :\n$$\n0 = r_xx^*(1-\\frac{x^*}{K_x})\n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^*=K_x \\vee x^* = 0\n$$\n\nDonc lorsque le taux de migration est nul la parabole correspondant à $\\dot x = 0$ a pour équation les droites $x^*=0$ et $x^*=K_x$ qu'on appelle respectivement $P_{10}$ et $P_{20}$. \n\n\nLorsque $\\beta = + \\infty$ on a, encore une fois par la première équation de ([-@eq-pdpsmig]):\n\n$$\ny^* = r_xx^*\\frac{1}{r_x} = x^*\n$$ \n\nAinsi quand le taux de migration tend vers l'infini la parabole $\\dot x = 0$ correspond à la droite $y^*=x^*$ qu'on appelle $P_\\infty$.\n\nOn notera dans la suite $A=(K_x,K_y)$, $B$ l'intersection non trivial (pas $(0,0)$) entre $P_\\infty$ et l'ellipse et $C$ l'intersection non trivial (pas $(K_x,0)$) entre $P_{20}$ et $P_\\infty$. \n\nPour calculer les coordonées de $B$ on utilise que $y^*=x^*$ et on le rentre dans ([-@eq-ell]) ce qui donne :\n$$\nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right)+r_y\\left(1-\\frac{x^*}{K_y}\\right)\\right) = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^* = \\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}}\n$$ \n\net comme $B$ est sur $P_\\infty$ alors on a :\n$$\ny^*= \\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}}\n$$\n$B$ est donc définie comme :  \n$$\nB = (\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}},\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}})\n$$\n\nPour calculer les coordonées de $C$ on utilise que $y^*=x^*$ dans la définition de $P_{20}$, ie comme $P_{20}$ est défini par $x^* =K_x$ alors $y^*=K_x$ et donc on a :\n$$\nC=(K_x,K_x)\n$$\n\nReprésentons le tout sur le premier plan de phase:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n## Parabole xdot=0 b=0:\nax.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole b=0')\nax.plot(np.zeros_like(xt), xt, color = 'C9')\n\n## Parabole xdot=0 b=+inf:\nax.plot(xt, xt, color = 'C6', label = 'Parabole b=$+\\infty$')\n\n## On place des textes indiquant les trois droites:\nax.text(0.05, yeq + 0.4, \"$P_{10}$\")\nax.text(Kx + 0.05, 2.8, \"$P_{20}$\")\nax.text(2.65, 2.45, \"$P_\\infty$\")\n\n## On place les trois points:\n## A :\nax.plot(Kx, Ky, marker = '.',color = 'C0', markersize = 7)\nax.text(Kx + 0.1, Ky + 0.1, \"$A$\")\n\n## B :\nax.plot((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky), \n            marker = '.', color = 'C0', markersize = 7)\n\nax.text((rx + ry)/(rx/Kx + ry/Ky) - 0.1, (rx + ry)/(rx/Kx + ry/Ky) + 0.1, \"$B$\")\n\n## C : \nax.plot(Kx, Kx, marker = '.', color = 'C0', markersize = 7)\nax.text(Kx - 0.1, Kx + 0.1, \"$C$\")\n\nax.legend(loc = \"upper left\", fontsize = 6.5)\n\ndisplay(fig)\n```\n\n::: {.cell-output .cell-output-display}\n![Plan de phase complet](modelesansmigrationass_files/figure-html/fig-pdp-output-1.png){#fig-pdp width=602 height=480}\n:::\n:::\n\n\nLorsque $\\beta$ augmente de $0$ à $+\\infty$ on a l'équilibre qui parcourt l'ellipse de $A$ à $B$.  \nPour que le système soit déflationiste on veut que la portion de l'ellipse de $A$ à $B$ soit complètement en dessous de la droite $d$ (grise).  \nPour ce faire on peut voir sur notre plan de phase qu'il faut que $C$ ait une coordonée $y$ plus grande que $A$ afin que $B$ soit toujours à gauche de $A$ (et donc en dessous de $d$). \n\nMathématiquement on veut donc que $K_x > K_y$. \n\nAinsi si on a $r_x < r_y$ et $K_x>K_y$ on aura tout le temps un modèle déflationiste pour les ravageurs.\n\nCeci est intéressant pour l'augmentorium, si on a la capacité de charge l'augmentorium qui est plus faible que celle de la culture alors le système est toujours négatif pour la population totale de ravageurs. \n\nOn peut aussi voir graphiquement que dans ce cas là on a toujours $x^* < K_x$, c'est ce que l'on cherche à obtenir. \n\nOn peut illustrer notre condition avec une simulation similaire à la partie précédente : \n\nOn utilise le même modèle, on change uniquement les paramètres :\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n## Paramètres : \nrx2 = 0.5\nry2 = 1  #On a bien rx2 < ry2 \nKx2 = 2\nKy2 = 1  #On a bien Kx2>Ky2\n\n## En l'occurence il s'agit des paramètres de base qu'on avait utilisé ##pour la simulation du premier plan de phase expliquant qu'on se ##retrouvait avec un équilibre déflationiste.\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n```\n:::\n\n\nEt on simule à nouveau :\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"true\"}\n## On crée la figure et l'axe:\n\nfig4, ax4 = plt.subplots(1, 1)\nfig4.suptitle(\"Somme des équilibre en fonction de β quand $r_x < r_y$ et $K_x > K_y$\")\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param2, i)) #On calcule pour chaque beta l'équilibre\n    ax4.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax4.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax4.text(3.2, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax4.set_xlabel('β')\nax4.set_ylabel('Population')\nax4.plot(Kx2+Ky2, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\n\n## On adapte la fenêtre:\nax4.set_ylim(2.2, 3.2)\n\nax4.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-17-output-1.png){width=589 height=477}\n:::\n:::\n\n\nOn observe qu'on a bien une déflation du système quelque soit le taux de migration.\n\n#### Conditions pour une inflation et/ou une déflation\n\nSur la base de la @fig-pdp on peut aussi déduire quand est-ce qu'on peut avoir inflation selon les paramètres.  \n\nIl s'agit de la même idée de preuve graphique qu'avant mais en complexifiant un peu.  Pour cela on va avoir besoin d'un quatrième point qu'on appellera $D$ et qui correspond à l'autre intersection entre l'ellipse et la droite $d$ (pas $(K_x,K_y)$).\n\nPour trouver les coordonnées de $D$ on a simplement que comme $D$ est sur $d$ alors on a $y^* = -x^* + K_x + K_y$ et on remplace $y^*$ dans ([-@eq-ell]) ce qui donne : \n$$\nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right) +r_y(-x^*+K_x+K_y)\\left(1-\\frac{-x^*+K_x+K_y}{K_y} \\right) = 0 \n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{r_yK_x}{K_y}\\left(1-\\frac{x^*}{K_x} \\right) \\right) + \\frac{r_y(K_x+K_y)}{K_y}(x^*-K_x) = 0\n$$\n$$\n\\Leftrightarrow\n$$\n$$\n\\left(1-\\frac{x^*}{K_x}\\right)\\left(x^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right]-\\frac{r_yK_x(K_x+K_y)}{K_y}\\right) = 0\n$$\n\nCe qui donne soit $x^* = K_x$ et on retouve alors $A$, soit :  \n$$\nx^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right] = \\frac{r_yK_x(K_x+K_y)}{K_y}\n$$\n$$\n\\Leftrightarrow\n$$\n$$\nx^* = \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n$$\n\nEt donc d'après la définition de $y^*$ :\n$$\ny^* = - \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} + K_x + K_y\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^* = \\frac{(K_x+K_y)(r_xK_y+r_yK_x)-r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n$$\n$$\n\\Leftrightarrow\n$$\n$$\ny^*=\\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x}\n$$\n\n\nAinsi, $D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} )$ .\n\nAjoutons $D$ au plan de phase :\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n## On ajoute D:\nax.plot((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx), \n        (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx),\n        color = 'C0', marker = '.', markersize = 7)\n\nax.text((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx) + 0.07, \n        0.08 + (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx), \"$D$\")\n\ndisplay(fig)\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-18-output-1.png){width=602 height=480}\n:::\n:::\n\n\nOn voit maintenant aisément que si $B$ est entre $A$ et $D$ alors les équilibres vont parcourir des valeurs inflationistes seulement (arc orange au dessus de la droite grise).  \n\nSi $B$ est en dessous de $D$ (la coordonnée y de $B$ est plus petite que celle de $D$) alors on a d'abord des équilibres inflationistes (de $A$ à $D$) puis déflationistes (de $D$ à $B$).\n\nMathématiquement on a donc : \n\nSi $K_y > K_x$ (la coordonnée $y$ de $B$ est plus grande que celle de $A$) et $K_xr_y > K_yr_x$ (la coordonnée $y$ de $B$ est plus grande que celle de $D$) alors le système est toujours inflationiste.\n\nSi $K_xr_y < K_yr_x$ (la coordonnée $y$ de $B$ est plus petite que celle de $D$) alors le système est d'abord inflationiste puis déflationiste.\n\nOn peut vérifier ces deux assertions avec des simulations similaires à la partie précédente : \n\nOn utilise le même modèle, on change uniquement les paramètres :\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n## Paramètres condition 1: \nrx3 = 0.4\nry3 = 1  #On a bien rx3 < ry3 \nKx3 = 1\nKy3 = 2  #On a bien Ky3>Kx3\n\n#On a la première condition de Kxry > Kyrx\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres condition 2: \nrx4 = 0.6\nry4 = 1  #On a bien rx4 < ry4 \nKx4 = 1  \nKy4 = 2  \n\n#On a la deuxième condition de Kxry > Kyrx\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n```\n:::\n\n\nEt on simule à nouveau :\n\n::: {.cell execution_count=19}\n``` {.python .cell-code code-fold=\"true\"}\n## On crée la figure et l'axe:\n\nfig5, (ax5, ax6) = plt.subplots(1, 2, figsize = (7, 5))\nax5.set_title(\"Somme des équilibre en fonction de β quand $r_x < r_y$ et $K_y > K_x$ et $K_xr_y > K_yr_x$\", fontsize = 6)\nax6.set_title(\"Somme des équilibre en fonction de β quand $r_x < r_y$ et $K_xr_y < K_yr_x$\", fontsize = 6)\n\nplt.subplots_adjust(wspace = 0.4) #On ajuste l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param3, i)) #On calcule pour chaque beta l'équilibre\n    ax5.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, c10, t1, args = (param4, i))\n    ax6.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt=np.arange(0, 4, 0.01)\n\nax5.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax5.text(3.2, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\nax6.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax6.text(3.2, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax5.set_xlabel('β')\nax5.set_ylabel('Population')\nax5.plot(Kx3 + Ky3, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\nax6.set_xlabel('β')\nax6.plot(Kx4 + Ky4, 0, color = 'C0', label = 'Somme des équilibres')\n\n## On adapte la fenêtre:\nax5.set_ylim(2.9, 3.2)\nax6.set_ylim(2.9, 3.1)\n\nax5.legend();\nax6.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-20-output-1.png){width=620 height=445}\n:::\n:::\n\n\nOn observe qu'on a bien dans la partie gauche tout le temps inflation et dans la partie droite d'abord inflation puis déflation.\n\n## Animation \n\nPour mieux comprendre comment se déplace le système en fonction des paramètres :\n\n::: {.cell execution_count=20}\n``` {.python .cell-code code-fold=\"true\"}\n#Technique pour utiliser une fenêtre geogebra:\n\nimport IPython.display as display\nfig01 = \"\"\"\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/ajaycvqe\" style = \"border: 1px solid black\"></iframe>\n\"\"\"\n\ndisplay.HTML(fig01)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=html}\n\n<iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/ajaycvqe\" style = \"border: 1px solid black\"></iframe>\n```\n:::\n:::\n\n\n## Inflation et déflation du système en fonction de la migration\n\nDans cette partie on va s'intéresser aux sommes des équilibres en fonction de $\\beta$.  \nOn a déja plus ou moins tracé les différents profils de courbe qu'on peut obtenir pour cette partie (quand on a vérifié les propositions de conditions d'inflation/déflation) mais il existe un quatrième profil de courbe.  \n\nOn va utiliser les mêmes méthodes que précédemment :\n\n::: {.cell execution_count=21}\n``` {.python .cell-code code-fold=\"false\"}\n#On redéinit la même fonction:\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n\n## Temps d'intégration :\n\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \n#Paramètres de la condition b):\nrx1 = 0.5\nry1 = 1  \nKx1 = 2\nKy1 = 1  \n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Paramètres condition c.1): \nrx2 = 0.4\nry2 = 1  \nKx2 = 1\nKy2 = 2  \n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n\n## Paramètres condition c.2): \nrx3 = 0.6\nry3 = 1  \nKx3 = 1  \nKy3 = 2  \n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres nouveau profil: \nrx4 = 0.5\nry4 = 2  \nKx4 = 0.5  \nKy4 = 1  \n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n\n## Condition initiale:\n\nc10 = [2, 0]\n\n## On crée la figure et l'axe:\n\nfig6, (ax7, ax8, ax9, ax10) = plt.subplots(1, 4, figsize = (9, 5))\nax7.set_title(\"Déflation\", fontsize = 8)\nax8.set_title(\"Inflation\", fontsize = 8)\nax9.set_title(\"Les deux\", fontsize = 8)\nax10.set_title(\"Inflation\", fontsize = 8)\n\nplt.subplots_adjust(wspace = 0.45) #On ajuste l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param1, i)) \n    ax7.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n\n    s2 = odeint(aug2, c10, t1, args = (param2, i))\n    ax8.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n    s3 = odeint(aug2, c10, t1, args = (param3, i))\n    ax9.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n    s4 = odeint(aug2, c10, t1, args = (param4, i))\n    ax10.plot(i, s4[-1][0] + s4[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax7.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax7.text(2.5, Kx1 + Ky1 + 0.01, '$K_x+K_y$')\n\nax8.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax8.text(2.5, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\nax9.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax9.text(2.5, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\n\nax10.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax10.text(2.5, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n\n## Légendes:\nax7.set_xlabel('β')\nax7.set_ylabel('Population')\nax7.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\n\nax8.set_xlabel('β')\n\nax9.set_xlabel('β')\n\nax10.set_xlabel('β')\n\n\n## On adapte la fenêtre:\nax7.set_ylim(2.4, 3.1)\nax8.set_ylim(2.95, 3.15)\nax9.set_ylim(2.9, 3.1)\nax10.set_ylim(1.25, 1.75)\n\n#On déplace la légende hors de la figure:\nax7.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5));\n```\n\n::: {.cell-output .cell-output-display}\n![](modelesansmigrationass_files/figure-html/cell-22-output-1.png){width=738 height=492}\n:::\n:::\n\n\nOn observe quatre profils différents. Les trois premiers ont déjà été obtenus précédemment.   \nLe quatrième correspond à un système inflationiste où le maximum d'inflation est atteint pour $\\beta = +\\infty$ contrairement à l'autre profil d'inflation.\n\n&nbsp;     \n\n[Passons](modeleavecmigrationass.qmd) mainenant à un modèle qui prend en compte que les migrations peuvent êtres assymétriques.\n\n",
    "supporting": [
      "modelesansmigrationass_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}