[
  {
    "objectID": "contexte.html",
    "href": "contexte.html",
    "title": "Contexte",
    "section": "",
    "text": "L’augmentorium est un outil ressemblant à une tente que l’on met dans les cultures afin d’y entreposer des fruits ou des légumes attaqués par des ravageurs.\n\nDescription de la structure\n\n\n\n\nAugmentorium en culture; Photo: J-P Deguine, Cirad\n\n\n\nL’augmentorium possède une ouverture pour entreposer les fruits et une grille afin de libérer les prédateurs de ces ravageurs (plus petits).\nL’augmentorium peut être enterré, afin de préserver d’une sortie des larves de ravageurs par le bas.\nOn observe aussi sur les modèles de plus haute génération des sas ou bien le déplacement de la grille (et donc de la lumière) à l’opposé de l’ouverture.\n\n\nAvantage biologique\nCette méthode, prophylactique, permet de concentrer les ravageurs dans un espace clos presque sans migration vers l’extérieur.\nEn effet, la taille des mailles de la grille permet de cloisonner près de 100% des ravageurs et libérer jusqu’à 98% des prédateurs (Deguine JP (2011)).\nAinsi, cette méthode permet à la fois de casser le cycle de reproduction des ravageurs mais aussi d’augmenter le ratio prédateurs sur ravageurs dans les cultures et enfin de garantir aux ravageurs, et donc aux prédateurs, un lieu propice à la reproduction.\nCette méthode s’inscrit dans une démarche de lutte intégrée car elle permet de réduire les pesticides dans les cultures et se sert de l’effet direct de prédation des prédateurs sur les ravageurs.\n\n\nModélisation utilisée\nNotre modélisation se fonde sur des modèles de dynamique des populations. Nous nous baserons sur des systèmes d’équations différentielles.\nLes naissances des ravageurs seront simulées par une croissance logistique (modèle de Verhulst). Une étude de ce modèle est laissée au lecteur ici.\nLe modèle final est un modèle proie-prédateur en deux structures avec de la migration assymétrique entre chaque structure.\nNous allons tout au long de ce rapport suivre une évolution dans les modèles en les complexifiant peu à peu.\nLes premiers modèles ont déja été analysés, peu à peu les études se feront de plus en plus rare (ou du moins incomplètes).\n\n\nNotion d’inflation et de déflation\nPour mieux comprendre les analyses faites dans ce rapport il faut comprendre le concept d’inflation d’un système biologique.\nDans les années 70 certains articles (Freedman (1977)) mentionnent que lorsqu’on considère un modèle avec deux zones et dans chaque zone une population qui échange avec l’autre librement des individus, alors la somme des équilibres est le plus souvent différente de celle qu’elle serait si il n’y avait qu’une zone.\nC’est ce qu’on appelle le débat SLOSS (Single Large Or Several Small). On dit qu’une population structurée est caractérisée par un phénomène d’inflation si la somme de ses équilibres est plus grande que l’équilibre s’il n’y avait qu’une structure (et l’inverse pour la déflation).\nL’objectif de l’augmentorium est de provoquer une déflation du système chez les ravageurs.\nNous allons commencer avec un modèle de base qui permet de situer la démarche et le type d’analyse possible face à ce genre de modèles.\nC’est parti !\n\n\n\n\n\n\n\nReferences\n\nDeguine JP, Quilici S, Atiama-Nurbel T. 2011. “Net Choice Is Key to the Augmentorium Technique of Fruit Fly Sequestration and Parasitoid Release.” Crop Protection 30: 198–202.\n\n\nFreedman, Waltman, H. I. 1977. “Mathematical Models of Population Interactions with Dispersal.” J. Appl. Math. 32: 631–48.\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "À propos",
    "section": "",
    "text": "Ce site a été généré grâce à Github.\nCes pages ont été générées avec Quarto, Jupyter et Python (version 3.10.10).\nLes principaux modules utilisés sont NumPy, Matplotlib, SciPy et Plotly.\nQuelques animations ont été réalisées sous Geogebra.\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Présentation",
    "section": "",
    "text": "Les prochaines pages regroupent mes travaux à l’INRAE Sophia-Antipolis lors de mon stage de L2 du 22/05/2023 au 21/07/23 sous la tutelle de Ludovic Mailleret dans l’équipe M2P2.\nLe but de ce stage était de modéliser un augmentorium, une structure dans les cultures où l’on met les fruits pourris, pour la lutte biologique.\nPour cela nous nous baserons sur des modèles de dynamique des populations.\nLe rapport se structure ainsi :\nEnfin, nous discuterons de l’efficacité théorique de l’augmentorium en conclusion.\nTous les articles utilisés sont ici."
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "Conclusion et perspectives",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "modelesansmigrationass.html",
    "href": "modelesansmigrationass.html",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelsimpleaug.html",
    "href": "modelsimpleaug.html",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom matplotlib import cm\nimport plotly.express as px"
  },
  {
    "objectID": "ref.html",
    "href": "ref.html",
    "title": "Références",
    "section": "",
    "text": "Voici la liste des références qui m’ont été utiles lors de mon travail :\n\nThéorie:\n\nMurray, J. D. 1989. Contiuous Population Models for Single Species & Continous Models for Interacting Populations. In Mathematical Biology. Vol. 19 1–35 & 63–94.\nCours/TP par L. Mailleret.\nCours de la faculté de Nice.\n\nModélisation:\n\nArditi, R., Lobry, C., Sari, T., 2015. Is dispersal always beneficial to carrying capacity ? New insights from the multi-patch logistic equation. Theor. Popul. Biol. 106, 45–59.\nArditi, R., Lobry, C., Sari, T., 2018. Asymmetric dispersal in the multi-patch logistic equation. Theor. Popul. Biol. 120, 11–15.\nDaozhou Gao, Yuan Lou, 2022, Total biomass of a single population in two-patch environments. Theor. Popul. Biol. 146, 1-14.\nFreedman, H.I., Waltman, P., 1977. Mathematical models of population interactions with dispersal.SIAM J. Appl. Math. 32 (3), 631–648.\n\nBiologie:\n\nDeguine JP, Atiama-Nurbel T, Quilici S, 2011. Net choice is key to the augmentorium technique of fruit fly sequestration and parasitoid release. Crop Protection 30 : 198-202.\nDeguine JP, Ferron P, 2006. Protection des cultures, préservation de la biodiversité, respect de l’environnement.Cahiers Agricultures 15 : 307-11.\nDeguine, J.-P., Atiama-Nurbel, T., Douraguia, E., & Rousse, P. (2011). L’augmentorium, un outil de protection agroécologique des cultures. Cahiers Agricultures 20: 261–265.\nKehrli, Patrik & Lehmann, M. & Bacher, Sven. (2004). Mass-hatching devices: a new biocontrol technique to augment parasitoids. Biol. Control. 32. 191-199.\nJang, E. & Klungness, Lester & McQuate, Grant. (2007). Extension Of The Use Of Augmentoria For Sanitation In A Cropping System Susceptible To the Alien Terphritid Fruit Flies (diptera: Terphritidae) In Hawaii.. J. of Appl. Sci. and Environ. Manage. Vol 11 Num 2. 11.\nKlungness, L.M., Jang, E.B., Ronald, F.L., Vargas, R.I., Sugano, J.S., Fujitani, E., 2005. New sanitation techniques for controlling tephritid fruit flies (Diptera: Tephritidae) in Hawaii. J. Appl. Sci. Environ. Manage. 9, 5e14.\n\n\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "modeleavecmigrationass.html",
    "href": "modeleavecmigrationass.html",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelcomplaug.html",
    "href": "modelcomplaug.html",
    "title": "Modèle complet avec proies structurées et prédateurs",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "modfinal.html",
    "href": "modfinal.html",
    "title": "Modèle proies-prédateurs structuré",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelesansmigrationass.html#définition-du-modèle",
    "href": "modelesansmigrationass.html#définition-du-modèle",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nOn pose le modèle suivant d’après Arditi (2015) : \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta(y-x)\\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta(x-y).\n\\end{array}\\right.\n\\tag{1}\navec :\n- x la population dans la première structure,\n- y la population dans la seconde structure,\n- r_x et r_y le taux de croissance dans les deux structures,\n- K_x et K_y les capacités de charge des deux structures,\n- \\beta la force de migration entre les structures.\nCe modèle est un modèle ressemblant peu à notre situation d’augmentorium car celui-ci est caractérisé par une migration assymétrique, il permet néanmoins de situer la démarche et les outils que nous allons utiliser pour étudier des modèles plus complexes."
  },
  {
    "objectID": "modelesansmigrationass.html#dynamique-du-modèle",
    "href": "modelesansmigrationass.html#dynamique-du-modèle",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Dynamique du modèle",
    "text": "Dynamique du modèle\nOn va tracer la dynamique de la population en fonction du temps pour se faire une première idée de comment se comporte la population.\nOn définit le modèle sous Python :\n\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b = param\n    x, y = etat\n    s = [ rx * x * ( 1 - x/Kx ) + b * ( y - x ), \n    ry * y * ( 1 - y/Ky ) + b * ( x - y )]\n    return s \n\nOn va utiliser odeint de Scipy afin de simuler une solution en fonction du temps. Il faut donc définir un temps d’intégration, des conditions initiales et les paramètres du modèle :\n\n## Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n## Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0 ,y0]\n\n## Paramètres: \nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\n\nparam_aug = np.array([rx, ry, Kx, Ky, b])\n\n## Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n\nMaintenant qu’on a la simulation on peut réprésenter la figure avec matplotlib :\n\nfig, ax = plt.subplots(1, 1, figsize = (7, 4 ))\n\nfig.suptitle('Dynamique des ravageurs dans le temps')\nax.plot(ti, s[:, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[:, 1], color = 'C0', label = 'augmentorium')\n\nax.grid() #on ajoute la grille\nax.legend() #on ajoute la légende\n\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n\n\n\n\nCette simulation nous montre une hausse de la population dans l’augmentorium et une baisse de la population dans la culture.\nLes deux populations atteignent un équilibre qui semble stable (il se maintient dans le temps).\nDans le cas d’un augmentorium, on voit que le simple fait de débarasser les fruits et de les mettre dans un espace séparé de la culture ammène à une baisse de la population de ravageurs dans la culture."
  },
  {
    "objectID": "modelesansmigrationass.html#plan-de-phase",
    "href": "modelesansmigrationass.html#plan-de-phase",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Plan de phase",
    "text": "Plan de phase\n\nEquilibres et stabilités\nNous allons tracer le plan de phase associé à ce système pour voir les équilibres et leurs stabilités.\nA l’équilibre on a par définition \\dot x = 0 et \\dot y =0 ce qui donne :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta(y^*-x^*) \\Leftrightarrow  y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right)\\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta(x^*-y^*) \\Leftrightarrow  x^*=r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\n\\end{array}\\right.\n\\tag{2}\navec x^* et y^* la valeur des équilibres.\nAinsi, les deux isoclines correspondent à des paraboles. Celles-ci se croisent trivialement en (0,0) et dans le quadrant positif en (x^*,y^*).\nPour calculer (x^*,y^*) on va utiliser l’expression de x^* trouvée en (2) qu’on va rentrer dans l’équation de y^* :\nComme x^* = r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right) on a :\n\ny^* = r_x\\left[r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\\right]\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)}{\\beta K_x}\\right)\n \n\\Leftrightarrow\n \ny^* = y^* - \\frac{r_yy^*}{\\beta} + \\frac{r_y{y^*}^2}{\\beta K_y} - \\frac{r_xy^*}{\\beta} + \\frac{r_xr_yy^*}{\\beta^2} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_y} + \\\\[.2cm]\n\\frac{r_x{y^*}^2}{\\beta K_x} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\\\[.2cm]\n\\frac{r_xr_y^2{y^*}^2}{\\beta^3 K_x} - \\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_x K_y} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\\\[.2cm]\n\\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_xK_y} + \\frac{r_xr_y^2{y^*}^4}{\\beta^3K_xK_y^2}\n \n\\Leftrightarrow\n \ny^*\\left(- \\frac{r_y}{\\beta} - \\frac{r_x}{\\beta} + \\frac{r_xr_y}{\\beta^2}\\right) + \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y} - \\frac{r_xr_y}{\\beta^2 K_y} + \\frac{r_x}{\\beta K_x} - 2\\frac{r_xr_y}{\\beta^2 K_x} + \\frac{r_xr_y^2}{\\beta^3 K_x} \\right) + \\\\[.2cm]\n2{y^*}^3\\left( \\frac{r_xr_y}{\\beta^2 K_xK_y} - \\frac{r_xr_y^2}{\\beta^3 K_xK_y} \\right) +\n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_xK_y^2} = 0\n\nCe qui donne après réarrangement : \ny^*\\left(\\frac{1}{\\beta}\\left[\\frac{r_xr_y}{\\beta} - r_y -r_x\\right]\\right)+ \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y}\\left[1-\\frac{r_x}{\\beta}\\right]+\\frac{r_x}{\\beta K_x}\\left[1-2\\frac{r_y}{\\beta}+\\frac{r_xr_y}{\\beta^2}\\right]\\right)+\\\\[.2cm]\n2{y^*}^3\\left(\\frac{r_xr_y}{\\beta^2 K_xK_y}\\left[1-\\frac{r_y}{\\beta}\\right]\\right) +\n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_y^2K_x} = 0\n\\tag{3}\nCe polynôme est résoluble via numpy pour obtenir y^*:\n\n## On défnit un monome y, un polynôme p et on prend ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol = y * (rx * ry * ((1/b) * ((1/b) - (1/rx) - (1/ry)) + 1/(rx * ry)) - 1) + \\\n(y**2) * ((rx*ry)/b) * ((1/Ky) * ((1/rx) - (1/b)) + (1/Kx) * ((1/ry) - (2/b) + (ry/(b**2)))) + \\\n2 * (y**3) * ((rx * ry)/((b**2) * Kx * Ky)) * (1 - (ry/b)) + \\\n(y**4) * ((rx * (ry**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution qu'on obtient avec un masque booléen qui sélectionne les racines réelles et strictement positives:\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() &gt; 0)]\nyeq=sol[0].real\n\nOn déduit x^* via sa définition par le système ( 2:\n\nxeq = (ry * yeq * ((1/ry) - (1/b) + (yeq/(b * Ky)))).real\n\nAvec la valeur des équilibres on va maintenant tracer le plan de phase :\n\nfig, ax = plt.subplots(1, 1)\nfig.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax.plot(xt,xt * (1/b) * (rx * ((xt/Kx) - 1) + b), \n                    color = 'C2', label = '$\\dot x=0$')\nax.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax.plot(xt * (1/b) * (ry * ((xt/Ky) - 1) + b), xt,\n                    color = 'C3', label = '$\\dot y=0$')\nax.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## On réduit la vue à ce qui nous intéresse:\nax.set_xlim(left = -.3, right = 3)\nax.set_ylim(top = 3, bottom = -.3)\n\n## On trace la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## On nomme les axes:\nax.set_xlabel('$x$', fontsize = '12') ;\nax.set_ylabel('$y$', fontsize = '12') ;\n\n## On plot les deux équilibres:\nax.plot(xeq.real, yeq.real, label = '$(x^*,y^*)$', marker = '.', markersize = 6, color = 'k')\nax.plot(0, 0, label = '$(0,0)$',\n                    marker = '.', markersize = 6, color = 'k')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax.quiver(X, Y, dx, dy, angles = 'xy', \n                    color = 'grey', scale = 80, width = 0.003);\n\n\n\n\nComme dit plus haut on a bien un croisement dans le quadrant positif qui correspond à l’équilibre (x^*,y^*).\nLes paraboles, en fonction des valeurs de leurs racines, peuvent croiser de différentes manières les axes des abssices et des ordonnées.\nLe plan de phase peut donc présenter plusieurs profils, autre que celui tracé ici. Néanmoins, le croisement des paraboles dans le quadrant positif (l’équilibre non nul) est toujours présent quelque soit le profil.\nEn faisant apparaître le champ de vecteur on peut déduire que l’équilibre en (0,0) est instable et l’équilibre en (x^*,y^*) est stable.\n\nStabilité mathématique des équilibres\nIl est clair que (0,0) est instable et (x^*,y^*) est stable (par le champ de vecteur).\nMathématiquement considérons la jacobienne de (1): \n\\mathbb{J}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy}{K_y}-\\beta\n\\end{pmatrix}\n\\tag{4}\net donc pour (0,0):\n\n\\mathbb{J_{\\vec{0}}}=\\begin{pmatrix}\n\\ r_x-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\beta\n\\end{pmatrix}\n\nLes valeurs propres \\lambda _1 et \\lambda _2 de cette matrice sont les solutions du polynôme caractéristique définit par : \n\\begin{vmatrix}\nr_x-\\beta-\\lambda & \\beta \\\\\n\\beta & r_y -\\beta -\\lambda \\\n\\end{vmatrix} = 0\n \n\\Leftrightarrow\n \n(r_x-\\beta-\\lambda)(r_y-\\beta - \\lambda) - \\beta^2 = 0\n \n\\Leftrightarrow\n \n\\lambda^2 + \\lambda\\left(2\\beta - r_x - r_y\\right) + r_xr_y - \\beta(r_x+r_y) = 0\n\nLe discriminant \\Lambda est donc définit par :\n\n\\Lambda = \\left(2\\beta - r_x - r_y\\right)^2 - 4(r_xr_y - \\beta[r_x+r_y]) \\\\\n= 4\\beta^2 -4\\beta(r_x +r_y) + r_x^2 +r_y^2 +2r_xr_y -4r_xr_y +4\\beta(r_x +r_y) \\\\ = 4\\beta^2 + (r_x-r_y)^2\n\nEt donc le spectre \\sigma de la jacobienne est :\n\n\\sigma_\\mathbb{J} = \\left(\\lambda_1 = \\frac{r_x+r_y-2\\beta-2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2},\\lambda_2=\\frac{r_x+r_y-2\\beta+2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2}\\right)\n\net on a ainsi,\n\n\\lambda_2 &gt; 0\n\nDonc (0,0) est bien instable.\nPour (x^*,y^*) on a : \n\\mathbb{J_{x^*,y^*}}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx^*}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy^*}{K_y}-\\beta\n\\end{pmatrix}\n\\tag{5}\nor, on a aussi d’après (2) :\n\n\\left\\{\\begin{array}{l}\n\\frac{y^*\\beta}{x^*} = \\beta - r_x + \\frac{r_xx^*}{K_x}   \\\\\n\\frac{x^*\\beta}{y^*} = \\beta - r_y + \\frac{r_yy^*}{K_y}  \n\\end{array}\\right.\n\nce qui simplifie la jacobienne en (x^*,y^*) à l’expression suivante :\n \\mathbb{J_{x^*,y^*}} = \\begin{pmatrix}\n\\ -\\frac{\\beta y^*}{x^*}-\\frac{r_xx^*}{K_x} & \\beta \\\\\n\\ \\beta & -\\frac{\\beta x^*}{y^*}-\\frac{r_yy^*}{K_y}\n\\end{pmatrix}\n\nIl est alors facile de vérifier que la trace de cette matrice est négative.\nLe déterminant quant à lui est donné par : \n\\alpha = \\left(\\frac{\\beta y^*}{x^*}+\\frac{r_xx^*}{K_x}\\right)\\left(\\frac{\\beta x^*}{y^*}+\\frac{r_yy^*}{K_y}\\right) - \\beta^2 \\\\\n= \\frac{\\beta r_y{y^*}^2}{x^*K_y} + \\frac{\\beta r_x {x^*}^2}{y^*K_x} + \\frac{r_xr_yx^*y^*}{K_xK_y} &gt; 0\n\nLe déterminant est lui positif, d’après la classification des portaits de plan de phase dans \\mathbb{R}^2 on a que (x^*,y^*) est stable.\n\n\n\nAnalyse du plan de phase\nOn remarque sur le plan de phase du système tracé précédemment que l’équilibre atteint n’est pas sur la droite x^*+y^*=K_x+K_y (en gris), on appellera cette droite d.\nSi le croisement des isoclines est au dessus de cette droite le système (1) subit une inflation et si le croisement est en dessous de cette droite il subit une déflation (voir contexte).\nOn voit que la structuration de l’espace, et les migrations qui en découle, perturbent les équilibres qui auraient dû être la somme des équilires des deux régions (la logistique tend vers la capacité maximale à l’équilibre).\nPlus généralement, on peut montrer qu’en cas de mixité parfaite entre les deux structures (\\beta \\to \\infty) on a d’après Arditi (2015):\n\nx^*+y^* = K_x + K_y + (K_x-K_y)\\frac{r_xK_y-r_yK_x}{r_xK_y+r_yK_x}\n\\tag{6}\nCe qui montre qu’en général on a pas x^*+y^* = K_x + K_x.\nDe plus par (6), si K_y&lt;K_x et si r_xK_y&lt;r_yK_x alors x^*+y^* &lt; K_x+K_y ce qui nous intéresse particulièrement pour la lutte biologique.\nEnsuite, en faisant \\dot x + \\dot y = 0, dans le cas de l’équilibre, on a: \nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+r_yy^*\\left(1-\\frac{y^*}{K_y}\\right) = 0\n\\tag{7}\nAutrement dit les points d’équilibres vivent sur une ellipse (si on ne modifie que \\beta ), qu’on va tracer avec contour :\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\n\nax.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left', fontsize = 8)\n\n## On place les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et on les relie aux axes:\nxc = np.arange(0, Kx, 0.01)\nax.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#On nomme les points:\nax.text(-0.2, Ky, '$K_y$')\nax.text(Kx, -0.2, '$K_x$')\n\n#On place les points d'équilibres :\nys = np.arange(0, yeq, 0.01)\nxs = np.arange(0, xeq, 0.01)\n\nax.plot(xeq * np.ones_like(ys), ys, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\nax.plot(xs, yeq * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax.text(-0.2, yeq, '$y^*$')\nax.text(xeq, -0.2, '$x^*$')\n\ndisplay(fig)\n\n\n\n\nLes conditions d’inflations et de déflations suivantes proviennent de l’article d’Arditi (2018).\n\na) Première condition à un système déflationiste\nOn remarque que le point (K_x,K_y) est en permanence sur la droite d qui coupe en permanence l’ellipse (en deux points) sauf pour une situation où d est tangente à l’ellipse.\nCe cas nous intéresse car il rend compte d’un système entièrement déflationiste. Représentons le sur le plan de phase :\nOn redéfinit les paramètres pour être dans le cas qui nous intéresse :\n\n## Paramètres: \nrxnew = 0.5\nrynew = 0.5\nKx = 2\nKy = 1\nb = 1\n\nEt on trace de la même manière que précédemment le plan de phase :\n\n\nCode\nfig2, ax2 = plt.subplots(1, 1)\nfig2.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax2.plot(xt,xt * (1/b) * (rxnew * ((xt/Kx) - 1) + b), color = 'C2', \n                label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax2.plot(xt * (1/b) * (rynew * ((xt/Ky) - 1) + b), xt, color = 'C3', \n                label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## On réduit la vue à ce qui nous intéresse:\nax2.set_xlim(left = -.3, right = 3)\nax2.set_ylim(top = 3, bottom = -.3)\n\n## On trace la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## On nomme les axes:\nax2.set_xlabel('$x$', fontsize = '12') ;\nax2.set_ylabel('$y$', fontsize = '12') ;\n\n## On recalcule les équilibres avec les nouveaux paramètres:\n## On défnit un monome y, un polynôme p et on prend ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol2 = y * (rxnew * rynew * ((1/b) * ((1/b) - (1/rxnew) - (1/rynew)) + 1/(rxnew * rynew)) - 1) + \\\n(y**2) * ((rxnew*rynew)/b) * ((1/Ky) * ((1/rxnew) - (1/b)) + (1/Kx) * ((1/rynew) - (2/b) + (rynew/(b**2)))) + \\\n2 * (y**3) * ((rxnew * rynew)/((b**2) * Kx * Ky)) * (1 - (rynew/b)) + \\\n(y**4) * ((rx * (rynew**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution qu'on obtient avec un masque booléen qui sélectionne les \n## racines réelles et strictement positives:\nsol2 = pol2.roots()[ (np.isreal( pol2.roots() )) * (pol2.roots() &gt; 0)]\nyeq2=sol2[0].real\n\n## On calcule x*\nxeq2 = (rynew * yeq2 * ((1/rynew) - (1/b) + (yeq2/(b * Ky)))).real\n\n## On plot les deux équilibres:\nax2.plot(xeq2.real, yeq2.real, label = '$(x^*,y^*)$', marker = '.', \n                markersize = 6, color = 'k')\nax2.plot(0, 0, label = '$(0,0)$', marker = '.', markersize = 6, \n                color = 'k')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', \n                scale = 80, width = 0.003) ;\n\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rxnew * X2 * (1 - X2/Kx)\nY = rynew * Y2 * (1 - Y2/Ky)\n\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left', fontsize = 8)\n\n## On place les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax2.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et on les relie aux axes:\nxc = np.arange(0, Kx, 0.01)\nax2.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax2.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#On nomme les points:\nax2.text(-0.2, Ky, '$K_y$')\nax2.text(Kx, -0.2, '$K_x$')\n\n#On place les points d'équilibres :\nys = np.arange(0, yeq2, 0.01)\nxs = np.arange(0, xeq2, 0.01)\n\nax2.plot(xeq2 * np.ones_like(ys), ys, linestyle = 'dashed',\n                color = 'k', linewidth = 0.5)\nax2.plot(xs, yeq2 * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax2.text(-0.2, yeq2, '$y^*$');\nax2.text(xeq2, -0.2, '$x^*$');\n\n\n\n\n\nL’ellipse, d’équation f(x,y)=r_xx\\left(1-\\frac{x}{K_x}\\right)+r_yy\\left(1-\\frac{y}{K_y}\\right) = 0 , peut être vue comme la ligne de niveau de f en 0.\nAinsi, une équation de la tangente au point (x_0,y_0) est donnée par:\n\n\\frac{\\partial f}{\\partial x}(x_0,y_0)(x-x_0)+ \\frac{\\partial f}{\\partial y}(x_0,y_0)(y-y_0) = 0\n\\tag{8}\nautrement dit : \n\\left(r_x - 2\\frac{r_xx_0}{K_x}\\right)(x-x_0) + \\left(r_y -2\\frac{r_yy_0}{K_y}\\right)(y-y_0) = 0\n\nDans le cas où x_0=K_x et y_0=K_y on a alors : \n-r_x(x-K_x) -r_y(y-K_y) = 0\n \n\\Leftrightarrow\n \ny = -\\frac{r_x}{r_y}\\left(x-K_x\\right) + K_y\n\\tag{9}\nqui est donc l’équation de la tangente à l’ellipse au point (K_x,K_y).\nSi maintenant on prend r_x=r_y alors on remarque que (9) est égale à l’équation de la droite d ce qui implique que toute l’ellipse est en dessous de d et donc que tous les équilibres sont déflationistes.\nDonc : si r_x=r_y on a (1) qui est déflationiste quelque soit le taux de migration.\nOn va effectuer une simulation avec les paramètres déduits à l’instant pour confirmer ce qu’on vient de dire.\nPour cela on va, pour chaque \\beta, simuler un temps suffisament large pour atteindre l’équilibre et représenter la somme des deux équilibres.\nIl faut donc définir une fonction qui prend en compte le changement de \\beta :\n\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n\nAinsi qu’un temps d’intégration large, des conditions initiales et des paramètres :\n\n## Temps d'intégration :\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \nrx1 = 0.5\nry1 = 0.5 # =on prend rx1=rx2\nKx1 = 2\nKy1 = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Condition initiale:\nc10 = [2, 0]\n\nEt enfin on simule avec odeint et on fait une boucle pour simuler que \\beta va de 0 à 4 (suffisant pour avoir une courbe intéressante):\n\n## On crée la figure et l'axe:\nfig3, ax3 = plt.subplots(1, 1)\nfig3.suptitle(\"Somme des équilibres en fonction de β quand $r_x = r_y$\")\n\n## Boucle ou i prend les valeurs de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param1, i)) #On calcule pour chaque beta l'équilibre\n    ax3.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\nxt = np.arange(0, 4, 0.01)\n\nax3.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax3.text(3.2, Kx + Ky + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax3.set_xlabel('β')\nax3.set_ylabel('Population')\nax3.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\n\n## On adapte la fenêtre:\nax3.set_ylim(2.2, 3.2)\n\nax3.legend();\n\n\n\n\nOn voit que la courbe bleu représentant la somme des équilibres est en permanence en dessous de la droite K_x+K_y. On a bien un système entièrement déflationiste quand r_x = r_y.\n\n\nb) Deuxième condition à un système déflationiste\nOn va maintenant considérer le cas où r_x &lt; r_y c’est à dire qu’on va prendre l’ellipse dans un seul sens (voir sur l’animation Geogebra).\nOn va analyser graphiquement le plan de phase. On aura besoin de tracer les droites définies par \\beta = 0 et \\beta = +\\infty dans l’équation y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right) (la parabole verte dans le plan de phase définie par \\dot x =0).\nEn effet, ceci va permettre d’encadrer l’équilibre (x^*,y^*) en fonction du taux de migration.\nLorsque \\beta = 0 on a, par la première équation de (2) : \n0 = r_xx^*(1-\\frac{x^*}{K_x})\n \n\\Leftrightarrow\n \nx^*=K_x \\vee x^* = 0\n\nDonc lorsque le taux de migration est nul la parabole correspondant à \\dot x = 0 a pour équation les droites x^*=0 et x^*=K_x qu’on appelle respectivement P_{10} et P_{20}.\nLorsque \\beta = + \\infty on a, encore une fois par la première équation de (2):\n\ny^* = r_xx^*\\frac{1}{r_x} = x^*\n\nAinsi quand le taux de migration tend vers l’infini la parabole \\dot x = 0 correspond à la droite y^*=x^* qu’on appelle P_\\infty.\nOn notera dans la suite A=(K_x,K_y), B l’intersection non trivial (pas (0,0)) entre P_\\infty et l’ellipse et C l’intersection non trivial (pas (K_x,0)) entre P_{20} et P_\\infty.\nPour calculer les coordonées de B on utilise que y^*=x^* et on le rentre dans (7) ce qui donne : \nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right)+r_y\\left(1-\\frac{x^*}{K_y}\\right)\\right) = 0\n \n\\Leftrightarrow\n \nx^* = \\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}}\n\net comme B est sur P_\\infty alors on a : \ny^*= \\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}}\n B est donc définie comme :\n\nB = (\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}},\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}})\n\nPour calculer les coordonées de C on utilise que y^*=x^* dans la définition de P_{20}, ie comme P_{20} est défini par x^* =K_x alors y^*=K_x et donc on a : \nC=(K_x,K_x)\n\nReprésentons le tout sur le premier plan de phase:\n\n## Parabole xdot=0 b=0:\nax.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole b=0')\nax.plot(np.zeros_like(xt), xt, color = 'C9')\n\n## Parabole xdot=0 b=+inf:\nax.plot(xt, xt, color = 'C6', label = 'Parabole b=$+\\infty$')\n\n## On place des textes indiquant les trois droites:\nax.text(0.05, yeq + 0.4, \"$P_{10}$\")\nax.text(Kx + 0.05, 2.8, \"$P_{20}$\")\nax.text(2.65, 2.45, \"$P_\\infty$\")\n\n## On place les trois points:\n## A :\nax.plot(Kx, Ky, marker = '.',color = 'C0', markersize = 7)\nax.text(Kx + 0.1, Ky + 0.1, \"$A$\")\n\n## B :\nax.plot((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky), \n            marker = '.', color = 'C0', markersize = 7)\n\nax.text((rx + ry)/(rx/Kx + ry/Ky) - 0.1, (rx + ry)/(rx/Kx + ry/Ky) + 0.1, \"$B$\")\n\n## C : \nax.plot(Kx, Kx, marker = '.', color = 'C0', markersize = 7)\nax.text(Kx - 0.1, Kx + 0.1, \"$C$\")\n\nax.legend(loc = \"upper left\", fontsize = 6.5)\n\ndisplay(fig)\n\n\n\n\nFigure 1: Plan de phase complet\n\n\n\n\nLorsque \\beta augmente de 0 à +\\infty on a l’équilibre qui parcourt l’ellipse de A à B.\nPour que le système soit déflationiste on veut que la portion de l’ellipse de A à B soit complètement en dessous de la droite d (grise).\nPour ce faire on peut voir sur notre plan de phase qu’il faut que C ait une coordonée y plus grande que A afin que B soit toujours à gauche de A (et donc en dessous de d).\nMathématiquement on veut donc que K_x &gt; K_y.\nAinsi si on a r_x &lt; r_y et K_x&gt;K_y on aura tout le temps un modèle déflationiste pour les ravageurs.\nCeci est intéressant pour l’augmentorium, si on a la capacité de charge l’augmentorium qui est plus faible que celle de la culture alors le système est toujours négatif pour la population totale de ravageurs.\nOn peut aussi voir graphiquement que dans ce cas là on a toujours x^* &lt; K_x, c’est ce que l’on cherche à obtenir.\nOn peut illustrer notre condition avec une simulation similaire à la partie précédente :\nOn utilise le même modèle, on change uniquement les paramètres :\n\n## Paramètres : \nrx2 = 0.5\nry2 = 1  #On a bien rx2 &lt; ry2 \nKx2 = 2\nKy2 = 1  #On a bien Kx2&gt;Ky2\n\n## En l'occurence il s'agit des paramètres de base qu'on avait utilisé ##pour la simulation du premier plan de phase expliquant qu'on se ##retrouvait avec un équilibre déflationiste.\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n\nEt on simule à nouveau :\n\n\nCode\n## On crée la figure et l'axe:\n\nfig4, ax4 = plt.subplots(1, 1)\nfig4.suptitle(\"Somme des équilibre en fonction de β quand $r_x &lt; r_y$ et $K_x &gt; K_y$\")\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param2, i)) #On calcule pour chaque beta l'équilibre\n    ax4.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax4.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax4.text(3.2, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax4.set_xlabel('β')\nax4.set_ylabel('Population')\nax4.plot(Kx2+Ky2, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\n\n## On adapte la fenêtre:\nax4.set_ylim(2.2, 3.2)\n\nax4.legend();\n\n\n\n\n\nOn observe qu’on a bien une déflation du système quelque soit le taux de migration.\n\n\nc) Conditions pour une inflation et/ou une déflation\nSur la base de la Figure 1 on peut aussi déduire quand est-ce qu’on peut avoir inflation selon les paramètres.\nIl s’agit de la même idée de preuve graphique qu’avant mais en complexifiant un peu. Pour cela on va avoir besoin d’un quatrième point qu’on appellera D et qui correspond à l’autre intersection entre l’ellipse et la droite d (pas (K_x,K_y)).\nPour trouver les coordonnées de D on a simplement que comme D est sur d alors on a y^* = -x^* + K_x + K_y et on remplace y^* dans (7) ce qui donne : \nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right) +r_y(-x^*+K_x+K_y)\\left(1-\\frac{-x^*+K_x+K_y}{K_y} \\right) = 0\n \n\\Leftrightarrow\n \nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{r_yK_x}{K_y}\\left(1-\\frac{x^*}{K_x} \\right) \\right) + \\frac{r_y(K_x+K_y)}{K_y}(x^*-K_x) = 0\n \n\\Leftrightarrow\n \n\\left(1-\\frac{x^*}{K_x}\\right)\\left(x^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right]-\\frac{r_yK_x(K_x+K_y)}{K_y}\\right) = 0\n\nCe qui donne soit x^* = K_x et on retouve alors A, soit :\n\nx^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right] = \\frac{r_yK_x(K_x+K_y)}{K_y}\n \n\\Leftrightarrow\n \nx^* = \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n\nEt donc d’après la définition de y^* : \ny^* = - \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} + K_x + K_y\n \n\\Leftrightarrow\n \ny^* = \\frac{(K_x+K_y)(r_xK_y+r_yK_x)-r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n \n\\Leftrightarrow\n \ny^*=\\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x}\n\nAinsi, D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} ) .\nAjoutons D au plan de phase :\n\n## On ajoute D:\nax.plot((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx), \n        (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx),\n        color = 'C0', marker = '.', markersize = 7)\n\nax.text((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx) + 0.07, \n        0.08 + (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx), \"$D$\")\n\ndisplay(fig)\n\n\n\n\nOn voit maintenant aisément que si B est entre A et D alors les équilibres vont parcourir des valeurs inflationistes seulement (arc orange au dessus de la droite grise).\nSi B est en dessous de D (la coordonnée y de B est plus petite que celle de D) alors on a d’abord des équilibres inflationistes (de A à D) puis déflationistes (de D à B).\nMathématiquement on a donc :\nSi K_y &gt; K_x (la coordonnée y de B est plus grande que celle de A) et K_xr_y &gt; K_yr_x (la coordonnée y de B est plus grande que celle de D) alors le système est toujours inflationiste.\nSi K_xr_y &lt; K_yr_x (la coordonnée y de B est plus petite que celle de D) alors le système est d’abord inflationiste puis déflationiste.\nOn peut vérifier ces deux assertions avec des simulations similaires à la partie précédente :\nOn utilise le même modèle, on change uniquement les paramètres :\n\n## Paramètres condition 1: \nrx3 = 0.4\nry3 = 1  #On a bien rx3 &lt; ry3 \nKx3 = 1\nKy3 = 2  #On a bien Ky3&gt;Kx3\n\n#On a la première condition de Kxry &gt; Kyrx\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres condition 2: \nrx4 = 0.6\nry4 = 1  #On a bien rx4 &lt; ry4 \nKx4 = 1  \nKy4 = 2  \n\n#On a la deuxième condition de Kxry &gt; Kyrx\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n\nEt on simule à nouveau :\n\n\nCode\n## On crée la figure et l'axe:\n\nfig5, (ax5, ax6) = plt.subplots(1, 2, figsize = (7, 5))\nax5.set_title(\"Somme des équilibre en fonction de β quand $r_x &lt; r_y$ et $K_y &gt; K_x$ et $K_xr_y &gt; K_yr_x$\", fontsize = 6)\nax6.set_title(\"Somme des équilibre en fonction de β quand $r_x &lt; r_y$ et $K_xr_y &lt; K_yr_x$\", fontsize = 6)\n\nplt.subplots_adjust(wspace = 0.4) #On ajuste l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param3, i)) #On calcule pour chaque beta l'équilibre\n    ax5.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, c10, t1, args = (param4, i))\n    ax6.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt=np.arange(0, 4, 0.01)\n\nax5.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax5.text(3.2, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\nax6.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax6.text(3.2, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax5.set_xlabel('β')\nax5.set_ylabel('Population')\nax5.plot(Kx3 + Ky3, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\nax6.set_xlabel('β')\nax6.plot(Kx4 + Ky4, 0, color = 'C0', label = 'Somme des équilibres')\n\n## On adapte la fenêtre:\nax5.set_ylim(2.9, 3.2)\nax6.set_ylim(2.9, 3.1)\n\nax5.legend();\nax6.legend();\n\n\n\n\n\nOn observe qu’on a bien dans la partie gauche tout le temps inflation et dans la partie droite d’abord inflation puis déflation."
  },
  {
    "objectID": "modelesansmigrationass.html#animation",
    "href": "modelesansmigrationass.html#animation",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Animation",
    "text": "Animation\nPour mieux comprendre comment se déplace le système en fonction des paramètres :\n\n#Technique pour utiliser une fenêtre geogebra:\n\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/ajaycvqe\" style = \"overflow: hidden;border: 1px solid black\"  scroll = \"no\" &gt;&lt;/iframe&gt;\n\"\"\"\n\ndisplay.HTML(fig01)"
  },
  {
    "objectID": "modeleavecmigrationass.html#définition-du-modèle",
    "href": "modeleavecmigrationass.html#définition-du-modèle",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nLe but d’un augmentorium est de confiner les ravageurs dans un espace clos qui ne laisse pas (ou peu) s’échapper ceux-ci.\nAinsi, il s’établit une migration assymétrique entre les deux structures qu’on peut modéliser en établissant le modèle suivant d’après Arditi (2018) :\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{1}\navec :\n- x la population de ravageurs dans la culture,\n- y la population de ravageurs dans l’augmentorium,\n- r_x et r_y le taux de croissance dans la culture et dans l’augmentorium,\n- K_x et K_y les capacités de charges de la culture de de l’augmentorium,\n- \\beta la force de migration entre les structures,\n- \\gamma_x et \\gamma_y caractérisant l’assymétrie de migration.\n\nNouvelles hypothèses propres à l’augmentorium\nCe modèle est plus proche de celui d’un augmentorium.\nComme les ravageurs se reproduisent mieux dans l’augmentorium que dans la culture on peut dire que r_x&lt;r_y.\nOn peut aussi dire que le taux de fuite des ravageurs (\\frac{1}{\\gamma_y}) se doit d’être beaucoup plus petit que le taux de migration (\\frac{1}{\\gamma_x}).\nOn a donc \\gamma_x &lt;&lt; \\gamma_y."
  },
  {
    "objectID": "modeleavecmigrationass.html#dynamique-du-modèle",
    "href": "modeleavecmigrationass.html#dynamique-du-modèle",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Dynamique du modèle",
    "text": "Dynamique du modèle\nEncore une fois on simule la dynamique des deux populations en fonction du temps en codant comme dans la première partie\nOn définit le système sous Python:\n\n\nCode\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b, gx, gy = param\n    x, y = etat\n    s=[rx * x * (1 - x/Kx) + b * (y/gy - x/gx),\n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s\n\n\nEt on définit les paramètres, le temps d’intégration etc. :\n\n\nCode\n# Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n# Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0, y0]\n\n# Paramètres: \n\nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\ngx = 0.5\ngy = 3\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n\n\nOn trace la figure :\n\n\nCode\nfig,ax = plt.subplots(1, 1)\nfig.suptitle('Dynamique des ravageurs dans le temps avec augmentorium')\n\nax.plot(ti, s[ :, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[ :, 1], color = 'C0', label = 'augmentorium')\n\n# Ajout d'élements:\nax.grid()\nax.legend()\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n\n\n\n\n\nCette dynamique, comme en première partie, présente un équilibre de maintien de la population.\nNéanmoins on observe que, pour les mêmes paramètres que dans la première partie, la population dans la culture est bien plus faible.\nLa migration assymétrique vers l’augmentorium semble être bénéfique à la culture."
  },
  {
    "objectID": "modeleavecmigrationass.html#plan-de-phase",
    "href": "modeleavecmigrationass.html#plan-de-phase",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Plan de phase",
    "text": "Plan de phase\n\nEquilibres et leur stabilité\nA l’équilibre on a le système suivant :\n\n\\left\\{\\begin{array}{l}\n\\dot x = 0 \\Leftrightarrow 0 = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = 0 \\Leftrightarrow 0 = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{2} \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\ny^*=\\gamma_y\\left(\\frac{x}{\\gamma_x}-\\frac{r_xx}{\\beta}\\left(1-\\frac{x}{K_x}\\right)\\right)\\\\\nx^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)\n\\end{array}\\right.\n\\tag{3}\nOn voit tout de suite qu’on a deux paraboles qui se croisent en (0,0) et en (x^*,y^*).\nOn va donc avoir deux équilibres, ceux-ci vivent sur une ellipse de même équation qu’en première partie.\nEn fonction des racines des paraboles on va avoir des plans de phases différents qu’on va tracer via les mêmes techniques qu’en première partie :\n\n\nCode\n#On crée la figure avec les 3 sous figures:\nfig2, (ax2, ax3, ax4) = plt.subplots(1, 3, figsize = (9, 4))\n\nfig2.suptitle('Plan de phase de la population')\nax2.set_title('β=1')\nax3.set_title('β=10')\nax4.set_title('β=0.1')\n\n#Plan de phase 1:#\n# Paramètres: \nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\nb1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam_aug1 = np.array([rx1, ry1, Kx1, Ky1, b1, gx1, gy1])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy1 * (xt/gx1 - rx1 * xt/b1 * (1 - xt/Kx1)), color = 'C2', label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax2.plot(gx1 * (yt/gy1 - ry1 * yt/b1 * (1 - yt/Ky1)), yt, color = 'C3', label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax2.set_xlim(left = -0.03, right = 0.5)\nax2.set_ylim(top = 1.5, bottom = -0.06)\n\nax2.set_xlabel('Ravageur dans la culture', fontsize = '12');\nax2.set_ylabel('Ravageur dans l\\'augmentorium', fontsize = '12');\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\nX, Y = np.meshgrid(xg, yg)\n\n#On utilise quiver:\ndx, dy = aug([X, Y], 0, param_aug1)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 15, width = 0.0035);\n\n#Plan de phase 2:#\n#Paramètres: \nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\nb2 = 10\ngx2 = 0.5\ngy2 = 3\n\nparam_aug2 = np.array([rx2, ry2, Kx2, Ky2, b2, gx2, gy2])  \n\n#Isocline nulles:\n#xdot = 0\nax3.plot(xt, gy2 * (xt/gx2 - rx2 * xt/b2 * (1 - xt/Kx2)), color = 'C2', label = '$\\dot x=0$')\nax3.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax3.plot(gx2 * (yt/gy2 - ry2 * yt/b2 * (1 - yt/Ky2)), yt, color = 'C3', label = '$\\dot y=0$')\nax3.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax3.set_xlim(left = -0.02, right = 0.35)\nax3.set_ylim(top = 1.4, bottom = -0.06)\n\nax3.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\n\nX, Y = np.meshgrid(xg, yg)\n\n#On utilise quiver:\ndx, dy = aug([X, Y], 0, param_aug2)\nax3.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 40, width = 0.003);\n\n#Plan de phase 3:\n#Paramètres: \nrx3 = 0.5\nry3 = 1\nKx3 = 2\nKy3 = 1\nb3 = 0.1\ngx3 = 0.5\ngy3 = 3\n\nparam_aug3=np.array([rx3, ry3, Kx3, Ky3, b3, gx3, gy3])\n\n#Isocline nulles:\n#xdot = 0 \nax4.plot(xt, gy3 * (xt/gx3 - rx3 * xt/b3 * (1 - xt/Kx3)), color = 'C2', label = '$\\dot x=0$')\nax4.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0 \nax4.plot(gx3 * (yt/gy3 - ry3 * yt/b3 * (1 - yt/Ky3)), yt, color = 'C3', label = '$\\dot y=0$')\nax4.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration:\nax4.set_xlim(left = -0.08, right = 1.9)\nax4.set_ylim(top=1.5, bottom = -0.06)\n\nax4.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n# Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.18)\nyg = np.arange(-0.5, 3, 0.18)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug3)\nax4.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 10, width = 0.0035);\n\n#On légende:\nax4.legend();\n\n\n\n\n\nEn fonction des valeurs de \\beta on observe des profils différents de plan de phase. Pour mieux le visualiser on pourra utiliser l’animation Geogebra mise à disposition à la fin de l’analyse.\nD’après le champ de vecteurs on voit clairement que l’équilibre en (0,0) est instable et l’équilibre (x^*,y^*) est stable.\nPour calculer l’équilibre on procède de la même manière que dans la première partie, c’est à dire en croisant les deux paraboles $ $ et \\dot y =0 : On a x^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right).\nDonc : \\small\ny^*=\\gamma_y\\left(\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\gamma_x}-\\frac{r_x\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\beta}\\left[1-\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{K_x}\\right]\\right)\n \n\\Leftrightarrow\n \n-\\frac{r_y\\gamma_yy^*}{\\beta} + \\frac{r_y \\gamma_y {y^*}^2}{\\beta K_y} - \\frac{r_x\\gamma_xy^*}{\\beta} + \\frac{r_xr_y\\gamma_x \\gamma_y y^*}{\\beta^2} \\\\\n- \\frac{r_xr_y\\gamma_x\\gamma_y{y^*}^2}{\\beta^2K_y} + \\frac{r_x\\gamma_x^2{y^*}^2}{\\beta K_x\\gamma_y} - \\frac{r_xr_y\\gamma_x^2{y^*}^2}{\\beta^2K_x} \\\\\n+ 2\\frac{r_xr_y\\gamma_x^2{y^*}^3}{\\beta^2K_xK_y} + \\frac{r_xr_y^2\\gamma_x^2 \\gamma_y {y^*}^2}{\\beta^3K_x} - 2\\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^3}{\\beta^3K_xK_y} \\\\\n+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^4}{\\beta^3K_xK_y^2}\n\nCe qui donne, en mettant les monomes y^* en facteur et en simplifiant ensuite par \\frac{y^*}{\\beta} :\n\n\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta}-\\gamma_yr_y-\\gamma_xr_x +\\\\ y\\left[\\frac{r_y\\gamma_y}{K_y}-\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta K_y}+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y}{\\beta^2K_x}+\\frac{r_x\\gamma_x^2}{\\gamma_yK_x}-\\frac{2r_xr_y\\gamma_x^2}{\\beta K_x}   \\right] +\\\\[.2cm]\n\\frac{2r_yr_x\\gamma_x^2y^2}{\\beta K_xK_y}\\left(1-\\frac{r_y\\gamma_y}{\\beta}\\right) + \\frac{r_xr_y^2\\gamma_x^2\\gamma_yy^3}{\\beta^2K_xK_y^2} = 0\n\\tag{4}\nCe polynôme est résoluble par numpy similairement à la première partie :\n\n\nCode\n# Paramètres pour calculer le polynôme\nrx = 0.5\nry = 1\nKx = 2.5\nKy = 2\nb = 1\ngx = 1.5\ngy = 3\n\n#Points d'équilibres, utilisation de numpy : monome, polynome et racines:\n#Calcul:\n#Monome y\nx = np.polynomial.Polynomial([0, 1])\n\n#Polynome :\npol = -gy * ry - gx * rx + (rx * ry * gx * gy)/b + x * ((ry * gy)/(Ky) - (ry * rx * gy * gx)/(b * Ky) + \\\n rx * ry**2 * gx**2 * gy/(b**2 * Kx) + rx * gx**2/(gy * Kx) - 2 * rx * ry * gx**2/(b * Kx)) + \\\n (x**2) * 2 * (ry * rx *gx**2)/(b * Kx * Ky) * (1 - ry * gy/b) + (x**3) * gy * rx * ((ry * gx)**2)/(b**2 * Kx * Ky**2)\n\n#Solution\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() &gt; 0)]\nyeq = sol[0].real\n\n#Calcul de x avec sa définition:\nxeq = gx * (yeq/gy - ry * yeq/b * (1 - yeq/Ky))\n\n\n\n\nAnalyse du plan de phase\nOn va tracer le plan de phase complet et l’analyser d’après la méthode de Arditi (2018) :\nDans cette analyse on va considérer, sans perte de généralité, que r_x &lt; r_y (on prend l’ellipse dans un seul sens, voir l’animation).\nPour cela on trace l’ellipse de la même manière que dans la première figure, l’équation de cette ellipse n’ayant pas de terme de migration dans le premier modèle elle est la même dans celui-ci aussi.\nEnsuite on va tracer la droite d correspondant à K_x+K_y=x^*+y^* car ceci va permettre de voir si le système subit une inflation ou une déflation.\nEnfin, similairement à la partie prédédente on va tracer les droites données par \\beta = 0 et \\beta = +\\infty dans la parabole définie par \\dot x =0 (parabole verte sur le plan de phase).\nLes droites sont différentes du modèle précédent donc on va les recalculer :\nLorsque \\beta = 0 on a exactement les mêmes deux droites que dans le modèle précédent en x^* =0 et en x^*=K_x car le fait que le nouveau modèle ajoute de l’assymétrie dans les migrations est effacé par une migration nulle. On les appelle respectivement P_{10} et P_{20}.\nLorsque \\beta = +\\infty on a d’après (3) : \ny^* = \\frac{\\gamma_y}{\\gamma_x}x^*\n\nOn appellera cette droite P_{\\infty}.\nIntroduisons les mêmes points que précédemment c’est à dire :\n\nA, l’intersection entre P_{20} et l’ellipse, c’est à dire la valeur de l’équilibre quand \\beta = 0.\nB, l’intersection entre P_{\\infty} et l’ellipse, c’est à dire la valeur de l’équilibre quand \\beta = +\\infty.\nC, l’intersection entre P_{20} et P_{\\infty}.\nD, l’intersection entre la droite d et l’ellipse qui n’est pas A.\n\nReprésentons le plan de phase avec ces éléments :\n\n\nCode\n#On crée la figure:\nfig2, ax2 = plt.subplots(1, 1, figsize = (8, 5))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase:\n# Paramètres égaux à ceux utilisés pour calculer les équilibres:\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy * (xt/gx - rx * xt/b * (1 - xt/Kx)), color = 'C2', label = '$\\dot x = 0$')\n\n#ydot = 0\nax2.plot(gx * (yt/gy - ry * yt/b * (1 - yt/Ky)), yt, color = 'C3', label = '$\\dot y = 0$')\n\n#Cadrage:\nax2.set_xlim(left = -0.30, right = 4.5)\nax2.set_ylim(top = 6, bottom = -0.70)\n\nax2.set_xlabel('$x^*$', fontsize = '12')\nax2.set_ylabel('$y^*$', fontsize = '12')\n\n#Axe x et y:\nax2.plot(xt, np.zeros_like(xt), color = 'k', linestyle = 'dashed')\nax2.plot(np.zeros_like(yt), yt, color = 'k', linestyle = 'dashed')\n\n#Droite capacité:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = \"0.8\")\n\n#Plot des équilibres:\nax2.plot(xeq, yeq, label = 'Equilibre stable', marker = '.', markersize = 12)\nax2.plot(0, 0, label = 'Equilibre Instable', marker = '.', markersize = 12, color = 'C5')\n\n#Ellipse:\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole β = 0')\nax2.plot(np.zeros_like(xt), xt, color = 'C9')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt, xt * gy/gx, color = 'C6', label = 'Parabole β = $+\\infty$')\n\n#A:\nax2.plot(Kx, Ky, color = 'black', marker = '.')\nax2.text(Kx - 0.1, Ky - 0.1, '$A$')\n\n#C:\nax2.plot(Kx, gy * Kx/gx, color = 'black', marker = '.')\nax2.text(Kx, gy * Kx/gx - 0.1, 'C')\n\n#B:\nax2.plot(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky),((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) \\\n                                        , color = 'black', marker = '.')\n\nax2.text(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) - 0.1, ((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) + 0.1 \\\n                                        , '$B$')\n\n#D:\nax2.plot(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx), rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx), color = 'black', marker = '.')\nax2.text(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, '$D$')\n\n#Légende:\nax2.legend();\n\n\n\n\n\n\na) Première condition de déflation\nLa première condition d’inflation est exactement la même que dans le modèle précédent et la preuve est en tout point égale (elle repose sur une analyse de l’équation de l’ellipse qui est la même dans les deux modèles). On ne détaillera pas ici cette preuve mais on sait donc que :\nSi r_x = r_y alors le système est tout le temps déflationiste.\n\n\nb) Deuxième condition de déflation\nNous allons faire une preuve graphique de cette condition similaire à l’ancien modèle.\nL’équilibre vit sur l’ellipse et parcourt l’arc orange entre A et B au fur et à mesure que \\beta augmente.\nAinsi pour avoir déflation on va vouloir avoir cet arc entièrement sous la droite d en gris.\nIl est alors facile de voir que pour cela on veut que la coordonnée en y de C soit plus grande que celle de A (C est plus haut sur la droite cyan que A), entraînant que la coordonnée en x de B est plus petite que celle de A (B se trouve plus à gauche sur l’ellipse que A).\nPour cela on a besoin de connaître les coordonnées de A et C.\n\nSi on note A l’intersection entre la parabole en 0 et l’ellipse et B l’intersection entre la parabole en 0 et en +\\infty alors pour que x^* &lt; K_x (ce que l’on veut) il faut que la coordonnée en y de B soit supérieur à celle de A.\nLe point A est défini par : A=(K_x,K_y)\nLe point B est défini par : B=\\left(K_x,\\frac{\\gamma_yK_x}{\\gamma_x}\\right)\n\nAutrement dit, si \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} alors on a toujours l’augmentorium qui est efficace, ie le système est déflationiste quelque soit le taux de migration \\beta.\n\n\nSi on note C l’intersection entre l’ellipse et la parabole en +\\infty on a alors la valeur de l’équilibre en \\beta =+\\infty.\nLe point C est défini par : C=\\left(\\frac{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)r_x + r_y}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} , \\frac{\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)r_y + r_x}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} \\right)\nMaintenant notons D la valeur de l’intersection entre le droite des capacités et l’ellipse.\nLe point D est défini par : D=\\left(\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xKy+r_yK_x}\\right)\nAinsi, quand \\beta augmente le point d’équilibre se déplace entre A et C. On voit donc que l’équilibre peut soit être tout le temps déflationiste si C est avant A (point précédent) sur l’ellipse soit être constamment inflationiste si C est entre A et D soit être les deux si C est après D.\nVoyons ceci en terme de coefficient de droite, on a alors les exactes mêmes conditions mais sur les pentes des droites passant par ces points, qu’on peut calculer. On a déja par le premier point la condition sur les paramètres pour avoir le système déflationiste.\n\nSi \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x} alors on a des équilibres à la fois inflationiste et déflationiste. En effet ceci traduit que C est après D, graphiquement on voit que l’équilibre est au début au dessus de la droite cyan et à la fin en dessous (après avoir passé D).\nSi \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} alors les équilibres sont constamment inflationiste.\n\n\nEnfin on observe que si la droite cyan est tangente à l’ellipse alors on a que le système est constamment déflationiste. Ceci correspond au même calcul que dans la première partie et on trouve que si r_x=r_y le système est tout le temps déflationiste pour tout \\beta.\n\n\nMaintenant si on prend r_x&gt;r_y on a un autre cas qui apparaît d’après Daozhou Gao (2022) En effet, et on le voit bien sur l’animation, on peut alors avoir C entre D et A avec C plus haut que A et ainsi on peut avoir un cas où le système est complètement inflationiste avec des valeurs de la somme des équilibres plus grands que C. Cette situation ne nous intéresse que peu car ce n’est pas un cas qui est biologiquement réaliste.\n\nPreuves:\n\nPoint B:\nLa première coordonnée est forcément K_x car on considère le croisement avec la parabole en \\beta = 0.\nOn sait que la parabole en \\beta = +\\infty est définie par y = \\frac{\\gamma_y}{\\gamma_x}x.\nOn a le résultat pour x=K_x.\nPoint C:\nLa parabole en \\beta = +\\infty est définie par y = \\frac{\\gamma_y}{\\gamma_x}x et l’ellipse par r_xx\\left(1-\\frac{x} {K_x}\\right) + r_yy\\left(1-\\frac{y}{K_y}\\right) = 0. Il suffit de remplacer dans l’expression de l’ellipse la valeur de y donnée par la parabole pour trouver la première coordonnée.\nPour trouver la deuxième on utilise l’expression de la parabole.\nPoint D: On fait la même que précédemment. La droite des capacités est définie par y= -x +K_x+K_y qu’on remplace dans l’expression de l’ellipse pour trouver la première coordonnée (après simplification). La deuxième est déduite de la la première grâce à l’expression de la droite.\n\nPour les conditions sur les équilibres on se rappelle que la pente de la parabole en \\beta = +\\infty est définie par \\frac{\\gamma_y}{\\gamma_x}.\nAinsi, quand cette pente est inférieure à celle de la droite passant par le point D (qui a une pente de \\frac{r_xK_y}{r_yK_x}) on a soit déflationiste soit inflationiste. On a donc pour condition \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x}.\nEnsuite pour que le système soit entièrement inflationiste on veut que la pente de \\beta = +\\infty soit entre celle de la droite passant par D et celle passant par A (première condition détaillée au premier point de l’analyse.) Ceci donne le résultat.\n\n\n\n\nAnimation\n\n\nCode\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \" style=\"overflow: hidden border: 1px solid black\" scrolling=\"no\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)\n\n\n\n\n\nFigure 1: Animation Geogebra permettant de voir quels paramètres influencent le système."
  },
  {
    "objectID": "modeleavecmigrationass.html#analyse-du-plan-de-phase",
    "href": "modeleavecmigrationass.html#analyse-du-plan-de-phase",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Analyse du plan de phase",
    "text": "Analyse du plan de phase\nOn va tracer le plan de phase complet et l’analyser.\nPour cela on trace l’ellipse de la même manière que dans la première figure.\nEnsuite on va tracer la droite correspondant à K_x+K_y=x^*+y^*. Ceci va permettre de voir si le système subit une inflation ou une déflation.\nEnfin on trace la parabole donnée par \\dot x =0 pour \\beta = 0 et \\beta = \\infty.\n\n\nCode\n#On crée la figure:\nfig2,ax2=plt.subplots(1,1,figsize=(11,6))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase 1:\n# Paramètres: \nrx=0.5\nry=1\nKx=2\nKy=1\nb=1\ngx=1\ngy=3\n\nparam_aug=np.array([rx,ry,Kx,Ky,b,gx,gy])\n\n# Isocline nulles:\nxt=np.arange(-10,10,0.01)\nyt=np.arange(-10,10,0.01)\n\n#xdot = 0 \nax2.plot(xt,gy*(xt/gx-rx*xt/b*(1-xt/Kx)),color='C2',label='$\\dot x=0$')\n\n#ydot = 0\nax2.plot(gx*(yt/gy-ry*yt/b*(1-yt/Ky)),yt,color='C3',label='$\\dot y=0$')\n\n#Cadrage:\nax2.set_xlim(left=-0.50,right=3)\nax2.set_ylim(top=3,bottom=-0.50)\nax2.set_xlabel('$x$',fontsize='12')\nax2.set_ylabel('$y$',fontsize='12')\n\n#Axe x et y:\nax2.plot(xt,np.zeros_like(xt),color='k',linestyle='dashed')\nax2.plot(np.zeros_like(yt),yt,color='k',linestyle='dashed')\n\n#Droite capacité:\nx=np.arange(0,10,0.01)\nax2.plot(x,-x+Kx+Ky,label='$K_x+K_y$',color='C9')\n\n#Plot des équilibres:\nax2.plot(xeq,yeq,label='Equilibre stable',marker='.',markersize=12)\nax2.plot(0,0,label='Equilibre Instable',marker='.',markersize=12,color='C5')\n\n#Ellipse:\nxg2=np.arange(-5,5,0.01)\nyg2=np.arange(-5,5,0.01)\nX2,Y2=np.meshgrid(xg2,yg2)\n\nX=rx*X2*(1-X2/Kx)\nY=ry*Y2*(1-Y2/Ky)\nax2.contour(X2,Y2,(X+Y),[0],colors='C1')\nax2.plot(0,0,color='C1',label='Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx*np.ones_like(xt),xt,color='C4',label='Parabole b=0')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt,xt*gy/gx,color='C6',label='Parabole b=$+\\infty$')\n\n#A:\nax2.plot(Kx,Ky,color='black',marker='.')\nax2.text(Kx-0.1,Ky-0.1,'$A$')\n\n#B:\nax2.plot(Kx,gy*Kx/gx,color='black',marker='.')\n\n#C:\nax2.plot(((gx/gy)*rx+ry)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky),((gy/gx)*ry+rx)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky),color='black',marker='.')\nax2.text(((gx/gy)*rx+ry)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky)-0.1,((gy/gx)*ry+rx)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky)+0.1,'$C$')\n\n#D:\nax2.plot(ry*Kx*(Kx+Ky)/(rx*Ky+ry*Kx),rx*Ky*(Kx+Ky)/(rx*Ky+ry*Kx),color='black',marker='.')\nax2.text(ry*Kx*(Kx+Ky)/(rx*Ky+ry*Kx)-0.1,rx*Ky*(Kx+Ky)/(rx*Ky+ry*Kx)-0.1,'$D$')\n\n#Légende:\nax2.legend()\n\n\n&lt;matplotlib.legend.Legend at 0x7f9bf81ea8c0&gt;\n\n\n\n\n\nSi r_x&lt;r_y, alors :\n\n\nSi on note A l’intersection entre la parabole en 0 et l’ellipse et B l’intersection entre la parabole en 0 et en +\\infty alors pour que x^* &lt; K_x (ce que l’on veut) il faut que la coordonnée en y de B soit supérieur à celle de A.\nLe point A est défini par : A=(K_x,K_y)\nLe point B est défini par : B=\\left(K_x,\\frac{\\gamma_yK_x}{\\gamma_x}\\right)\n\nAutrement dit, si \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} alors on a toujours l’augmentorium qui est efficace, ie le système est déflationiste quelque soit le taux de migration \\beta.\n\n\nSi on note C l’intersection entre l’ellipse et la parabole en +\\infty on a alors la valeur de l’équilibre en \\beta =+\\infty.\nLe point C est défini par : C=\\left(\\frac{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)r_x + r_y}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} , \\frac{\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)r_y + r_x}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} \\right)\nMaintenant notons D la valeur de l’intersection entre le droite des capacités et l’ellipse.\nLe point D est défini par : D=\\left(\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xKy+r_yK_x}\\right)\nAinsi, quand \\beta augmente le point d’équilibre se déplace entre A et C. On voit donc que l’équilibre peut soit être tout le temps déflationiste si C est avant A (point précédent) sur l’ellipse soit être constamment inflationiste si C est entre A et D soit être les deux si C est après D.\nVoyons ceci en terme de coefficient de droite, on a alors les exactes mêmes conditions mais sur les pentes des droites passant par ces points, qu’on peut calculer. On a déja par le premier point la condition sur les paramètres pour avoir le système déflationiste.\n\nSi \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x} alors on a des équilibres à la fois inflationiste et déflationiste. En effet ceci traduit que C est après D, graphiquement on voit que l’équilibre est au début au dessus de la droite cyan et à la fin en dessous (après avoir passé D).\nSi \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} alors les équilibres sont constamment inflationiste.\n\n\nEnfin on observe que si la droite cyan est tangente à l’ellipse alors on a que le système est constamment déflationiste. Ceci correspond au même calcul que dans la première partie et on trouve que si r_x=r_y le système est tout le temps déflationiste pour tout \\beta.\n\n\nMaintenant si on prend r_x&gt;r_y on a un autre cas qui apparaît.\nEn effet, et on le voit bien sur l’animation, on peut alors avoir C entre D et A avec C plus haut que A et ainsi on peut avoir un cas où le système est complètement inflationiste avec des valeurs de la somme des équilibres plus grands que C. Cette situation ne nous intéresse que peu car ce n’est pas un cas qui est biologiquement réaliste.\n\nPreuves:\n\nPoint B:\nLa première coordonnée est forcément K_x car on considère le croisement avec la parabole en \\beta = 0.\nOn sait que la parabole en \\beta = +\\infty est définie par y = \\frac{\\gamma_y}{\\gamma_x}x.\nOn a le résultat pour x=K_x.\nPoint C:\nLa parabole en \\beta = +\\infty est définie par y = \\frac{\\gamma_y}{\\gamma_x}x et l’ellipse par $r_xx(1- {K_x}) + r_yy(1-) = 0 $. Il suffit de remplacer dans l’expression de l’ellipse la valeur de y donnée par la parabole pour trouver la première coordonnée.\nPour trouver la deuxième on utilise l’expression de la parabole.\nPoint D: On fait la même que précédemment. La droite des capacités est définie par y= -x +K_x+K_y qu’on remplace dans l’expression de l’ellipse pour trouver la première coordonnée (après simplifacation). La deuxième est déduite de la la première grâce à l’expression de la droite.\n\nPour les conditions sur les équilibres on se rappelle que la pente de la parabole en \\beta = +\\infty est définie par \\frac{\\gamma_y}{\\gamma_x}.\nAinsi, quand cette pente est inférieure à celle de la droite passant par le point D (qui a une pente de \\frac{r_xK_y}{r_yK_x}) on a soit déflationiste soit inflationiste. On a donc pour condition \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x}.\nEnsuite pour que le système soit entièrement inflationiste on veut que la pente de \\beta = +\\infty soit entre celle de la droite passant par D et celle passant par A (première condition détaillée au premier point de l’analyse.) Ceci donne le résultat.\n\n\nAnimation\n\n\nCode\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width=\"800\" height=\"600\" src=\"https://www.geogebra.org/classic/bhhpgtqv\" style=\"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)\n\n\n\n\n\nFigure 1: Animation Geogebra permettant de voir quels paramètres influencent le système."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "Présentation",
    "section": "Remerciements",
    "text": "Remerciements\n\nJe tiens à remercier Ludovic Mailleret et son équipe pour m’avoir gentillement accueilli et fait confiance. Merci spécialement à Ludovic qui m’a beaucoup supporté et qui a pris de son temps pour m’aider."
  },
  {
    "objectID": "modeleavecmigrationass.html#somme-des-équilibres-en-fonction-de-la-migration",
    "href": "modeleavecmigrationass.html#somme-des-équilibres-en-fonction-de-la-migration",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Somme des équilibres en fonction de la migration",
    "text": "Somme des équilibres en fonction de la migration\n\nIllustration des propositions précédentes\nOn va illustrer les propositions précédentes en traçant la somme des équilibres en fonction de \\beta. Pour cela on va simuler avec odeint (pendant un temps assez large pour atteindre l’équilibre) pour chaque valeur de \\beta.\nOn définit une fonction qui dépend de \\beta :\n\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, gy = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\net on pose le temps d’intégration, les paramètres et les conditions initiales :\n\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\n\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4, gx4, gy4])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 100, 0.01)\n\n#Condition initiale:\ne0 = [1, 1]\n\nEt enfin on trace les quatre figures :\n\nfig, (ax, ax1, ax2, ax3) = plt.subplots(1, 4, figsize = (9, 4))\nplt.subplots_adjust(wspace = 0.5)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i)) #On calcule pour chaque beta l'équilibre\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n    s3 = odeint(aug2, e0, t, args = (param4, i))\n    ax3.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n    \n    \nfor i in np.arange(0, 4, 0.001):\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n\n#Plot de la droite Kx+Ky:    \nxt = np.arange(0, 4, 0.01)\nxt2 = np.arange(0, 4, 0.001)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt2, (Kx2 + Ky2) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.10, Kx2 + Ky2 + 0.006, '$K_x+K_y$')\n\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.12, Kx3 + Ky3 + 0.006, '$K_x+K_y$')\n\nax3.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax3.text(3.12, Kx4 + Ky4 + 0.006, '$K_x+K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax2.set_xlabel('β')\nax3.set_xlabel('β')\nax.set_ylabel('Population')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\n\n#On déplace la légende hors de la figure:\nax.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5))\n\n#Titres:\nax.set_title('Déflation')\nax1.set_title('Les deux')\nax2.set_title('Inflation')\nax3.set_title('Inflation')\n\nText(0.5, 1.0, 'Inflation')\n\n\n\n\n\nOn voit donc que la structuration de l’espace peut causer dans plusieurs cas une inflation. C’est ce que l’on souhaite éviter à tout prix avec l’augmentorium.\nMais, les hypothèses sur l’augmentorium limitent les situations qu’on peut atteindre.\nEn effet, comme r_x&lt;r_y la quatrième situation est impossible. De plus, comme \\gamma_x &lt;&lt; \\gamma_y on a \\frac{\\gamma_y}{\\gamma_x}&gt;&gt;1. Et, puisque la capacité K entre l’augmentorium et la culture diffère en fonction des types de cultures mais reste généralement proche entre les deux.\nAinsi le rapport entre ces deux capacités est proche de 1 que ce soit inférieurement ou supérieurement.\nOn a donc en permanence dans les cultures la condition \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} ce qui implique une déflation de la somme des équilibres par rapport à la capacité totale.\n\n\nCas de l’augmentorium\nDans le cas de l’augmentorium il est important de considérer l’équilibre x^* seule par rapport à K_x (sa valeur s’il n’y a pas de migration). En effet même si on a inflation dans le système si x^*&lt;K_x alors on considère l’augmentorium comme efficace.\nOn va donc tracer l’équilibre x^* en fonction de \\beta en considérant que soit K_x &lt; K_y soit K_x &gt; K_y :\n\n\nCode\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 1\nKy2 = 2\ngx2 = 0.5\ngy2 = 3\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\nax.set_title('Equilibre de la culture en fonction du taux de migration avec $K_x&gt;K_y$', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de migration avec $K_x&lt;K_y$', fontsize = 7)\n\n#Boucle en fonction de beta\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0], marker = '.', color = 'C0')\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0], marker = '.', color = 'C0')\n\n#Droite Kx:\nxt = np.arange(0, 4, 0.01)\nax.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 - 0.1, '$K_x$')\n\nax1.plot(xt, Kx2 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 - 0.1, '$K_x$')\n\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax.plot(0, 0, color = 'C0', label = 'Eq. culture')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture')\n\nax.legend()\nax1.legend()\n\n\n&lt;matplotlib.legend.Legend at 0x7f23a5b7b700&gt;\n\n\n\n\n\nOn observe que quelque soit le type de culture on a efficacité de l’augmentorium.\nEnsuite, comme le taux de fuite est un paramètre clé de notre méthode. On va donc tracer la somme des équilibres et l’équilibre x^* en fonction de \\gamma_y.\nAttention, un fort taux de fuite correspond à un \\gamma_y faible.\n\n\nCode\n#Définition d'un nouveau modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\nb = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx1 - 0.1, '$K_x$')\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.01):\n    s = odeint(aug3, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax1.plot(i, s[-1][0], marker = '.', color = 'C0')\n\n#Légendes:\nax1.set_xlabel('Ɣy, Fuite')\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture')\n\nax.set_title('Somme des équilibres en fonction du taux de fuite', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de fuite', fontsize = 7)   \nax.legend()\nax1.legend()\nax.set_ylabel(\"Densité de pop.\")\n\n\nText(0, 0.5, 'Densité de pop.')\n\n\n\n\n\nOn observe que la somme des équilibres de la population de ravageurs en fonction du taux de fuite a une forme que nous n’avions pas eu.\nIl est possible en passant par l’animation geogebra de voir ceci en modifiant le taux de fuite. On a pour des fortes fuites un système déflationiste, puis une petite zone inflationiste et enfin de nouveau une zone déflationiste. Ceci est paradoxal car on est entrain de dire que un fort taux de fuite encourage une déflation du système et donc une efficacité de la technique de l’augmentorium.\nIl faut donc chercher plus en détail et exprimer l’équilibre dans la culture en fonction de la fuite. En effet, c’est ce qui nous intéresse le plus car l’équilibre dans l’augmentorium n’est pas important pour la lutte biologique.\nOn voit que l’équilibre dans la culture est d’abord inflationiste pour des forts taux de fuites et ensuite déflationiste pour des taux de fuites faibles. On a ici le résultat logique auquel on s’attendait qui est que l’augmentorium n’est pas efficace si la fuite est trop forte.\nDonc si le taux de fuite est très mal géré l’augmentorium peut être négatif pour la culture."
  },
  {
    "objectID": "modeleavecmigrationass.html#conclusion",
    "href": "modeleavecmigrationass.html#conclusion",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Conclusion",
    "text": "Conclusion\nCe modèle considère uniquement la population de ravageurs. Or, la méthode de l’augmentorium repose énormément sur l’action des prédateurs on va donc considérer maintenant un modèle qui prend en compte ces prédateurs."
  },
  {
    "objectID": "modelsimpleaug.html#définition-du-modèle",
    "href": "modelsimpleaug.html#définition-du-modèle",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nCe modèle est un modèle de prédation de Lotka-Volterra où les proies se répartissent en deux structures et les prédateurs diffusent librement entre les deux strcutures.\nNous partirons pour être plus général du postulat que la prédation et les naissances sont diférentielles entre les structures mais certaines analyses se baseront sur une égalité des naissances par exemple.\nNous considérons le modèle suivant :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\navec:\n- r_x le taux de croissance de x dans la culture,\n- r_y le taux de croissance de y dans l’augmentorium,\n- K_x la capacité maximale de la culture,\n- K_y la capacité maximale de l’augmentorium,\n- \\beta la force de migration,\n- \\gamma_x le taux d’assymétrie de la migration culture vers augmentorium,\n- \\gamma_y le taux d’assymétrie de la migration augmentorium vers culture,\n- p_x,p_y la prédation de z sur x ou y,\n- n_x,n_y le taux de conversion proie prédateur dans la culture ou l’augmentorium (naissance due à la prédation),\n- m la mortalité des prédateurs z.\nOn a donc maintenant un espace structuré en deux zones, s’échangeant assymétriquement de la population (qui grandit logisitiquement), le tout controlé par une population de prédateurs ne chassant et ne se reproduisant pas de la même manière dans les deux zones.\n\nNouvelles hypothèses :\nOn pose p_y &gt; p_x et n_y&gt;n_x.\nEn effet l’augmentorium est un lieu propice au développement des individus que ce soit les parasites ou les ravageurs.\nAinsi la prédation exercé sur les ravageurs est plus forte dans l’augmentorium et les naissances des prédateurs sont plus fortes dans l’augmentorium que dans la culture."
  },
  {
    "objectID": "modelsimpleaug.html#dynamique-des-populations",
    "href": "modelsimpleaug.html#dynamique-des-populations",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Dynamique des populations",
    "text": "Dynamique des populations\nOn va encore une fois simuler comment se comporte les trois populations en fonction du temps.\nLe code commenté est acessible dans la boite cachée ci dessous:\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat,t,param):\n    x,y,z=etat\n    rx,Kx,ry,Ky,gx,gy,b,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Paramètres Simulation 1 : \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\ngx1=0.5\ngy1=3\nb1=1\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,b1,px1,py1,nx1,ny1,m1])\n\n#Paramètres Simulation 2: \nrx2=0.5\nry2=1\nKx2=2\nKy2=1\ngx2=0.5\ngy2=3\nb2=1\npx2=0.5\npy2=1\nnx2=0.5\nny2=1\nm2=2\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,b2,px2,py2,nx2,ny2,m2])\n\n#Temps d'intégration 1,2:\nt3=np.arange(0,200,0.01)\nt4=np.arange(0,50,0.01)\n\n#Condition initiale de 1,2:\nx0=2\ny0=0\nz0=0.5\nc0=np.array([x0,y0,z0])\n\n#Simulation 1,2:\ns3=odeint(a,c0,t3,args=(param_a1,))\ns4=odeint(a,c0,t4,args=(param_a2,))\n\n#Plot de la figure: \nfig,ax = plt.subplots(1,2,figsize=(14,5))\nfig.suptitle('Simulation du modèle d\\'augmentorium')\nplt.subplots_adjust(hspace=0.4)\n\n#Plot de l'axe 1:\nax[0].plot(t3,s3[:,0],color='C0',label='Ravageur dans la culture')\nax[0].plot(t3,s3[:,1],color='C1',label='Ravageur dans l\\'augmentorium')\nax[0].plot(t3,s3[:,2],color='C6',label='Prédateurs totaux')\n\n#Plot de l'axe 2:\nax[1].plot(t4,s4[:,0],color='C0',label='Ravageur dans la culture')\nax[1].plot(t4,s4[:,1],color='C1',label='Ravageur dans l\\'augmentorium')\nax[1].plot(t4,s4[:,2],color='C6',label='Prédateurs totaux')\n\n\n#Légendes et titres:\nax[0].set_ylabel('Population, x,y,z')\nax[0].legend(fontsize=8)\nax[0].grid()\nax[0].set_xlabel('Temps, t')\nax[0].set_ylim(top=2,bottom=-0.05)\nax[0].set_title('Coexistence des trois populations',fontsize=7.5)\n\nax[1].set_xlabel('Temps, t')\nax[1].set_ylabel('Population, x,y,z')\nax[1].legend(fontsize=8)\nax[1].grid()\nax[1].set_ylim(top=2,bottom=-0.05)\n\nax[1].set_title('Disparition des parasites, maintien des ravageurs',fontsize=7.5)\n\n\nText(0.5, 1.0, 'Disparition des parasites, maintien des ravageurs')\n\n\n\n\n\nLes profils de dynamique se répartissent en deux grandes catégories. Ceux où la population de prédateurs survit et celle où elle disparaît. Il semble donc il y a voir deux équilibres stables dans ce système.\nPour de faibles temps t on observe des oscillations à la Lotka-Volterra.\nLe profil de la dynamique de la population sans prédateurs est similaire au modèle avec seulement les proies et la migration assymétrique. On verra dans la suite que ces deux modèles sont complètement confondus (sans prédateurs)."
  },
  {
    "objectID": "modelsimpleaug.html#plan-de-phase",
    "href": "modelsimpleaug.html#plan-de-phase",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Plan de phase",
    "text": "Plan de phase\nPour tracer le plan de phase on pose toutes les variations égales à 0 (situation d’équilibre) :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n0 = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n0 = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n qui devient :\n\n\\left\\{\\begin{array}{l}\nz_1 = \\frac{r_x}{p_x}\\left(1-\\frac{x}{K_x}\\right)+\\frac{\\beta}{p_xx}\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\nz_2 = \\frac{r_y}{p_y}\\left(1-\\frac{y}{K_y}\\right)+\\frac{\\beta}{p_yy}\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\\\\\nz=0 \\lor n_xx+n_yy=m\n\\end{array}\\right.\n\nOn se retrouve avec deux surfaces et deux plans dont les intersections seront les équilibres. Voyons ceci avec une animation :\n\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width=\"600\" height=\"500\" src=\"https://www.geogebra.org/classic/bw3wqnzg\" style=\"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)"
  },
  {
    "objectID": "modelaug.html",
    "href": "modelaug.html",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport plotly.express as px"
  },
  {
    "objectID": "modelaug.html#définition-du-modèle",
    "href": "modelaug.html#définition-du-modèle",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nCe modèle est un modèle de prédation de Lotka-Volterra où les proies se répartissent en deux structures et les prédateurs diffusent librement entre les deux strcutures.\nNous partirons pour être plus général du postulat que la prédation et les naissances sont diférentielles entre les structures mais certaines analyses se baseront sur une égalité des naissances par exemple.\nNous considérons le modèle suivant d’après Freedman (1977):\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{1}\navec:\n- r_x le taux de croissance de x dans la culture,\n- r_y le taux de croissance de y dans l’augmentorium,\n- K_x la capacité maximale de la culture,\n- K_y la capacité maximale de l’augmentorium,\n- \\beta la force de migration,\n- \\gamma_x le taux d’assymétrie de la migration culture vers augmentorium,\n- \\gamma_y le taux d’assymétrie de la migration augmentorium vers culture,\n- p_x,p_y la prédation de z sur x ou y,\n- n_x,n_y le taux de conversion proie prédateur dans la culture ou l’augmentorium (naissance due à la prédation),\n- m la mortalité des prédateurs z.\nOn a donc maintenant un espace structuré en deux zones, s’échangeant assymétriquement de la population (qui grandit logisitiquement), le tout controlé par une population de prédateurs ne chassant et ne se reproduisant pas de la même manière dans les deux zones.\n\nNouvelles hypothèses\nOn pose p_y &gt; p_x et n_y&gt;n_x.\nEn effet l’augmentorium est un lieu propice au développement des individus que ce soit les prédateurs ou les ravageurs.\nAinsi la prédation exercé sur les ravageurs est plus forte dans l’augmentorium et les naissances des prédateurs sont plus fortes dans l’augmentorium que dans la culture."
  },
  {
    "objectID": "modelaug.html#dynamique-des-populations",
    "href": "modelaug.html#dynamique-des-populations",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Dynamique des populations",
    "text": "Dynamique des populations\nOn va encore une fois simuler comment se comporte les trois populations en fonction du temps.\nLe code commenté est acessible dans la boite cachée ci dessous:\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat,t,param):\n    x,y,z=etat\n    rx,Kx,ry,Ky,gx,gy,b,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Paramètres Simulation 1 : \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\ngx1=0.5\ngy1=3\nb1=1\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,b1,px1,py1,nx1,ny1,m1])\n\n#Paramètres Simulation 2: \nrx2=0.5\nry2=1\nKx2=2\nKy2=1\ngx2=0.5\ngy2=3\nb2=1\npx2=0.5\npy2=1\nnx2=0.5\nny2=1\nm2=2\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,b2,px2,py2,nx2,ny2,m2])\n\n#Temps d'intégration 1,2:\nt3=np.arange(0,200,0.01)\nt4=np.arange(0,50,0.01)\n\n#Condition initiale de 1,2:\nx0=2\ny0=0\nz0=0.5\nc0=np.array([x0,y0,z0])\n\n#Simulation 1,2:\ns3=odeint(a,c0,t3,args=(param_a1,))\ns4=odeint(a,c0,t4,args=(param_a2,))\n\n#Plot de la figure: \nfig,ax = plt.subplots(1,2,figsize=(14,5))\nfig.suptitle('Simulation du modèle d\\'augmentorium')\nplt.subplots_adjust(hspace=0.4)\n\n#Plot de l'axe 1:\nax[0].plot(t3,s3[:,0],color='C0',label='Ravageurs dans la culture')\nax[0].plot(t3,s3[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax[0].plot(t3,s3[:,2],color='C6',label='Prédateurs totaux')\n\n#Plot de l'axe 2:\nax[1].plot(t4,s4[:,0],color='C0',label='Ravageurs dans la culture')\nax[1].plot(t4,s4[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax[1].plot(t4,s4[:,2],color='C6',label='Prédateurs totaux')\n\n\n#Légendes et titres:\nax[0].set_ylabel('Population, x,y,z')\nax[0].legend(fontsize=8)\nax[0].grid()\nax[0].set_xlabel('Temps, t')\nax[0].set_ylim(top=2,bottom=-0.05)\nax[0].set_title('Coexistence des trois populations',fontsize=7.5)\n\nax[1].set_xlabel('Temps, t')\nax[1].set_ylabel('Population, x,y,z')\nax[1].legend(fontsize=8)\nax[1].grid()\nax[1].set_ylim(top=2,bottom=-0.05)\n\nax[1].set_title('Disparition des prédateurs, maintien des ravageurs',fontsize=7.5)\n\n\nText(0.5, 1.0, 'Disparition des prédateurs, maintien des ravageurs')\n\n\n\n\n\nLes profils de dynamique se répartissent en deux grandes catégories. Ceux où la population de prédateurs survit et celle où elle disparaît. Il semble donc il y a voir deux équilibres stables dans ce système.\nPour de faibles temps t on observe des oscillations à la Lotka-Volterra.\nLe profil de la dynamique de la population sans prédateurs est similaire au modèle avec seulement les proies et la migration assymétrique. On verra dans la suite que ces deux modèles sont complètement confondus (sans prédateurs)."
  },
  {
    "objectID": "modelaug.html#plan-de-phase",
    "href": "modelaug.html#plan-de-phase",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Plan de phase",
    "text": "Plan de phase\nPour tracer le plan de phase on pose toutes les variations égales à 0 (situation d’équilibre) :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)-p_xx^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)-p_yy^*z^* \\\\\n0 = z^*\\left(n_xx^*+n_yy^* - m\\right)\n\\end{array}\\right.\n\\tag{2}\nqui devient :\n\n\\left\\{\\begin{array}{l}\nz^* = \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right)+\\frac{\\beta}{p_xx^*}\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)\\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right)+\\frac{\\beta}{p_yy^*}\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)\\\\\nz^*=0 \\lor n_xx^*+n_yy^*=m\n\\end{array}\\right.\n\\tag{3}\nOn se retrouve avec deux surfaces et deux plans dont les intersections seront les équilibres. Voyons ceci avec une animation :\n\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width=\"700\" height=\"550\" src=\"https://www.geogebra.org/classic/bw3wqnzg\" style=\"overflow: hidden border: 1px solid black\" scroll=\"no\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)\n\n\n\n\n\nEn vert on a l’intersection entre la surface définie par \\dot x =0 et les plans z=0 et n_xx+n_yy=m.\nEn rouge on a l’intersection entre la surface définie par \\dot y =0 et les plans z=0 et n_xx+n_yy=m.\nOn a donc que l’intersetion des courbes vertes et rouges sont les équilibres. Il est facile de voir qu’il n’en existe que trois différents dont un seul correspond à la coexistence des trois populations.\nOn peut aussi plot la trajectoire de la population avec plotly :\n\nfig = px.line_3d(x=s3[:,0], y=s3[:,1], z=s3[:,2],title=\"Coexistence des populations z≠0\")\nfig2 = px.line_3d(x=s4[:,0], y=s4[:,1], z=s4[:,2],title=\"Extinction des prédateurs z=0\")\nfig.show()\nfig2.show()\n\n\n                                                \n\n\n\n                                                \n\n\n\nCalcul des équilibres\nSi z=0 alors (1) devient:\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{4}\nqui est exactement le système considéré précedemment. Pour l’analyse de ses équilibres se référer à ceci.\nOn va donc s’intéresser uniquement à l’équilibre de coexistence qu’on notera (x^* , y^* , z^*).\nNous allons calculer pour différentes valeurs de \\beta les valeurs de l’équilibre.\n\nLorsque \\beta = 0\n(2) devient : \n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)-p_xx^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)-p_yy^*z^* \\\\\n0 = z^*\\left(n_xx^*+n_yy^* - m\\right)\n\\end{array}\\right.\n\\tag{5} \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\nz^* = \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) \\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right) \\\\\ny^* = \\frac{1}{n_y}\\left(m-n_xx^*\\right)\n\\end{array}\\right.\n\\tag{6} et ainsi :\n\n\\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) = \\frac{r_y}{p_y}\\left(1-\\frac{m}{n_yK_y}+\\frac{n_xx^*}{n_y}\\right)\n et donc : \nx^*=\\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\n\nOn déduit y^* et z^* avec leur définition d’après (6): \n\\left\\{\\begin{array}{l}\nx^* =  \\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x} \\\\\ny^* = \\frac{K_y\\left(r_yn_xp_xK_x+r_xp_ym - r_xn_xp_yK_x\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x} \\\\\nz^* = r_xr_y\\left(\\frac{n_xK_x+n_yK_y-m}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\right)\n\\end{array}\\right.\n\\tag{7}\n\n\n\n\n\n\nWarning\n\n\n\nLe document de Freedman (1977) contient deux erreurs, un B_1 à la place d’un \\beta_1 dans l’expression de y^* (respectivement x_{20} dans son article) et un p_y à la place d’un p_x dans l’expression de z^* (respectivement un \\beta_2 à la place d’un \\beta_1 selon ses notations).\n\n\nPour que ces équilibres soient positifs il faut que :\n\n-\\frac{mr_y}{K_yn_yp_y} &lt; \\frac{r_x}{p_x} - \\frac{r_y}{p_y} &lt; \\frac{mr_x}{K_xn_xp_x}\n\\tag{8}\net\n\nn_xK_x+n_yK_y &gt; m\n\\tag{9}\nOn verra dans la suite que la condition (9) est l’invasion des prédateurs.\n\n\nLorsque \\beta \\ne 0 et petit\nPour \\beta petit on va utiliser l’égalité de Taylor pour trouver (x_*,y^*,z^*). On a alors, si on note (x^*(\\beta),y^*(\\beta),z^*(\\beta)):\n\n\\left\\{\\begin{array}{l}\nx^*(0) = \\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\\\\ny^*(0) = \\frac{K_y\\left(r_yn_xp_xK_x+r_xp_ym - r_xn_xp_yK_x\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\\\\nz^*(0) = r_xr_y\\left(\\frac{n_xK_x+n_yK_y-m}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\right)\n\\end{array}\\right. \\\\\n\nSoit \\mathbb{F(x,y,z,\\beta)} tel que : \n\\mathbb{F(x,y,z,\\beta)} = \\left\\{\\begin{array}{l}\nr_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\nr_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\nz\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right. \\\\\n On veut ainsi résoudre : \n\\mathbb{F\\left(\\mathcal{x}^*(\\beta) , \\mathcal{y}^*(\\beta) , \\mathcal{z}^*(\\beta) , \\beta\\right)}=0\n\nor, d’après la formule de Taylor on a à l’ordre 1 en dimension 4 on a:\n\n\\mathbb{F\\left(\\mathcal{x}^*(\\beta) , \\mathcal{y}^*(\\beta) , \\mathcal{z}^*(\\beta) , \\beta\\right)}=\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)} + \\\\\n\\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta + \\mathbb{J}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}}\\small\\begin{pmatrix} \\mathcal{x}^*(\\beta) - \\mathcal{x}^*(\\mathcal{0}) \\\\ \\mathcal{y}^*(\\beta) - \\mathcal{y}^*(\\mathcal{0}) \\\\ \\mathcal{z}^*(\\beta) - \\mathcal{z}^*(\\mathcal{0}) \\end{pmatrix} + o(\\beta)\n\\tag{10} \n\\Leftrightarrow\n \n\\begin{pmatrix} \\mathcal{x}^*(\\beta) \\\\ \\mathcal{y}^*(\\beta) \\\\ \\mathcal{z}^*(\\beta) \\end{pmatrix} =\n\\begin{pmatrix} \\mathcal{x}^*(\\mathcal{0}) \\\\  \\mathcal{y}^*(\\mathcal{0}) \\\\  \\mathcal{z}^*(\\mathcal{0}) \\end{pmatrix} - \\mathbb{J^{\\mathcal{-1}}}\\tiny{\\mathbb{F\\left(\\mathcal{x}_2^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} \\small\\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta + o(\\beta)\n\nOn a, \\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta = \\begin{pmatrix} -\\frac{\\mathcal{x}^*(\\mathcal{0})}{\\gamma_x}+\\frac{\\mathcal{y}^*(\\mathcal{0})}{\\gamma_y}\\\\\\frac{\\mathcal{x}^*(\\mathcal{0})}{\\gamma_x}-\\frac{\\mathcal{y}^*(\\mathcal{0})}{\\gamma_y}\\\\ 0\\end{pmatrix} .\net, \n\\mathbb{J}\\small{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} =\n\\begin{pmatrix} -\\frac{r_xx^*(0)}{K_x} & 0 & -p_xx^*(0) \\\\ 0 & -\\frac{r_yy^*(0)}{K_y} & -p_yy^*(0) \\\\ n_xz^*(0) & n_yz^*(0) & 0 \\end{pmatrix}\n\nil est alors facile de calculer que, \ndet(\\mathbb{J}) = -x^*(0)y^*(0)z^*(0)\\left(\\frac{r_xn_yp_y}{K_x}+\\frac{r_yn_xp_x}{K_y}\\right) \\ne 0\n\nLa jacobienne est donc bien inversible et on peut la calculer (méthode des cofacteurs) ce qui donne : \n\\mathbb{J^{\\mathcal{-1}}}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} =\\small \\frac{1}{\\frac{r_xp_yn_y}{K_x}+\\frac{r_yp_xn_x}{K_y}} \\begin{pmatrix} -\\frac{p_yn_y}{x^*(0)} & \\frac{p_xn_y}{y^*(0)} & \\frac{r_yp_x}{z^*(0)K_y} \\\\ \\frac{p_yn_x}{x^*(0)} & -\\frac{p_xn_x}{y^*(0)} & \\frac{r_xp_y}{z^*(0)K_x} \\\\ -\\frac{r_yn_x}{x^*(0)K_y} & -\\frac{r_xn_y}{y^*(0)K_x}& -\\frac{r_xr_y}{z^*(0)K_xK_y} \\end{pmatrix}\n\\tag{11}\nEn mettant en œuvre le calcul on trouve : \n\\left\\{\\begin{array}{l}\nx^*(\\beta) = x^*(0) - \\frac{\\beta n_yK_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{p_y}{x^*(0)}+\\frac{p_x}{y^*(0)}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\\\\\ny^*(\\beta) = y^*(0) - \\frac{\\beta n_xK_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{p_y}{x^*(0)}+\\frac{p_x}{y^*(0)}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\\\\\nz^*(\\beta) = z^*(0) - \\frac{\\beta K_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{r_xn-y}{y^*(0)K_x}-\\frac{r_yn_x}{x^*(0)K_y}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\n\\end{array}\\right.\\\\\n\\tag{12}\n\n\nLorsque \\beta est quelconque\n(2) donne, en exprimant y^* en fonction de x^*: \n\\left\\{\\begin{array}{l}\nz^* =  \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{\\beta}{p_x}\\left(\\frac{m}{n_y\\gamma_y x^*}-\\frac{n_x}{n_y\\gamma_y}-\\frac{1}{\\gamma_x}\\right)   \\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{m-n_xx^*}{n_yK_y}\\right) + \\frac{\\beta n_y}{p_y}\\left(\\frac{x^*}{\\gamma_x\\left(m-n_xx^*\\right)}-\\frac{1}{n_y\\gamma_y}\\right) \\\\\ny^* =\\frac{1}{n_y}\\left(m- n_xx^*\\right)\n\\end{array}\\right.\n\\tag{13}\nOn trouve x^* en faisant l’intersection entre les deux premières équations, on trouve y^* avec la troisième équation et z^* avec la première équation.\nPour calculer l’équilibre on utilise numpy:\n\n\nCode\n#Calcul de x*:\nx=np.polynomial.Polynomial([0,1])\n#Polynome :\npol1= (m1-nx1*x)*x*rx1/px1*(1-x/Kx1) + (m1-nx1*x)*b1/px1*((m1-nx1*x)/(ny1*gy1) - x/gx1) - (m1-nx1*x)*x*ry1/py1*(1-(m1-nx1*x)/(ny1*Ky1)) - x*b1*ny1/py1*(x/gx1 - (m1-nx1*x)/(ny1*gy1))\n#On utilise un masque booléen adapté à la situation --&gt; solution réelle, positive et qui vérifie la condtion imposée par la troisième équation du système:\nsolx=pol1.roots()[(np.isreal(pol1.roots())) *(pol1.roots() &gt; 0)*(pol1.roots()&lt;m1/ny1)]\n\n#Calcul de y*:\nsoly=1/ny1*(m1-nx1*solx)\n\n#Calcul de z*:\nsolz=rx1/px1*(1-solx/Kx1) + b1/px1*(m1/(ny1*gy1*solx) -nx1/(ny1*gy1)- 1/gx1)\n\n\n\n\n\nStabilité des équilibres\nSans prédateurs (z=0) on a les mêmes équilibres que dans la partie précédente, la stabilité est donc la même que dans la partie précédente.\nOn va calculer pour différentes valeurs de \\beta la stabilité.\n\nLorsque \\beta=0\nLa jacobienne du système est: \n\\mathbb{J_{\\mathcal{x^*_2},\\mathcal{y^*_2},\\mathcal{z^*_2},\\mathcal{0}}}  =  \\begin{pmatrix} -\\frac{r_xx_2^*(0)}{K_x} & 0 & -p_xx_2^*(0) \\\\ 0 & -\\frac{r_yy_2^*(0)}{K_y} & -p_yy_2^*(0) \\\\ n_xz_2^*(0) & n_yz_2^*(0) & 0 \\end{pmatrix}\n\nEn calculant le polynôme caractéristique on en déduit que toutes les parties réelles des valeurs propres sont négatives et que donc l’équilibre est stable. La preuve est faite par Freedman dans son théorème 4.1.\n\n\nLorsque \\beta \\ne 0 et \\beta petit\n\n\\mathbb{J_{\\mathcal{x^*},\\mathcal{y^*},\\mathcal{z^*},\\mathcal{\\beta}}}  =  \\begin{pmatrix} -\\frac{r_xx^*(0)}{K_x} -\\frac{\\beta}{\\gamma_x} & \\frac{\\beta}{\\gamma_y} & -p_xx^*(0) \\\\ \\frac{\\beta}{\\gamma_x} & -\\frac{r_yy^*(0)}{K_y}-\\frac{\\beta}{\\gamma_y} & -p_yy^*(0) \\\\ n_xz^*(0) & n_yz^*(0) & 0 \\end{pmatrix} = \\mathbb{J_{\\mathcal{x^*},\\mathcal{y^*},\\mathcal{z^*},\\mathcal{0}}} + \\beta \\begin{pmatrix} -\\frac{1}{\\gamma_x} & \\frac{1}{\\gamma_y} & 0 \\\\ \\frac{1}{\\gamma_x} & -\\frac{1}{\\gamma_y} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n\nComme \\beta est petit on a la matrice qui est petite et qui n’influence pas le signe des valeurs propres. Donc l’équilibre est encore stable."
  },
  {
    "objectID": "modelaug.html#equilibres-en-fonction-des-paramètres",
    "href": "modelaug.html#equilibres-en-fonction-des-paramètres",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Equilibres en fonction des paramètres",
    "text": "Equilibres en fonction des paramètres\nDans cette partie on va distinguer les cas où n_x = n_y et p_x=p_y de ceux où ils sont différents.\nEn effet, l’un des postulats de l’augmentorium est que le dévellopement des ravageurs et prédateurs est favorisé dans celui-ci mais on peut supposer que la prédation et les naissances dans l’augmentorium sont égales.\nIl est intéressant de considérer la somme des équilibre des proies en fonction de la force de migration (\\beta) et les équilibres dans la culture en fonction du taux de fuite (\\gamma_y) et du taux de migration (\\gamma_x).\n\nPrédation et naissances égales\nDans ce cas (1) devient :\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-pxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-pyz \\\\\n\\dot z = z\\left(n\\left(x+y\\right) - m\\right)\n\\end{array}\\right.\n\\tag{14}\n\nSomme des équilibres des proies en fonction de \\beta\nA l’équilibre, on a :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)-px^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)-py^*z^* \\\\\nx^*+y^* = \\frac{m}{n}\n\\end{array}\\right.\n\\tag{15}\nOn voit, avec la troisième équation du système, que la somme des équilibres des proies est toujours égale à \\frac{m}{n} quelque soit \\beta du moment que les prédateurs sont présents.\nIntuitivement on considère que la présence d’un équilibre des prédateurs positifs (invasion des prédateurs) est soumise à la condition que pour une population aussi petite soit elle de prédateurs (\\beta \\to 0) et pour les proies à l’équilibre on ait un taux de croissance positif pour les prédateurs.\nMathématiquement cette assomption est équivalente à la condition, si on note (x_0^*(\\beta),y^*_0(\\beta)) l’équilibre sans prédateurs pour un taux \\beta, que x_0^* + y_0^* &gt; \\frac{m}{n} \\Leftrightarrow \\exists z^* \\ne 0.\nPour \\beta = 0 on a que s’il existe un équilibre des prédateurs positif alors on a K_x+K_y&gt;\\frac{m}{n} par l’égalité (7). Ceci est donc la condition d’invasion des prédateurs (9) mentionnée plus tôt.\nSi \\beta = \\infty on va réduire le système (14) en équation de Lotka-Volterra avec croissance logistique. Ainsi la présence d’un équilibre des prédateurs impliquera la condition d’invasion supposée.\nLa démarche à partir du système (14) est la suivante :\n\n\\dot x - \\dot y = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right) - r_yy^*\\left(1-\\frac{y^*}{K_y}\\right) + pz\\left(y-x\\right) -2\\beta \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\tag{16}\nQuand \\beta \\to \\infty, \\dot x - \\dot y devient : \n\\dot x - \\dot y = -2\\beta \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\net donc on a forcément que \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right) \\to 0 ie que \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\nOn pose N = x+y qui est, avec l’assertion précédente, équivalent à \n\\frac{N}{\\gamma_x+\\gamma_y} = \\frac{x+y}{\\gamma_x+\\gamma_y} = \\frac{\\frac{x\\gamma_x}{\\gamma_x}+\\frac{y\\gamma_y}{\\gamma_y}}{\\gamma_x+\\gamma_y} = \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}\n\\tag{17}\nOn a ainsi : \n\\dot N = \\dot x + \\dot y = \\frac{r_xx\\gamma_x}{\\gamma_x}\\left(1-\\frac{x}{K_x}\\right) + \\frac{r_yy\\gamma_y}{\\gamma_y}\\left(1-\\frac{y}{K_y}\\right)-pzN\n \n\\Leftrightarrow\n \n\\dot N = \\frac{r_xN\\gamma_x}{\\gamma_x+\\gamma_y}\\left(1-\\frac{x}{K_x}\\right) + \\frac{r_yN\\gamma_y}{\\gamma_x+\\gamma_y}\\left(1-\\frac{y}{K_y}\\right)-pzN\n \n\\Leftrightarrow\n \n\\dot N = \\left(\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right)N\\left(1-\\frac{\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}}{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}N\\right)-pzN\n\\tag{18}\nEn posant r_N = \\left(\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right) et K_N=\\frac{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}{\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}} le système devient :\n \\left\\{\\begin{array}{l}\n\\dot N = r_NN\\left(1-\\frac{N}{K_N}\\right)-pzN \\\\\n\\dot z = z\\left(nN - m\\right)\n\\end{array}\\right.\n\\tag{19}\nqui est bien un système de L-V avec croissance logistique.\nSi \\exists z^* &gt; 0 alors on a N^*=\\frac{m}{n}.\nDe plus, on a : pz^* = r_N\\left(1-\\frac{N^*}{K_N}\\right) et donc si z^*&gt;0 on a N^* &lt; K_N qui est équivalent à \\frac{m}{n} &lt; K_N.\nSi on considère le système précédent sans prédateurs on a :\n \\left\\{\\begin{array}{l}\n\\dot N_0 = r_NN_0\\left(1-\\frac{N_0}{K_N}\\right)\n\\end{array}\\right.\n\net on a donc N_0^* = K_N.\nOr, posons la condition mathématique intuitive : \nx^*_0(+\\infty)+y^*_0(+\\infty) &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \n\\frac{x^*_0(+\\infty)\\gamma_x}{\\gamma_x}+\\frac{y^*_0(+\\infty)\\gamma_y}{\\gamma_y} &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \n\\frac{N_0^*(+\\infty)\\gamma_x}{\\gamma_x+\\gamma_y}+\\frac{N^*_0(+\\infty)\\gamma_y}{\\gamma_x+\\gamma_y} &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \nK_N &gt; \\frac{m}{n}\n\nL’intuition biologique est donc confirmée par des preuves mathématiques.\nOn va donc tracer les graphes de la somme des équilibres du système (1) avec et sans prédateurs et constater cette saturation à lorsque la condition x_0^* + y_0^* &gt; \\frac{m}{n} est validée.\nPour plot on va simuler avec odeint pendant un temps assez large pour atteindre l’équilibre :\n\n\nCode\n#Définition d'une fonction qui prend en compte le changement de migration:\ndef a(etat,t,param,i):\n    x,y,z=etat\n    b=i\n    rx,Kx,ry,Ky,gx,gy,p,n,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-p*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-p*y*z,z*(n*(x+y)-m)]\n    return [xdot,ydot,zdot]\n\n#Définition du modèle sans prédateurs:\ndef aug(etat,t,param,i):\n    rx,Kx,ry,Ky,gx,gy=param\n    b=i\n    x,y=etat\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx),ry*y*(1-y/Ky)+b*(x/gx-y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\np1=1\nm11=1\nn11=0.25\nm12=3\nn12=2\n\nparam11=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,p1,n11,m11])\nparam12=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,p1,n12,m12])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\np2=1\nm21=1\nn21=0.3278\nm22=1\nn22=0.335\n\nparam21=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,p2,n21,m21])\nparam22=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,p2,n22,m22])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\np3=0.5\nm31=1\nn31=0.2832\nm32=1\nn32=0.289\n\nparam31=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,p3,n31,m31])\nparam32=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,p3,n32,m32])\n\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\np4=1\nm41=1\nn41=0.436\nm42=1\nn42=0.45\n\nparam41=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,p4,n41,m41])\nparam42=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,p4,n42,m42])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt=np.arange(0,1000,0.01)\n\n#Condition initiale:\ne0=[1,1,1]\n\n#Figure:\nfig,ax=plt.subplots(2,4,figsize=(12,9))\nplt.subplots_adjust(wspace=0.4,hspace=0.3)\n\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0,4,0.01):\n    s11=odeint(a,e0,t,args=(param11,i)) #On calcule pour chaque beta l'équilibre\n    ax[0][0].plot(i,s11[-1][0]+s11[-1][1],marker='.',markersize=3,color='C0')\n    s12=odeint(a,e0,t,args=(param12,i))\n    ax[0][1].plot(i,s12[-1][0]+s12[-1][1],marker='.',markersize=3,color='C0')\n    \n    s11sp=odeint(aug,e0[0:2],t,args=(param11[0:6],i))\n    ax[0][0].plot(i,s11sp[-1][0]+s11sp[-1][1],marker='.',markersize=1,color='0.7')\n    s12sp=odeint(aug,e0[0:2],t,args=(param12[0:6],i))\n    ax[0][1].plot(i,s12sp[-1][0]+s12sp[-1][1],marker='.',markersize=1,color='0.7')\n    \n    \n    s21=odeint(a,e0,t,args=(param21,i))\n    ax[0][2].plot(i,s21[-1][0]+s21[-1][1],marker='.',markersize=3,color='C0')             \n    s22=odeint(a,e0,t,args=(param22,i))\n    ax[0][3].plot(i,s22[-1][0]+s22[-1][1],marker='.',markersize=3,color='C0')              \n    \n    s21sp=odeint(aug,e0[0:2],t,args=(param21[0:6],i))\n    ax[0][2].plot(i,s21sp[-1][0]+s21sp[-1][1],marker='.',markersize=1,color='0.7')\n    s22sp=odeint(aug,e0[0:2],t,args=(param22[0:6],i))\n    ax[0][3].plot(i,s22sp[-1][0]+s22sp[-1][1],marker='.',markersize=1,color='0.7')\n    \n    \n    s31=odeint(a,e0,t,args=(param31,i))\n    ax[1][0].plot(i,s31[-1][0]+s31[-1][1],marker='.',markersize=3,color='C0')\n    s32=odeint(a,e0,t,args=(param32,i))\n    ax[1][1].plot(i,s32[-1][0]+s32[-1][1],marker='.',markersize=3,color='C0')\n    \n    s31sp=odeint(aug,e0[0:2],t,args=(param31[0:6],i))\n    ax[1][0].plot(i,s31sp[-1][0]+s31sp[-1][1],marker='.',markersize=1,color='0.7')\n    s32sp=odeint(aug,e0[0:2],t,args=(param32[0:6],i))\n    ax[1][1].plot(i,s32sp[-1][0]+s32sp[-1][1],marker='.',markersize=1,color='0.7')\n    \nfor i in np.arange(0,10,0.01):\n    s41=odeint(a,e0,t,args=(param41,i))\n    ax[1][2].plot(i,s41[-1][0]+s41[-1][1],marker='.',markersize=3,color='C0')\n    s42=odeint(a,e0,t,args=(param42,i))\n    ax[1][3].plot(i,s42[-1][0]+s42[-1][1],marker='.',markersize=3,color='C0')\n    \n    s41sp=odeint(aug,e0[0:2],t,args=(param41[0:6],i))\n    ax[1][2].plot(i,s41sp[-1][0]+s41sp[-1][1],marker='.',markersize=1,color='0.7')\n    s42sp=odeint(aug,e0[0:2],t,args=(param42[0:6],i))\n    ax[1][3].plot(i,s42sp[-1][0]+s42sp[-1][1],marker='.',markersize=1,color='0.7')\n\n#Plot de la droite Kx+Ky:    \nxt=np.arange(0,4,0.01)\nxt2=np.arange(0,4,0.01)\nxt3=np.arange(0,10,0.01)\n\nax[0][0].plot(xt,(Kx1+Ky1)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt2,(Kx1+Ky1)*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[0][2].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][3].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt2,(Kx3+Ky3)*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt,(Kx3+Ky3)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][2].plot(xt3,(Kx4+Ky4)*np.ones_like(xt3),linestyle='dashed',color='k',markersize='6')\nax[1][3].plot(xt3,(Kx4+Ky4)*np.ones_like(xt3),linestyle='dashed',color='k',markersize='6')\n\n#Plot de m/n:\nax[0][0].plot(xt,m11/n11*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[0][1].plot(xt,m12/n12*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[0][2].plot(xt,m21/n21*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[0][3].plot(xt,m22/n22*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[1][0].plot(xt,m31/n31*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[1][1].plot(xt,m32/n32*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')         \nax[1][2].plot(xt3,m41/n41*np.ones_like(xt3),linestyle='dashed',color='g',markersize='6')\nax[1][3].plot(xt3,m42/n42*np.ones_like(xt3),linestyle='dashed',color='g',markersize='6')  \n\n#Légendes:\nax[0][0].set_xlabel('β')\nax[0][1].set_xlabel('β')\nax[0][2].set_xlabel('β')\nax[0][3].set_xlabel('β')\nax[1][0].set_xlabel('β')\nax[1][1].set_xlabel('β')\nax[1][2].set_xlabel('β')\nax[1][3].set_xlabel('β')\n\nax[0][0].set_ylabel('Population')\nax[0][0].plot(0,0,color='0.8',label='Somme des équilibres sans prédateurs')\nax[0][0].plot(0,0,color='C0',label='Somme des équilibres avec prédateurs')\nax[0][0].plot(0,0,linestyle='dashed',color='g',markersize='6',label='m/n')\nax[0][0].plot(0,0,linestyle='dashed',color='k',markersize='6',label='Kx+Ky')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(6.55, -0.5, 0.5, 0.5),fontsize=10)\n\n#Titres:\nax[0][0].set_title('Déflation')\nax[0][1].set_title('Déflation')\nax[0][2].set_title('Les deux')\nax[0][3].set_title('Déflation')\nax[1][0].set_title('Inflation')\nax[1][1].set_title('Déflation')\nax[1][2].set_title('Inflation')\nax[1][3].set_title('Déflation')\n\n\nText(0.5, 1.0, 'Déflation')\n\n\n\n\n\nDans ces simulations on a posé les 4 situations possibles de courbes comme avec le modèle précédent avec, soit \\frac{m}{n} plus grand que la somme des capacités soit \\frac{m}{n} plus petits que la somme des capacités. On se retrouve donc avec 8 profils différents. On aurait pu inclure les profils où \\frac{m}{n} est complètement au dessus ou en dessous mais ils n’avaient pas grand intérêt.\nLorsque les prédateurs sont présents, ie que x^*_0(\\beta)+y^*_0(\\beta)&gt;\\frac{m}{n}, c’est à dire quand la courbe grise est au dessus de la droite verte on a bien que x^*(\\beta)+y^*(\\beta)=\\frac{m}{n}. Quand ils sont absents (la courbe grise est en dessous de la droite verte) on observe bien que x^*(\\beta)=x_0^*(\\beta), y^*(\\beta)=y^*_0(\\beta) (les courbes bleu et grise sont confondues).\nOn observe que lorsqu’on a \\frac{m}{n} &lt; K_x + K_y on a toujours un système déflationiste, en effet on a alors que soit le système sans prédateurs avait une somme au dessus de \\frac{m}{n} et on ainsi que l’équilibre vaut \\frac{m}{n} (qui est par l’observation sous K_x + K_y et donc déflation) soit le système était en dessous de \\frac{m}{n} et donc on a la somme correspondant à l’équilibre sans prédateurs mais qui est en dessous de K_x + K_y par observation.\nCes graphiques traduisent bien l’effet de l’ajout des prédateurs dans un système : si celui ci est déja déflationiste il le reste, si celui ci était inflationiste et déflationiste ou complètement inflationiste il peut devenir déflationiste.\nAutrement dit si on reprend les conditions sur les inflations et déflations posées précédemment on a :\nSi le système sans prédateurs est de base déflationiste alors le système avec prédateurs est aussi déflationiste (avec survie ou pas des prédateurs).\nAinsi d’après les conditions du modèle précédent on a que si \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} alors le système avec prédateurs est toujours déflationiste.\nDe plus, si \\frac{\\gamma_y}{\\gamma_x}&lt;\\frac{K_y}{K_x} alors on a soit un système inflationiste si \\frac{m}{n} &lt; K_x+K_y soit un système inflationiste et déflationiste mais moins inflationiste quand sans les prédateurs si \\frac{m}{n} &lt; (x^*+y^*)_{max}.\nEnfin si \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} alors si on a x^*(\\infty)+y^*(\\infty) &gt; \\frac{m}{n} &gt; K_x+K_y alors le système est inflationiste mais moins que son pendant sans prédateurs.\n\n\nEquilibre de la culture en fonction de \\gamma_x et \\gamma_y\nOn va maintenant voir l’évolution de l’équilibre dans la culture en fonction de \\gamma_x (le taux de migration) et de \\gamma_y (le taux de fuite):\n\n\nCode\n#On définit un modèle qui prend en compte le changement de b et un autre qui prend en compte le changement de gy\ndef a1(etat,t,param,h):\n    x,y,z=etat\n    rx,Kx,ry,Ky,b,gy,p,n,m = param\n    gx=h\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-p*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-p*y*z,z*(n*(x+y)-m)]\n    return xdot,ydot,zdot\n\ndef a2(etat,t,param,h):\n    x,y,z=etat\n    rx,Kx,ry,Ky,gx,b,p,n,m = param\n    gy=h\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-p*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-p*y*z,z*(n*(x+y)-m)]\n    return xdot,ydot,zdot\n\n#Paramètres Simulation b1: \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\nb1=1\ngy1=4\np1=1\nn1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,b1,gy1,p1,n1,m1])\n\n#Paramètres Simulation b2: \nrx2=0.5\nry2=1\nKx2=1\nKy2=2\nb2=1\ngy2=4\np2=1\nn2=1\nm2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,b2,gy2,p2,n2,m2])\n\n#Paramètres Simulation gy1: \nrx3=0.5\nry3=1\nKx3=2\nKy3=1\ngx3=0.5\nb3=1\np3=1\nn3=1\nm3=0.5\n\nparam_a3=np.array([rx3,Kx3,ry3,Ky3,gx3,b3,p3,n3,m3])\n\n#Paramètres Simulation gy2: \nrx4=0.5\nry4=1\nKx4=1\nKy4=2\ngx4=0.5\nb4=1\np4=1\nn4=1\nm4=0.5\n\nparam_a4=np.array([rx4,Kx4,ry4,Ky4,gx4,b4,p4,n4,m4])\n\n#Temps d'intégration:\nt1=np.arange(0,500,0.01)\n\n#Conditions initiales:\nx0=1\ny0=1\nz0=1\nc0=np.array([x0,y0,z0])\n\n#On trace la figure:\nfig1,ax=plt.subplots(2,2,figsize=(10,5))\n\n#Boucle qui met à jour b et simule à chaque fois l'équilibre :\nfor i in np.arange(0.01,3,0.01):\n    sa1=odeint(a1,c0,t1,args=(param_a1,i))\n    ax[0][0].plot(i,sa1[-1][0],marker='.',color='C0')\n    sa2=odeint(a1,c0,t1,args=(param_a2,i))\n    ax[0][1].plot(i,sa2[-1][0],marker='.',color='C0')\n\n#Boucle qui met à jour gy et simule l'équilibre:\nfor i in np.arange(0.01,5,0.01):\n    sa3=odeint(a2,c0,t1,args=(param_a3,i))\n    ax[1][0].plot(i,sa3[-1][0],marker='.',color='C0')\n    sa4=odeint(a2,c0,t1,args=(param_a4,i))\n    ax[1][1].plot(i,sa4[-1][0],marker='.',color='C0')\n\n#On plot la ligne correspondant à Kx\nxt=np.arange(0.01,3,0.01)\nxt2=np.arange(0.01,5,0.01)\nax[0][0].plot(xt,Kx1*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt,Kx2*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt2,Kx3*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt2,Kx4*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\n\n##Légendes et titres:\nfig1.suptitle(\"Simulation de l\\'équilibre dans la culture en fonction du taux de migration et du taux de fuite\")\n\n#Abssices:\nax[0][0].set_xlabel(\"Taux de migration, Ɣx\")\nax[0][1].set_xlabel(\"Taux de migration, Ɣx\")\nax[1][0].set_xlabel(\"Taux de fuite, Ɣy\")\nax[1][1].set_xlabel(\"Taux de fuite, Ɣy\")\n\n#Titre des sous figures:\nax[0][0].set_title(\"$K_x&gt;K_y$\")\nax[0][1].set_title(\"$K_x&lt;K_y$\")\nax[1][0].set_title(\"$K_x&gt;K_y$\")\nax[1][1].set_title(\"$K_x&lt;K_y$\")\n\n#Ordonnées:\nax[0][0].set_ylabel(\"Densité de pop.\")\nax[1][0].set_ylabel(\"Densité de pop.\")\n\n#Légende générale:\nax[0][0].plot(0,0,color='C0',label='Equilibre dans la culture')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(0.9, -0.69, 0.5, 0.5))\n\n#Ecartement des figures:\nplt.subplots_adjust(hspace=0.5)\n\n#Texte Kx:\nax[0][0].text(2.75,Kx1-0.2,'$K_x$')\nax[0][1].text(2.75,Kx2-0.1,'$K_x$')\nax[1][0].text(4.75,Kx3-0.2,'$K_x$')\nax[1][1].text(4.75,Kx4-0.1,'$K_x$')\n\n\nText(4.75, 0.9, '$K_x$')\n\n\n\n\n\nEn haut on observe l’équilibre en fonction du taux de migration. On voit que quelque soit la culture on a un équilibre qui est bien en dessous de la capactié biotique de la culture. La technique de l’augmentorium semble être efficace.\nOn observe que quand le taux de migration est fort (\\gamma_x petit) alors on a un équilibre dans la culture faible et celui augmente au fur et à mesure que le taux de migration ralentit. Mettre de l’effort dans la tache de ramasser les fruits et les séquestrer n’est donc pas vain.\nMaintenant quand on regarde le taux de fuite, s’il est élevé (valeur petite de \\gamma_y) alors on a un équilibre dans la culture plus grand que si il est faible. Plus \\gamma_y est grand (et donc plus le taux de fuite est faible) moins l’équilibre dans la culture est élevé.\nCe paramètre est donc crucial et c’est quelque chose qu’il faut continuer d’améliorer (en mettant en place des sas, de la lumière à l’opposé de l’entrée pour attirer les ravageurs etc.).\n\n\n\nPrédation et naissances différentielles\nMaintenant on va considérer le modèle plus complexe de naissances (n) et de la prédation (p) différentes entre la culture et l’augentorium.\nCe postulat n’est pas annodin car on peut vraisemblablement penser que l’augmentorium fournit une structure positive à la croissance grâce à la grande concentration de ressources qu’il renferme et à son relatif cloisonnement de l’extérieur.\n\nSomme des équilibres des proies en fonction de \\beta\nPrécédemment on observait une saturation de la somme des proies à \\frac{m}{n}. Mais cette observation résultait de la trop forte simplification du modèle considéré. En considérant notre modèle actuel et en faisant l’hypothèse que z^* \\ne 0 alors on a la condition n_xx^*+n_yy^* = m.\nL’intuition mathématique, via le même raisonnement biologique précédent, est que l’invasion des prédateurs ie \\exists z^* &gt; 0 est vérifiée si seulement si n_xx_0^*(\\beta) + n_yy_0^*(\\beta)&gt;m où x_0^*(\\beta) et y_0^*(\\beta) sont les équilibres du système sans prédateurs.\nMontrons le mathématiquement pour \\beta = 0 et \\beta = +\\infty :\nPour \\beta =0, on a le système suivant :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{20}\nqui a l’équilibre implique que : \n\\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right)\n qui donne, via la condition z &gt; 0, après réarrangement: \nx^* = \\frac{K_x\\left(r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\\right)}{r_xp_yn_yK_y+r_yp_xn_xK_x}\n\\tag{21}\nPar l’expression de z^* on a K_x &gt; x^* autrement dit : \nK_x &gt; \\frac{K_x\\left(r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\\right)}{r_xp_yn_yK_y+r_yp_xn_xK_x}\n \n\\Leftrightarrow\n \nr_xp_yn_yK_y+r_yp_xn_xK_x &gt; r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\n \n\\Leftrightarrow\n \nr_yp_x(n_xK_x+n_yK_y) &gt; r_yp_xm \\Leftrightarrow n_xK_x + n_yK_y &gt; m\n\nOr x_0^*(0) = K_x et y_0^*(0) car ce ne sont que des croissances logistiques.\nAinsi la condition n_xx_0^*(0) + n_yy_0^*(0)&gt;m équivaut à n_xK_x + n_yK_y &gt; m\nLa condition d’un équilibre positif implique bien cette condition d’invasion.\nPour \\beta =+\\infty, on va simplifier le système (1).\nOn pose N = x+y et en faisant tendre \\beta \\to +\\infty et en considérant \\dot x - \\dot y on a forcément \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\nCette condition permet de dire que \\frac{N}{\\gamma_x+\\gamma_y} = \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\n\n\\dot N = \\frac{r_xx\\gamma_x}{\\gamma_x}\\left(1-\\frac{x\\gamma_x}{K_x\\gamma_x}\\right) + \\frac{r_yy\\gamma_y}{\\gamma_y}\\left(1-\\frac{y\\gamma_y}{K_y\\gamma_y}\\right) - z\\left(\\frac{p_xx\\gamma_x}{\\gamma_x}+\\frac{p_yy\\gamma_y}{\\gamma_y}\\right)\n\nEn réarrangeant l’expression de droite en prenant en compte la condition précédente on a: \n\\dot N = \\underbrace{\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}}_{r_N} N \\left(1 - N \\underbrace{\\frac{\\left(\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}\\right)}{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}}_{\\frac{1}{K_N}} \\right) - zN\\underbrace{\\left(\\frac{p_x\\gamma_x+p_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right)}_{p_N}\n\nPour \\dot z on a : \n\\dot z = z\\left(\\frac{n_xx\\gamma_x}{\\gamma_x}+\\frac{n_yy\\gamma_y}{\\gamma_y}-m\\right)\n \n\\Leftrightarrow\n \n\\dot z = z\\left( N \\underbrace{\\frac{n_x\\gamma_x+n_y\\gamma_y}{\\gamma_x+\\gamma_y}}_{n_N} - m\\right)\n\nLe système (1) devient donc pour \\beta \\to +\\infty :\n \\left\\{\\begin{array}{l}\n\\dot N = r_N N \\left(1-\\frac{N}{K_N}\\right) - p_NzN \\\\\n\\dot z = z\\left(n_N N - m\\right)\n\\end{array}\\right.\n\\tag{22}\nqui est exactement un système proie-prédateur de Lotka-Volterra.\nSi \\exists z^* &gt; 0 on a à la fois N^*=\\frac{m}{n_N} et aussi N^* &lt; K_N et donc on a la condition suivante, s’il existe un équilibre non nul, K_N n_N &gt; m.\nOr, en prenant n_xx_0^*(+\\infty) + n_yy_0^*(+\\infty) &gt; m on a : \n\\frac{n_xx_0^*(+\\infty)\\gamma_x}{\\gamma_x} + \\frac{n_yy_0^*(+\\infty)\\gamma_y}{\\gamma_y} &gt; m\n \n\\Leftrightarrow\n \n\\frac{N^*_0}{\\gamma_x+\\gamma_y}(n_x\\gamma_x+n_y\\gamma_y) &gt; m\n\navec N^*_0 qui est l’équilibre du système de L-V pour z=0. Cet équilibre est trivialement égal à K_N et donc on a: \nK_N n_N &gt; m\n\nNos intuitions biologiques étant validées mathématiquement pour \\beta = 0 et \\beta = +\\infty on peut logiquement se dire que c’est aussi le cas pour un \\beta \\in ]0,+\\infty].\nOn va simuler numériquement la somme des équilibres des proies du système (1) par la même méthode que précédemment en faisant aussi aparaître la courbe n_xx^*_0+n_yy^*_0 et m ainsi que la somme des équilibres des proies du système (1) sans prédateurs pour pouvoir voir quand on a disparition des prédateurs et donc x^*_0 + y^*_0 = x^*+y^*.\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat,t,param,i):\n    x,y,z=etat\n    b=i\n    rx,Kx,ry,Ky,gx,gy,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Définition du modèle sans prédateurs:\ndef aug2(etat,t,param,i):\n    rx,Kx,ry,Ky,gx,gy=param\n    b=i\n    x,y=etat\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx),ry*y*(1-y/Ky)+b*(x/gx-y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm11=1\nm12=1.5\n\nparam11p=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,px1,py1,nx1,ny1,m11])\nparam11sp=param11p[0:6]\nparam12p=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,px1,py1,nx1,ny1,m12])\nparam12sp=param12p[0:6]\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\npx2=0.5\npy2=3\nnx2=0.5\nny2=1\nm21=1\nm22=1.9\n\nparam21p=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,px2,py2,nx2,ny2,m21])\nparam21sp=param21p[0:6]\nparam22p=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,px2,py2,nx2,ny2,m22])\nparam22sp=param22p[0:6]\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\npx3=1\npy3=0.5\nnx3=0.5\nny3=1\nm31=1.5\nm32=2.45\n\nparam31p=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,px3,py3,nx3,ny3,m31])\nparam31sp=param31p[0:6]\nparam32p=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,px3,py3,nx3,ny3,m32])\nparam32sp=param32p[0:6]\n\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\npx4=3\npy4=0.5\nnx4=0.5\nny4=1\nm41=1.4\nm42=1.82\n\nparam41p=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,px4,py4,nx4,ny4,m41])\nparam41sp=param41p[0:6]\nparam42p=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,px4,py4,nx4,ny4,m42])\nparam42sp=param42p[0:6]\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt=np.arange(0,800,0.01)\n\n#Condition initiale:\ne0p=[1,1,1]\ne0sp=[1,1]\n\n#Figure:\nfig,ax=plt.subplots(2,4,figsize=(20,10))\nplt.subplots_adjust(hspace=0.4)\n\nxt=np.arange(0,4,0.01)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0,4,0.01):\n    s1p=odeint(a,e0p,t,args=(param11p,i)) #On calcule pour chaque beta l'équilibre\n    s1sp=odeint(aug2,e0sp,t,args=(param11sp,i))\n    ax[0][0].plot(i,s1p[-1][0]+s1p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][0].plot(i,nx1*s1sp[-1][0]+ny1*s1sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][0].plot(xt,m11*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][0].plot(i,s1sp[-1][0]+s1sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s1p=odeint(a,e0p,t,args=(param12p,i)) #On calcule pour chaque beta l'équilibre\n    s1sp=odeint(aug2,e0sp,t,args=(param12sp,i))\n    \n    ax[0][1].plot(i,s1p[-1][0]+s1p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][1].plot(i,nx1*s1sp[-1][0]+ny1*s1sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][1].plot(xt,m12*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][1].plot(i,s1sp[-1][0]+s1sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    \n    s2p=odeint(a,e0p,t,args=(param21p,i)) #On calcule pour chaque beta l'équilibre\n    s2sp=odeint(aug2,e0sp,t,args=(param21sp,i))\n    \n    ax[0][2].plot(i,s2p[-1][0]+s2p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][2].plot(i,nx2*s2sp[-1][0]+ny2*s2sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][2].plot(xt,m21*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][2].plot(i,s2sp[-1][0]+s2sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s2p=odeint(a,e0p,t,args=(param22p,i)) #On calcule pour chaque beta l'équilibre\n    s2sp=odeint(aug2,e0sp,t,args=(param22sp,i))\n    \n    ax[0][3].plot(i,s2p[-1][0]+s2p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][3].plot(i,nx2*s2sp[-1][0]+ny2*s2sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][3].plot(xt,m22*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][3].plot(i,s2sp[-1][0]+s2sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    \n    s3p=odeint(a,e0p,t,args=(param31p,i)) #On calcule pour chaque beta l'équilibre\n    s3sp=odeint(aug2,e0sp,t,args=(param31sp,i))\n    \n    ax[1][0].plot(i,s3p[-1][0]+s3p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][0].plot(i,nx3*s3sp[-1][0]+ny3*s3sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][0].plot(xt,m31*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][0].plot(i,s3sp[-1][0]+s3sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s3p=odeint(a,e0p,t,args=(param32p,i)) #On calcule pour chaque beta l'équilibre\n    s3sp=odeint(aug2,e0sp,t,args=(param32sp,i))\n    \n    ax[1][1].plot(i,s3p[-1][0]+s3p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][1].plot(i,nx3*s3sp[-1][0]+ny3*s3sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][1].plot(xt,m32*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][1].plot(i,s3sp[-1][0]+s3sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    \n    s4p=odeint(a,e0p,t,args=(param41p,i)) #On calcule pour chaque beta l'équilibre\n    s4sp=odeint(aug2,e0sp,t,args=(param41sp,i))\n   \n    ax[1][2].plot(i,s4p[-1][0]+s4p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][2].plot(i,nx4*s4sp[-1][0]+ny4*s4sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][2].plot(xt,m41*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][2].plot(i,s4sp[-1][0]+s4sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s4p=odeint(a,e0p,t,args=(param42p,i)) #On calcule pour chaque beta l'équilibre\n    s4sp=odeint(aug2,e0sp,t,args=(param42sp,i))\n    \n    ax[1][3].plot(i,s4p[-1][0]+s4p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][3].plot(i,nx4*s4sp[-1][0]+ny4*s4sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][3].plot(xt,m42*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][3].plot(i,s4sp[-1][0]+s4sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n#Plot de la droite Kx+Ky:    \nax[0][0].plot(xt,(Kx1+Ky1)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt,(Kx1+Ky1)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][2].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][3].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt,(Kx3+Ky3)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt,(Kx3+Ky3)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][2].plot(xt,(Kx4+Ky4)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][3].plot(xt,(Kx4+Ky4)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\n\n#Légendes:\nax[0][0].set_xlabel('β')\nax[0][1].set_xlabel('β')\nax[0][2].set_xlabel('β')\nax[0][3].set_xlabel('β')\nax[1][0].set_xlabel('β')\nax[1][1].set_xlabel('β')\nax[1][2].set_xlabel('β')\nax[1][3].set_xlabel('β')\n\nax[0][0].set_ylabel('Population')\nax[0][0].plot(0,0,color='0.8',label='Somme des équilibres sans prédateurs')\nax[0][0].plot(0,0,color='C0',label='Somme des équilibres avec prédateurs')\nax[0][0].plot(0,0,linestyle='dashed',color='r',markersize='6',label='nx*x+ny*y')\nax[0][0].plot(0,0,linestyle='dashed',color='g',markersize='6',label='m')\nax[0][0].plot(0,0,linestyle='dashed',color='k',markersize='6',label='Kx+Ky')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(5.2, -0.5, 0.5, 0.5),fontsize=10)\n\n#Titres:\nax[0][0].set_title('Déflation')\nax[0][1].set_title('Déflation')\nax[0][2].set_title('Déflation')\nax[0][3].set_title('Les deux')\nax[1][0].set_title('Déflation')\nax[1][1].set_title('Les deux')\nax[1][2].set_title('Déflation')\nax[1][3].set_title('Les deux')\n\n\nText(0.5, 1.0, 'Les deux')\n\n\n\n\n\nOn observe que si m est toujours plus grand que n_xx_0^*+n_yy_0^* alors les prédateurs disparaissent et on a que la somme des équilibres est égale à x_0^*+y_0^* (la courbe bleu est tout le temps confondue avec la courbe grise).\nEnsuite, quand m est toujours plus petit que n_xx_0^*+n_yy_0^* alors les prédateurs sont toujours en vie et on a que la somme des équilibres est égale à x^*+y^*.\nEnfin, quand m croise n_xx_0^*+n_yy_0^* on observe que la somme des équilibres est à la fois x^*+y^* et x_0^*+y_0^*. Si n_xx_0^*+n_yy_0^* est croissant alors on a d’abord que la somme des équilibres est égale à x_0^*+y_0^* puis x^*+y^* et inversement si n_xx_0^*+n_yy_0^* est décroissante.\n\n\nEquilibre de la culture en fonction de \\gamma_x et \\gamma_y\nOn va maintenant tracer l’équilibre dans la culture en fonction du taux de migration et de fuite.\n\n\nCode\n#On définit un modèle qui prend en compte le changement de b et un autre qui prend en compte le changement de gy\ndef a1(etat,t,param,i):\n    x,y,z=etat\n    gx=i\n    rx,Kx,ry,Ky,b,gy,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\ndef a2(etat,t,param,i):\n    x,y,z=etat\n    gy=i\n    rx,Kx,ry,Ky,gx,b,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Paramètres Simulation b1: \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\nb1=1\ngy1=4\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,b1,gy1,px1,py1,nx1,ny1,m1])\n\n#Paramètres Simulation b2: \nrx2=0.5\nry2=1\nKx2=1\nKy2=2\nb2=1\ngy2=4\npx2=0.5\npy2=1\nnx2=0.5\nny2=1\nm2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,b2,gy2,px2,py2,nx2,ny2,m2])\n\n#Paramètres Simulation gy1: \nrx3=0.5\nry3=1\nKx3=2\nKy3=1\ngx3=0.5\nb3=1\npx3=0.5\npy3=1\nnx3=0.5\nny3=1\nm3=0.5\n\nparam_a3=np.array([rx3,Kx3,ry3,Ky3,gx3,b3,px3,py3,nx3,ny3,m3])\n\n#Paramètres Simulation gy2: \nrx4=0.5\nry4=1\nKx4=1\nKy4=2\ngx4=0.5\nb4=1\npx4=0.5\npy4=1\nnx4=0.5\nny4=1\nm4=0.5\n\nparam_a4=np.array([rx4,Kx4,ry4,Ky4,gx4,b4,px4,py4,nx4,ny4,m4])\n\n#Temps d'intégration:\nt1=np.arange(0,500,0.01)\n\n#Conditions initiales:\nx0=1\ny0=1\nz0=1\nc0=np.array([x0,y0,z0])\n\n#On trace la figure:\nfig1,ax=plt.subplots(2,2,figsize=(10,5))\n\n#Boucle qui met à jour b et simule à chaque fois l'équilibre :\nfor i in np.arange(0.01,3,0.01):\n    sa1=odeint(a1,c0,t1,args=(param_a1,i))\n    ax[0][0].plot(i,sa1[-1][0],marker='.',color='C0')\n    sa2=odeint(a1,c0,t1,args=(param_a2,i))\n    ax[0][1].plot(i,sa2[-1][0],marker='.',color='C0')\n\n#Boucle qui met à jour gy et simule l'équilibre:\nfor i in np.arange(0.01,5,0.01):\n    sa3=odeint(a2,c0,t1,args=(param_a3,i))\n    ax[1][0].plot(i,sa3[-1][0],marker='.',color='C0')\n    sa4=odeint(a2,c0,t1,args=(param_a4,i))\n    ax[1][1].plot(i,sa4[-1][0],marker='.',color='C0')\n\n#On plot la ligne correspondant à Kx\nxt=np.arange(0.01,3,0.01)\nxt2=np.arange(0.01,5,0.01)\nax[0][0].plot(xt,Kx1*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt,Kx2*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt2,Kx3*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt2,Kx4*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\n\n##Légendes et titres:\nfig1.suptitle(\"Simulation de l\\'équilibre dans la culture en fonction du taux de migration et du taux de fuite\")\n\n#Abssices:\nax[0][0].set_xlabel(\"Taux de migration, Ɣx\")\nax[0][1].set_xlabel(\"Taux de migration, Ɣx\")\nax[1][0].set_xlabel(\"Taux de fuite, Ɣy\")\nax[1][1].set_xlabel(\"Taux de fuite, Ɣy\")\n\n#Titre des sous figures:\nax[0][0].set_title(\"$K_x&gt;K_y$\")\nax[0][1].set_title(\"$K_x&lt;K_y$\")\nax[1][0].set_title(\"$K_x&gt;K_y$\")\nax[1][1].set_title(\"$K_x&lt;K_y$\")\n\n#Ordonnées:\nax[0][0].set_ylabel(\"Densité de pop.\")\nax[1][0].set_ylabel(\"Densité de pop.\")\n\n#Légende générale:\nax[0][0].plot(0,0,color='C0',label='Equilibre dans la culture')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(0.9, -0.69, 0.5, 0.5))\n\n#Ecartement des figures:\nplt.subplots_adjust(hspace=0.5)\n\n#Texte Kx:\nax[0][0].text(2.75,Kx1-0.2,'$K_x$')\nax[0][1].text(2.75,Kx2-0.1,'$K_x$')\nax[1][0].text(4.75,Kx3-0.2,'$K_x$')\nax[1][1].text(4.75,Kx4-0.1,'$K_x$')\n\n\nText(4.75, 0.9, '$K_x$')\n\n\n\n\n\nOn observe des résultats similaires au système simplifié. L’analyse qui en résulte est la même.\nD’après les graphiques, l’effet de l’augmentorium sur l’équilibre dans la culture a l’air largement diminué dans tous les types de culture."
  },
  {
    "objectID": "modelaug.html#conclusion",
    "href": "modelaug.html#conclusion",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Conclusion",
    "text": "Conclusion\nCe modèle nous permet d’entrevoir mathématiquement pourquoi l’augmentorium est une technique efficace dans les cultures."
  },
  {
    "objectID": "modfinal.html#définition-du-modèle",
    "href": "modfinal.html#définition-du-modèle",
    "title": "Modèle proies-prédateurs structuré",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nDans ce modèle on va considérer 4 populations correspondant aux proies et aux prédateurs dans l’augmentorium et dans la culture.\nVoici le modèle:\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_1xz_1 \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_2yz_2 \\\\\n\\dot z_1 = z_1\\left(n_1x - m_1 \\right) + \\delta\\left(\\frac{z_2}{\\mu _2}-\\frac{z_1}{\\mu _1}\\right) \\\\\n\\dot z_2 = z_2\\left(n_2y - m_2 \\right) + \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\\end{array}\\right.\n\\tag{1}"
  },
  {
    "objectID": "modelesansmigrationass.html#inflation-et-déflation-du-système",
    "href": "modelesansmigrationass.html#inflation-et-déflation-du-système",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Inflation et déflation du système :",
    "text": "Inflation et déflation du système :\n \nPassons mainenant à un modèle qui prend en compte que les migrations peuvent êtres assymétriques."
  },
  {
    "objectID": "modelesansmigrationass.html#inflation-et-déflation-du-système-en-fonction-de-la-migration",
    "href": "modelesansmigrationass.html#inflation-et-déflation-du-système-en-fonction-de-la-migration",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Inflation et déflation du système en fonction de la migration",
    "text": "Inflation et déflation du système en fonction de la migration\nDans cette partie on va s’intéresser aux sommes des équilibres en fonction de \\beta.\nOn a déja plus ou moins tracé les différents profils de courbe qu’on peut obtenir pour cette partie (quand on a vérifié les propositions de conditions d’inflation/déflation) mais il existe un quatrième profil de courbe.\nOn va utiliser les mêmes méthodes que précédemment :\n\n\nCode\n#On redéinit la même fonction:\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n\n## Temps d'intégration :\n\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \n#Paramètres de la condition b):\nrx1 = 0.5\nry1 = 1  \nKx1 = 2\nKy1 = 1  \n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Paramètres condition c.1): \nrx2 = 0.4\nry2 = 1  \nKx2 = 1\nKy2 = 2  \n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n\n## Paramètres condition c.2): \nrx3 = 0.6\nry3 = 1  \nKx3 = 1  \nKy3 = 2  \n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres nouveau profil: \nrx4 = 0.5\nry4 = 2  \nKx4 = 0.5  \nKy4 = 1  \n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n\n## Condition initiale:\n\nc10 = [2, 0]\n\n## On crée la figure et l'axe:\n\nfig6, (ax7, ax8, ax9, ax10) = plt.subplots(1, 4, figsize = (9, 5))\nax7.set_title(\"Déflation\", fontsize = 8)\nax8.set_title(\"Inflation\", fontsize = 8)\nax9.set_title(\"Les deux\", fontsize = 8)\nax10.set_title(\"Inflation\", fontsize = 8)\n\nplt.subplots_adjust(wspace = 0.45) #On ajuste l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param1, i)) \n    ax7.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n\n    s2 = odeint(aug2, c10, t1, args = (param2, i))\n    ax8.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n    s3 = odeint(aug2, c10, t1, args = (param3, i))\n    ax9.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n    s4 = odeint(aug2, c10, t1, args = (param4, i))\n    ax10.plot(i, s4[-1][0] + s4[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax7.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax7.text(2.5, Kx1 + Ky1 + 0.01, '$K_x+K_y$')\n\nax8.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax8.text(2.5, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\nax9.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax9.text(2.5, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\n\nax10.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax10.text(2.5, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n\n## Légendes:\nax7.set_xlabel('β')\nax7.set_ylabel('Population')\nax7.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si on avait mis label dans la boucle la légende aurait été trop grande\n\nax8.set_xlabel('β')\n\nax9.set_xlabel('β')\n\nax10.set_xlabel('β')\n\n\n## On adapte la fenêtre:\nax7.set_ylim(2.4, 3.1)\nax8.set_ylim(2.95, 3.15)\nax9.set_ylim(2.9, 3.1)\nax10.set_ylim(1.25, 1.75)\n\n#On déplace la légende hors de la figure:\nax7.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5));\n\n\n\n\n\nOn observe quatre profils différents. Les trois premiers ont déjà été obtenus précédemment.\nLe quatrième correspond à un système inflationiste où le maximum d’inflation est atteint pour \\beta = +\\infty contrairement à l’autre profil d’inflation.\n \nPassons mainenant à un modèle qui prend en compte que les migrations peuvent êtres assymétriques."
  },
  {
    "objectID": "modfinal.html#réduction-du-modèle",
    "href": "modfinal.html#réduction-du-modèle",
    "title": "Modèle proies-prédateurs structuré",
    "section": "Réduction du modèle",
    "text": "Réduction du modèle\nL’augmentorium permet aux prédateurs de circuler presque librement entre les l’intérieur et l’extérieur. On va donc considérer que \\delta \\to +\\infty et voir si on peut se rapporter à un modèle plus simple.\nOn considère \\dot z_1 - \\dot z_2:\n\n\\dot z_1 - \\dot z_2 = z_1(n_1x-m_1)-z_2(n_2y-m_2) - \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\nLorsque \\delta = +\\infty on a \\dot z_1 - \\dot z_2 qui devient: \n\\dot z_1 - \\dot z_2 = - \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\net donc on a \\dot z_1 - \\dot z_2 \\to 0 \\Leftrightarrow \\frac{z_1}{\\mu _1} = \\frac{z_2}{\\mu _2}.\nSi on pose z=z_1+z_2 alors par la proposition précédente on a : \n\\frac{z}{\\mu _1+\\mu _2} = \\frac{\\frac{z_1\\mu _1}{\\mu _1}+\\frac{z_2\\mu _2}{\\mu _2}}{\\mu _1 +\\mu _2}=\\frac{z_1}{\\mu _1} = \\frac{z_2}{\\mu _2}\n\net donc : \n\\dot z = \\dot z_1 + \\dot z_2 = \\frac{z_1\\mu _1}{\\mu _1}\\left(n_1x - m_1 \\right) + \\frac{z_2\\mu _2}{\\mu _2}\\left(n_2y - m_2 \\right)\n \n\\Leftrightarrow\n \n\\dot z = \\frac{z}{\\mu _1 +\\mu _2}\\left(\\mu _1(n_1x-m_1)+\\mu _2(n_y-m_2)\\right)\n \n\\Leftrightarrow\n \n\\dot z = z \\left(\\underbrace{\\frac{\\mu _1n_1}{\\mu _1 +\\mu _2}}_{n_x}x + \\underbrace{\\frac{\\mu _2n_2}{\\mu _1 +\\mu _2}}_{n_y}y - \\underbrace{\\frac{\\mu _1m_1 + \\mu _2m_2}{\\mu _1 +\\mu _2}}_{m}\\right)\n\nOn a alors : \n\\dot z = z(n_xx+n_yy-m)\n\nMaintenant considérons les proies :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-\\frac{p_1xz_1\\mu _1}{\\mu _1} \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-\\frac{p_2yz_2\\mu _2}{\\mu _2} \\\\\n\\end{array}\\right.\n \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-\\overbrace{\\frac{p_1xz\\mu _1}{\\mu _1+\\mu _2}}^{p_x} \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-\\underbrace{\\frac{p_2yz\\mu _2}{\\mu _1+\\mu _2}}_{p_y}\n\\end{array}\\right.\n\nCeci donne donc le modèle d’augmentorium de la partie précédente :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{2}\nL’analyse de ce modèle est faite ici et toutes les propositions vues sont aussi applicables dans ce modèle.\nNous allons faire quelques simulations pour voir si le modèle suit les modèles précédents et voir son comportement pour des \\delta \\ne \\infty."
  },
  {
    "objectID": "modfinal.html#dynamique-du-modèle-non-réduit",
    "href": "modfinal.html#dynamique-du-modèle-non-réduit",
    "title": "Modèle proies-prédateurs structuré",
    "section": "Dynamique du modèle non réduit :",
    "text": "Dynamique du modèle non réduit :\nOn va voir la dynamique des 4 populations dans un premier temps :\n\n\nCode\n#Définition du modèle avec prédateurs:\n\ndef aug3(etat, t, param):\n    x, y, z1, z2 = etat\n    rx,Kx,ry,Ky,gx,gy,b,px,py,nx,ny,mx,my,d,mux,muy = param\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z1*x,\n    ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z2,\n    z1*(nx*x-mx)+d*(z2/muy-z1/mux),\n    z2*(ny*x-my)+d*(z1/mux-z2/muy)]\n    return s\n\n#Paramètres Simulation 1 : \nrx1=1\nry1=1.5\nKx1=3\nKy1=2\ngx1=0.5\ngy1=3\nb1=1\npx1=1\npy1=1.5\nnx1=1.5\nny1=2\nmx1=0.5\nmy1=0.5\nd1=1\nmux1=1.5\nmuy1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,b1,px1,py1,nx1,ny1,mx1,my1,d1,mux1,muy1])\n\n#Paramètres Simulation 2 : \nrx2=0.5\nry2=1\nKx2=3\nKy2=2\ngx2=0.5\ngy2=3\nb2=1\npx2=1\npy2=1.5\nnx2=1\nny2=1.5\nmx2=0.5\nmy2=0.5\nd2=1\nmux2=1.5\nmuy2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,b2,px2,py2,nx2,ny2,mx2,my2,d2,mux2,muy2])\n\n#Temps d'intégration 1:\nt=np.arange(0,100,0.01)\n\n#Condition initiale de 1:\nx0=2\ny0=0\nz10=0.5\nz20=0\nc0=np.array([x0,y0,z10,z20])\n\n#Simulation 1:\ns1=odeint(aug3,c0,t,args=(param_a1,))\ns2=odeint(aug3,c0,t,args=(param_a2,))\n\n#Plot de la figure: \nfig,(ax,ax1) = plt.subplots(1,2,figsize=(14,5))\nfig.suptitle('Simulation du modèle final d\\'augmentorium')\nplt.subplots_adjust(wspace=0.2)\n\n#Plot de l'axe 1:\nax.plot(t,s1[:,0],color='C0',label='Ravageurs dans la culture')\nax.plot(t,s1[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax.plot(t,s1[:,2],color='C6',label='Prédateurs dans la culture')\nax.plot(t,s1[:,3],color='C9',label='Prédateurs dans l\\'augmentorium')\n\n#Plot de l'axe 1:\nax1.plot(t,s2[:,0],color='C0',label='Ravageurs dans la culture')\nax1.plot(t,s2[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax1.plot(t,s2[:,2],color='C6',label='Prédateurs dans la culture')\nax1.plot(t,s2[:,3],color='C9',label='Prédateurs dans l\\'augmentorium')\n\n#Légendes et titres:\nax.set_ylabel('Population, x,y,z1,z2')\nax.legend(fontsize=8)\nax.grid()\nax.set_xlabel('Temps, t')\nax.set_title('Coexistence des quatres populations',fontsize=7.5)\n\nax1.set_ylabel('Population, x,y,z1,z2')\nax1.legend(fontsize=8)\nax1.grid()\nax1.set_xlabel('Temps, t')\nax1.set_title('Disparition des prédateurs',fontsize=7.5)\n\n\nText(0.5, 1.0, 'Disparition des prédateurs')\n\n\n\n\n\nOn observe deux situations, l’une avec un équilibre de coexistence des quatres populations et l’autre avec disparition des preédateurs."
  }
]