[
  {
    "objectID": "contexte.html",
    "href": "contexte.html",
    "title": "Contexte",
    "section": "",
    "text": "L’augmentorium est un outil ressemblant à une tente placée dans les cultures afin d’y entreposer des fruits ou des légumes attaqués par des ravageurs.\n\nDescription de la structure\n\n\n\n\nAugmentorium en culture; Photo: J-P Deguine, Cirad\n\n\n\nL’augmentorium possède une ouverture pour entreposer les fruits et une grille afin de libérer les prédateurs de ces ravageurs (plus petits).\nL’augmentorium peut être enterré, afin de préserver d’une sortie des larves de ravageurs par le bas.\nNous observons aussi sur les modèles de plus haute génération des sas ou bien le déplacement de la grille (et donc de la lumière) à l’opposé de l’ouverture.\n\n\nAvantage biologique\nCette méthode, prophylactique, permet de concentrer les ravageurs dans un espace clos presque sans migration vers l’extérieur.\nEn effet, la taille des mailles de la grille permet de cloisonner près de 100% des ravageurs et libérer jusqu’à 98% des prédateurs (Deguine JP (2011)).\nAinsi, cette méthode permet à la fois de casser le cycle de reproduction des ravageurs mais aussi d’augmenter le ratio prédateurs sur ravageurs dans les cultures et enfin de garantir aux ravageurs, et donc aux prédateurs, un lieu propice à la reproduction.\nCette méthode s’inscrit dans une démarche de lutte intégrée car elle permet de réduire les pesticides dans les cultures et se sert de l’effet direct de prédation des prédateurs sur les ravageurs.\n\n\nModélisation utilisée\nNotre modélisation se fonde sur des modèles de dynamique des populations. Nous nous baserons sur des systèmes d’équations différentielles.\nLes naissances des ravageurs seront simulées par une croissance logistique (modèle de Verhulst). Une étude de ce modèle est laissée au lecteur ici.\nLe modèle final est un modèle proie-prédateur en deux structures avec de la migration asymétrique entre chaque structure.\nNous allons tout au long de ce rapport suivre une évolution dans les modèles en les complexifiant peu à peu.\nLes premiers modèles ont déja été analysés, peu à peu les études se feront de plus en plus rare (ou du moins incomplètes).\n\n\nNotion d’inflation et de déflation\nPour mieux comprendre les analyses faites dans ce rapport il faut comprendre le concept d’inflation d’un système biologique.\nDans les années 70 certains articles (Freedman H. I. (1977)) mentionnent que lorsqu’on considère un modèle avec deux zones et dans chaque zone une population qui échange avec l’autre librement des individus, alors la somme des équilibres est le plus souvent différente de celle qu’elle serait si il n’y avait qu’une zone.\nC’est ce qu’on appelle le débat SLOSS (Single Large Or Several Small). On dit qu’une population structurée est caractérisée par un phénomène d’inflation si la somme de ses équilibres est plus grande que l’équilibre s’il n’y avait qu’une structure (et l’inverse pour la déflation).\nL’objectif de l’augmentorium est de provoquer une déflation du système chez les ravageurs.\nNous allons commencer avec un modèle de base qui permet de situer la démarche et le type d’analyse possible face à ce genre de modèles.\nC’est parti !\n\n\n\n\n\n\n\nReferences\n\nDeguine JP, Quilici S, Atiama-Nurbel T. 2011. “Net Choice Is Key to the Augmentorium Technique of Fruit Fly Sequestration and Parasitoid Release.” Crop Protection 30: 198–202.\n\n\nFreedman H. I., Waltman P. 1977. “Mathematical Models of Population Interactions with Dispersal.” J. Appl. Math. 32: 631–48.\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "À propos",
    "section": "",
    "text": "Ce site a été généré grâce à Github.\nCes pages ont été générées avec Quarto, Jupyter et Python (version 3.10.10).\nLes principaux modules utilisés sont NumPy, Matplotlib, SciPy et Plotly.\nQuelques animations ont été réalisées sous Geogebra.\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Présentation",
    "section": "",
    "text": "Les prochaines pages regroupent mes travaux à l’INRAE Sophia-Antipolis lors de mon stage de L2 du 22/05/2023 au 21/07/23 sous la tutelle de Ludovic Mailleret dans l’équipe M2P2.\nLe but de ce stage était de modéliser un augmentorium, une structure dans les cultures où l’on met les fruits pourris, pour la lutte biologique.\nPour cela nous nous baserons sur des modèles de dynamique des populations.\nLe rapport se structure ainsi :\nEnfin, nous discuterons d’un dernier modèle et de l’efficacité théorique de l’augmentorium en conclusion.\nTous les articles utilisés sont ici."
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "Perspectives et conclusion",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelesansmigrationass.html",
    "href": "modelesansmigrationass.html",
    "title": "Modèle logistique structuré sans migration asymétrique",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelsimpleaug.html",
    "href": "modelsimpleaug.html",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom matplotlib import cm\nimport plotly.express as px"
  },
  {
    "objectID": "ref.html",
    "href": "ref.html",
    "title": "Références",
    "section": "",
    "text": "Voici la liste des références qui m’ont été utiles lors de mon travail :\n\nThéorie:\n\nMurray, J. D. 1989. Contiuous Population Models for Single Species & Continous Models for Interacting Populations. In Mathematical Biology. Vol. 19 1–35 & 63–94.\nCours/TP par L. Mailleret.\nCours de la faculté de Nice.\n\nModélisation:\n\nArditi, R., Lobry, C., Sari, T., 2015. Is dispersal always beneficial to carrying capacity ? New insights from the multi-patch logistic equation. Theor. Popul. Biol. 106, 45–59.\nArditi, R., Lobry, C., Sari, T., 2018. Asymmetric dispersal in the multi-patch logistic equation. Theor. Popul. Biol. 120, 11–15.\nDaozhou Gao, Yuan Lou, 2022, Total biomass of a single population in two-patch environments. Theor. Popul. Biol. 146, 1-14.\nFreedman, H.I., Waltman, P., 1977. Mathematical models of population interactions with dispersal.SIAM J. Appl. Math. 32 (3), 631–648.\n\nBiologie:\n\nDeguine JP, Atiama-Nurbel T, Quilici S, 2011. Net choice is key to the augmentorium technique of fruit fly sequestration and parasitoid release. Crop Protection 30 : 198-202.\nDeguine JP, Ferron P, 2006. Protection des cultures, préservation de la biodiversité, respect de l’environnement.Cahiers Agricultures 15 : 307-11.\nDeguine, J.-P., Atiama-Nurbel, T., Douraguia, E., & Rousse, P. (2011). L’augmentorium, un outil de protection agroécologique des cultures. Cahiers Agricultures 20: 261–265.\nKehrli, Patrik & Lehmann, M. & Bacher, Sven. (2004). Mass-hatching devices: a new biocontrol technique to augment parasitoids. Biol. Control. 32. 191-199.\nJang, E. & Klungness, Lester & McQuate, Grant. (2007). Extension Of The Use Of Augmentoria For Sanitation In A Cropping System Susceptible To the Alien Terphritid Fruit Flies (diptera: Terphritidae) In Hawaii.. J. of Appl. Sci. and Environ. Manage. Vol 11 Num 2. 11.\nKlungness, L.M., Jang, E.B., Ronald, F.L., Vargas, R.I., Sugano, J.S., Fujitani, E., 2005. New sanitation techniques for controlling tephritid fruit flies (Diptera: Tephritidae) in Hawaii. J. Appl. Sci. Environ. Manage. 9, 5e14.\n\n\n\n\n\n\n\nReusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "modeleavecmigrationass.html",
    "href": "modeleavecmigrationass.html",
    "title": "Modèle logistique structuré avec migration asymétrique",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelcomplaug.html",
    "href": "modelcomplaug.html",
    "title": "Modèle complet avec proies structurées et prédateurs",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by-nc/4.0/"
  },
  {
    "objectID": "modfinal.html",
    "href": "modfinal.html",
    "title": "Modèle proies-prédateurs structuré",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint"
  },
  {
    "objectID": "modelesansmigrationass.html#définition-du-modèle",
    "href": "modelesansmigrationass.html#définition-du-modèle",
    "title": "Modèle logistique structuré sans migration asymétrique",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nNous posons le modèle suivant d’après Arditi R. (2015) : \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta(y-x)\\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta(x-y).\n\\end{array}\\right.\n\\tag{1}\navec :\n- x la population dans la première structure,\n- y la population dans la seconde structure,\n- r_x et r_y le taux de croissance dans les deux structures,\n- K_x et K_y les capacités de charge des deux structures,\n- \\beta la force de migration entre les structures.\nCe modèle ressemble peu à notre situation d’augmentorium car celui-ci est caractérisé par une migration asymétrique, il permet néanmoins de situer la démarche et les outils que nous allons utiliser pour étudier des modèles plus complexes."
  },
  {
    "objectID": "modelesansmigrationass.html#dynamique-du-modèle",
    "href": "modelesansmigrationass.html#dynamique-du-modèle",
    "title": "Modèle logistique structuré sans migration asymétrique",
    "section": "Dynamique du modèle",
    "text": "Dynamique du modèle\nNous allons tracer la dynamique de la population en fonction du temps pour se faire une première idée de comment se comporte la population.\nNous définissons le modèle sous Python :\n\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b = param\n    x, y = etat\n    s = [ rx * x * ( 1 - x/Kx ) + b * ( y - x ), \n    ry * y * ( 1 - y/Ky ) + b * ( x - y )]\n    return s \n\nNous allons utiliser odeint de Scipy afin de simuler une solution en fonction du temps. Il faut donc définir un temps d’intégration, des conditions initiales et les paramètres du modèle :\n\n## Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n## Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0 ,y0]\n\n## Paramètres: \nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\n\nparam_aug = np.array([rx, ry, Kx, Ky, b])\n\n## Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n\nMaintenant que nous avons la simulation nous pouvons réprésenter la figure avec matplotlib :\n\nfig, ax = plt.subplots(1, 1, figsize = (7, 4 ))\n\nfig.suptitle('Dynamique des ravageurs dans le temps')\nax.plot(ti, s[:, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[:, 1], color = 'C0', label = 'augmentorium')\n\nax.grid() #Nous ajoutons la grille\nax.legend() #Nous ajoutons la légende\n\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n\n\n\n\nFigure 1: Dynamique du modèle\n\n\n\n\nCette simulation nous montre une hausse de la population dans l’augmentorium et une baisse de la population dans la culture.\nLes deux populations atteignent un équilibre qui semble stable (il se maintient dans le temps).\nDans le cas d’un augmentorium, nous voyons que le simple fait de débarasser les fruits et de les mettre dans un espace séparé de la culture ammène à une baisse de la population de ravageurs dans la culture."
  },
  {
    "objectID": "modelesansmigrationass.html#plan-de-phase",
    "href": "modelesansmigrationass.html#plan-de-phase",
    "title": "Modèle logistique structuré sans migration asymétrique",
    "section": "Plan de phase",
    "text": "Plan de phase\n\nEquilibres et stabilités\nNous allons tracer le plan de phase associé à ce système pour voir les équilibres et leurs stabilités.\nA l’équilibre nous avons par définition \\dot x = 0 et \\dot y =0 ce qui donne :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta(y^*-x^*) \\Leftrightarrow  y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right)\\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta(x^*-y^*) \\Leftrightarrow  x^*=r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\n\\end{array}\\right.\n\\tag{2}\navec x^* et y^* la valeur des équilibres.\nAinsi, les deux isoclines correspondent à des paraboles. Celles-ci se croisent trivialement en (0,0) et dans le quadrant positif en (x^*,y^*).\nPour calculer (x^*,y^*) nous allons utiliser l’expression de x^* trouvée en (2) que nous allons rentrer dans l’équation de y^* :\nComme x^* = r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right) nous avons:\n\ny^* = r_x\\left[r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)\\right]\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{r_yy^*\\left(\\frac{1}{r_y}-\\frac{1}{\\beta}+\\frac{y^*}{\\beta K_y}\\right)}{\\beta K_x}\\right)\n \n\\Leftrightarrow\n \ny^* = y^* - \\frac{r_yy^*}{\\beta} + \\frac{r_y{y^*}^2}{\\beta K_y} - \\frac{r_xy^*}{\\beta} + \\frac{r_xr_yy^*}{\\beta^2} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_y} + \\\\[.2cm]\n\\frac{r_x{y^*}^2}{\\beta K_x} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\frac{r_xr_y{y^*}^2}{\\beta^2 K_x} + \\\\[.2cm]\n\\frac{r_xr_y^2{y^*}^2}{\\beta^3 K_x} - \\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_x K_y} + \\frac{r_xr_y{y^*}^3}{\\beta^2 K_xK_y} - \\\\[.2cm]\n\\frac{r_xr_y^2{y^*}^3}{\\beta^3 K_xK_y} + \\frac{r_xr_y^2{y^*}^4}{\\beta^3K_xK_y^2}\n \n\\Leftrightarrow\n \ny^*\\left(- \\frac{r_y}{\\beta} - \\frac{r_x}{\\beta} + \\frac{r_xr_y}{\\beta^2}\\right) + \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y} - \\frac{r_xr_y}{\\beta^2 K_y} + \\frac{r_x}{\\beta K_x} - 2\\frac{r_xr_y}{\\beta^2 K_x} + \\frac{r_xr_y^2}{\\beta^3 K_x} \\right) + \\\\[.2cm]\n2{y^*}^3\\left( \\frac{r_xr_y}{\\beta^2 K_xK_y} - \\frac{r_xr_y^2}{\\beta^3 K_xK_y} \\right) +\n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_xK_y^2} = 0\n\nCe qui donne après réarrangement : \ny^*\\left(\\frac{1}{\\beta}\\left[\\frac{r_xr_y}{\\beta} - r_y -r_x\\right]\\right)+ \\\\[.2cm]\n{y^*}^2\\left(\\frac{r_y}{\\beta K_y}\\left[1-\\frac{r_x}{\\beta}\\right]+\\frac{r_x}{\\beta K_x}\\left[1-2\\frac{r_y}{\\beta}+\\frac{r_y^2}{\\beta^2}\\right]\\right)+\\\\[.2cm]\n2{y^*}^3\\left(\\frac{r_xr_y}{\\beta^2 K_xK_y}\\left[1-\\frac{r_y}{\\beta}\\right]\\right) +\n{y^*}^4 \\frac{r_xr_y^2}{\\beta^3K_y^2K_x} = 0\n\\tag{3}\nCe polynôme est résoluble via numpy pour obtenir y^*:\n\n## Nous définissons un monome y, un polynôme p et nous prenons ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol = y * ((1/b) * (-rx - ry + rx*ry/b)) + \\\n(y**2) * (ry/(Ky * b) * (1 - (rx/b)) + rx/(b * Kx) * (1 - (2*ry/b) + ry**2 /(b**2))) + \\\n2 * (y**3) * ((rx * ry)/((b**2) * Kx * Ky)) * (1 - (ry/b)) + \\\n(y**4) * ((rx * (ry**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution que nous obtenons avec un masque booléen qui sélectionne les racines réelles et strictement positives:\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() &gt; 0)]\nyeq=sol[0].real\n\nNous déduisions x^* via sa définition par le système (2) :\n\nxeq = (ry * yeq * ((1/ry) - (1/b) + (yeq/(b * Ky)))).real\n\nAvec la valeur des équilibres nous allons maintenant tracer le plan de phase :\n\nfig, ax = plt.subplots(1, 1)\nfig.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax.plot(xt,xt * (1/b) * (rx * ((xt/Kx) - 1) + b), \n                    color = 'C2', label = '$\\dot x=0$')\nax.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax.plot(xt * (1/b) * (ry * ((xt/Ky) - 1) + b), xt,\n                    color = 'C3', label = '$\\dot y=0$')\nax.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## Nous réduisons la vue à ce qui nous intéresse:\nax.set_xlim(left = -.3, right = 3)\nax.set_ylim(top = 3, bottom = -.3)\n\n## Nous traçons la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## Nous nommons les axes:\nax.set_xlabel('$x$', fontsize = '12') ;\nax.set_ylabel('$y$', fontsize = '12') ;\n\n## Nous représentons les deux équilibres:\nax.plot(xeq.real, yeq.real, label = '$(x^*,y^*)$', marker = '.', markersize = 6, color = 'k')\nax.plot(0, 0, label = '$(0,0)$',\n                    marker = '.', markersize = 6, color = 'k')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax.quiver(X, Y, dx, dy, angles = 'xy', \n                    color = 'grey', scale = 80, width = 0.003);\n\n\n\n\nFigure 2: Plan de phase du modèle\n\n\n\n\nComme dit plus haut nous avons bien un croisement dans le quadrant positif qui correspond à l’équilibre (x^*,y^*).\nLes paraboles, en fonction des valeurs de leurs racines, peuvent croiser de différentes manières les axes des abscisses et des ordonnées.\nLe plan de phase peut donc présenter plusieurs profils, autres que celui tracé ici. Néanmoins, le croisement des paraboles dans le quadrant positif (l’équilibre non nul) est toujours présent quelque soit le profil.\nEn faisant apparaître le champ de vecteur nous pouvons déduire que l’équilibre en (0,0) est instable et l’équilibre en (x^*,y^*) est stable.\n\nStabilité mathématique des équilibres\nIl est clair que (0,0) est instable et (x^*,y^*) est stable (par le champ de vecteur).\nMathématiquement considérons la jacobienne de (1): \n\\mathbb{J}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy}{K_y}-\\beta\n\\end{pmatrix}\n\\tag{4}\net donc pour (0,0):\n\n\\mathbb{J_{\\vec{0}}}=\\begin{pmatrix}\n\\ r_x-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\beta\n\\end{pmatrix}\n\nLes valeurs propres \\lambda _1 et \\lambda _2 de cette matrice sont les solutions du polynôme caractéristique définit par : \n\\begin{vmatrix}\nr_x-\\beta-\\lambda & \\beta \\\\\n\\beta & r_y -\\beta -\\lambda \\\n\\end{vmatrix} = 0\n \n\\Leftrightarrow\n \n(r_x-\\beta-\\lambda)(r_y-\\beta - \\lambda) - \\beta^2 = 0\n \n\\Leftrightarrow\n \n\\lambda^2 + \\lambda\\left(2\\beta - r_x - r_y\\right) + r_xr_y - \\beta(r_x+r_y) = 0\n\nLe discriminant \\Delta est donc définit par :\n\n\\Delta = \\left(2\\beta - r_x - r_y\\right)^2 - 4(r_xr_y - \\beta[r_x+r_y]) \\\\\n= 4\\beta^2 -4\\beta(r_x +r_y) + r_x^2 +r_y^2 +2r_xr_y -4r_xr_y +4\\beta(r_x +r_y) \\\\ = 4\\beta^2 + (r_x-r_y)^2\n\nEt donc le spectre \\sigma de la jacobienne est :\n\n\\sigma_\\mathbb{J} = \\left(\\lambda_1 = \\frac{r_x+r_y-2\\beta-2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2},\\lambda_2=\\frac{r_x+r_y-2\\beta+2\\beta \\sqrt{\\frac{(r_x-r_y)^2}{4\\beta^2}+1}}{2}\\right)\n\net nous avons ainsi,\n\n\\lambda_2 &gt; 0\n\nDonc (0,0) est bien instable.\nPour (x^*,y^*) nous avons: \n\\mathbb{J_{x^*,y^*}}=\\begin{pmatrix}\n\\ r_x-\\frac{2r_xx^*}{K_x}-\\beta & \\beta \\\\\n\\ \\beta & r_y -\\frac{2r_yy^*}{K_y}-\\beta\n\\end{pmatrix}\n\\tag{5}\nor, nous avons aussi d’après (2):\n\n\\left\\{\\begin{array}{l}\n\\frac{y^*\\beta}{x^*} = \\beta - r_x + \\frac{r_xx^*}{K_x}   \\\\\n\\frac{x^*\\beta}{y^*} = \\beta - r_y + \\frac{r_yy^*}{K_y}  \n\\end{array}\\right.\n\nce qui simplifie la jacobienne en (x^*,y^*) à l’expression suivante :\n \\mathbb{J_{x^*,y^*}} = \\begin{pmatrix}\n\\ -\\frac{\\beta y^*}{x^*}-\\frac{r_xx^*}{K_x} & \\beta \\\\\n\\ \\beta & -\\frac{\\beta x^*}{y^*}-\\frac{r_yy^*}{K_y}\n\\end{pmatrix}\n\nIl est alors facile de vérifier que la trace de cette matrice est négative.\nLe déterminant quant à lui est donné par: \n\\alpha = \\left(\\frac{\\beta y^*}{x^*}+\\frac{r_xx^*}{K_x}\\right)\\left(\\frac{\\beta x^*}{y^*}+\\frac{r_yy^*}{K_y}\\right) - \\beta^2 \\\\\n= \\frac{\\beta r_y{y^*}^2}{x^*K_y} + \\frac{\\beta r_x {x^*}^2}{y^*K_x} + \\frac{r_xr_yx^*y^*}{K_xK_y} &gt; 0\n\nLe déterminant est lui positif et (x^*,y^*) est donc stable.\n\n\n\nAnalyse du plan de phase\nNous remarquons sur la Figure 2 que l’équilibre atteint n’est pas sur la droite x^*+y^*=K_x+K_y (en gris), nous appellerons cette droite d.\nSi le croisement des isoclines est au dessus de cette droite le système (1) subit une inflation et si le croisement est en dessous de cette droite il subit une déflation (voir contexte).\nNous voyons que la structuration de l’espace, et les migrations qui s’en suivent, perturbent les équilibres qui auraient dû, sans migration, être la somme de l’équilibre dans chaque strucuture qui est K_x+K_y (car les populations ont une croissance logistique).\nPlus généralement, nous pouvons montrer qu’en cas de mixité parfaite entre les deux structures (\\beta \\to \\infty) nous avons d’après Arditi R. (2015):\n\nx^*+y^* = K_x + K_y + (K_x-K_y)\\frac{r_xK_y-r_yK_x}{r_xK_y+r_yK_x}\n\\tag{6}\nCe qui montre qu’en général nous n’avons pas x^*+y^* = K_x + K_x.\nDe plus par (6), si K_y&lt;K_x et si r_xK_y&lt;r_yK_x alors x^*+y^* &lt; K_x+K_y ce qui nous intéresse particulièrement pour la lutte biologique.\nEnsuite, en faisant \\dot x + \\dot y = 0, dans le cas de l’équilibre, nous avons: \nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+r_yy^*\\left(1-\\frac{y^*}{K_y}\\right) = 0\n\\tag{7}\nAutrement dit les points d’équilibres vivent sur une ellipse (si nous ne modifions que \\beta ), que nous allons tracer avec contour :\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\n\nax.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left', fontsize = 8)\n\n## Nous plaçons les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et nous les relions aux axes:\nxc = np.arange(0, Kx, 0.01)\nax.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#Nous nommons les points:\nax.text(-0.2, Ky, '$K_y$')\nax.text(Kx, -0.2, '$K_x$')\n\n#Nous plaçons les points d'équilibres :\nys = np.arange(0, yeq, 0.01)\nxs = np.arange(0, xeq, 0.01)\n\nax.plot(xeq * np.ones_like(ys), ys, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\nax.plot(xs, yeq * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax.text(-0.2, yeq, '$y^*$')\nax.text(xeq, -0.2, '$x^*$')\n\ndisplay(fig)\n\n\n\n\nFigure 3: Plan de phase avec ellipse\n\n\n\n\nLes conditions d’inflations et de déflations suivantes proviennent de l’article d’Arditi R. (2018).\n\nPremière condition à un système déflationniste\nNous remarquons que le point (K_x,K_y) est en permanence sur la droite d qui coupe en permanence l’ellipse (en deux points) sauf pour une situation où d est tangente à l’ellipse.\nCe cas nous intéresse car il rend compte d’un système entièrement déflationniste en effet, l’équilibre étant necessairement sur l’ellipse, si celle-ci est tangente à la droite d, l’ensemble de l’ellipse est située dans la zone où x^*+y^*&lt;K_x+K_y.\nReprésentons le sur le plan de phase :\nNous redéfinissons les paramètres pour être dans le cas qui nous intéresse :\n\n## Paramètres: \nrxnew = 0.5\nrynew = 0.5\nKx = 2\nKy = 1\nb = 1\n\nEt nous traçons de la même manière que précédemment le plan de phase :\n\n\nCode\nfig2, ax2 = plt.subplots(1, 1)\nfig2.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax2.plot(xt,xt * (1/b) * (rxnew * ((xt/Kx) - 1) + b), color = 'C2', \n                label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax2.plot(xt * (1/b) * (rynew * ((xt/Ky) - 1) + b), xt, color = 'C3', \n                label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## Nous réduisons la vue à ce qui nous intéresse:\nax2.set_xlim(left = -.3, right = 3)\nax2.set_ylim(top = 3, bottom = -.3)\n\n## Nous traçons la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## Nous nommons les axes:\nax2.set_xlabel('$x$', fontsize = '12') ;\nax2.set_ylabel('$y$', fontsize = '12') ;\n\n## Nous recalculons les équilibres avec les nouveaux paramètres:\n## Nous définissons un monome y, un polynôme p et nous prenons ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol2 =  y * ((1/b) * (-rxnew - rynew + rxnew * rynew/b)) + \\\n(y**2) * (rynew/(Ky * b) * (1 - (rxnew/b)) + rxnew/(b * Kx) * (1 - (2*rynew/b) + rynew**2 /(b**2))) + \\\n2 * (y**3) * ((rxnew * rynew)/((b**2) * Kx * Ky)) * (1 - (rynew/b)) + \\\n(y**4) * ((rxnew * (rynew**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution que nous obtenons avec un masque booléen qui sélectionne les \n## racines réelles et strictement positives:\nsol2 = pol2.roots()[ (np.isreal( pol2.roots() )) * (pol2.roots() &gt; 0)]\nyeq2=sol2[0].real\n\n## Nous calculons calcule x*\nxeq2 = (rynew * yeq2 * ((1/rynew) - (1/b) + (yeq2/(b * Ky)))).real\n\n## Nous représentons les deux équilibres:\nax2.plot(xeq2.real, yeq2.real, label = '$(x^*,y^*)$', marker = '.', \n                markersize = 6, color = 'k')\nax2.plot(0, 0, label = '$(0,0)$', marker = '.', markersize = 6, \n                color = 'k')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left')\n\n## Ajout du champ de vecteur via la fonction quiver :\nxg = np.arange(0, 5, 0.6)\nyg = np.arange(0, 5, 0.6)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', \n                scale = 80, width = 0.003) ;\n\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rxnew * X2 * (1 - X2/Kx)\nY = rynew * Y2 * (1 - Y2/Ky)\n\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax2.legend(loc = 'upper left', fontsize = 8)\n\n## Nous plaçons les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax2.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax2.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et nous les relions aux axes:\nxc = np.arange(0, Kx, 0.01)\nax2.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax2.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#Nous nommons les points:\nax2.text(-0.2, Ky, '$K_y$')\nax2.text(Kx, -0.2, '$K_x$')\n\n#Nous plaçons les points d'équilibres :\nys = np.arange(0, yeq2, 0.01)\nxs = np.arange(0, xeq2, 0.01)\n\nax2.plot(xeq2 * np.ones_like(ys), ys, linestyle = 'dashed',\n                color = 'k', linewidth = 0.5)\nax2.plot(xs, yeq2 * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax2.text(-0.2, yeq2, '$y^*$');\nax2.text(xeq2, -0.2, '$x^*$');\n\n\n\n\n\nFigure 4: Plan de phase déflationiste\n\n\n\n\nL’ellipse, d’équation f(x,y)=r_xx\\left(1-\\frac{x}{K_x}\\right)+r_yy\\left(1-\\frac{y}{K_y}\\right) = 0 , peut être vue comme la ligne de niveau de f en 0.\nAinsi, une équation de la tangente au point (x_0,y_0) est donnée par:\n\n\\frac{\\partial f}{\\partial x}(x_0,y_0)(x-x_0)+ \\frac{\\partial f}{\\partial y}(x_0,y_0)(y-y_0) = 0\n\\tag{8}\nautrement dit: \n\\left(r_x - 2\\frac{r_xx_0}{K_x}\\right)(x-x_0) + \\left(r_y -2\\frac{r_yy_0}{K_y}\\right)(y-y_0) = 0\n\nDans le cas où x_0=K_x et y_0=K_y nous avons alors: \n-r_x(x-K_x) -r_y(y-K_y) = 0\n \n\\Leftrightarrow\n \ny = -\\frac{r_x}{r_y}\\left(x-K_x\\right) + K_y\n\\tag{9}\nqui est donc l’équation de la tangente à l’ellipse au point (K_x,K_y).\nSi maintenant nous prenons r_x=r_y alors nous remarquons que (9) est égale à l’équation de la droite d ce qui implique que toute l’ellipse est en dessous de d et donc que tous les équilibres sont déflationnistes.\nDonc : si r_x=r_y nous avons (1) qui est déflationniste quelque soit le taux de migration.\nNous allons effectuer une simulation avec les paramètres déduits à l’instant pour illustrer ce que nous venons de dire.\nPour cela nous allons, pour chaque \\beta, simuler un temps suffisament large pour atteindre l’équilibre et représenter la somme des deux équilibres.\n\n\n\n\n\n\nNote\n\n\n\nNous aurions pu utiliser les racines du polynôme calculé plus haut afin de simuler la somme des équilibres.\n\n\nIl faut donc définir une fonction qui prend en compte le changement de \\beta :\n\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n\nAinsi qu’un temps d’intégration large, des conditions initiales et des paramètres :\n\n## Temps d'intégration :\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \nrx1 = 0.5\nry1 = 0.5 # Nous prenons rx1=rx2\nKx1 = 2\nKy1 = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Condition initiale:\nc10 = [2, 0]\n\nEt enfin nous simulons avec odeint et nous faisons une boucle pour simuler que \\beta va de 0 à 4 (suffisant pour avoir une courbe intéressante):\n\n## Nous créons la figure et l'axe:\nfig3, ax3 = plt.subplots(1, 1)\nfig3.suptitle(\"Somme des équilibres en fonction de β quand $r_x = r_y$\")\n\n## Boucle ou i prend les valeurs de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param1, i)) #Nous calculons pour chaque beta l'équilibre\n    ax3.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\nxt = np.arange(0, 4, 0.01)\n\nax3.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax3.text(3.2, Kx + Ky + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax3.set_xlabel('β')\nax3.set_ylabel('Population')\nax3.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\n\n## Nous adaptons la fenêtre:\nax3.set_ylim(2.2, 3.2)\n\nax3.legend();\n\n\n\n\nFigure 5: Somme des équilibres déflationiste\n\n\n\n\nNous voyons que la courbe bleue représentant la somme des équilibres est en permanence en dessous de la droite K_x+K_y. Nous avons bien un système entièrement déflationniste quand r_x = r_y.\n\n\nDeuxième condition à un système déflationniste\nNous allons maintenant considérer le cas où r_x &lt; r_y c’est à dire nous allons prendre l’ellipse dans le sens horizontal (voir sur l’animation Geogebra pour plus de clarté).\nNous allons analyser graphiquement le plan de phase. Nous aurons besoin de tracer les droites définies par \\beta = 0 et \\beta \\to +\\infty dans l’équation y^*=r_xx^*\\left(\\frac{1}{r_x}-\\frac{1}{\\beta}+\\frac{x^*}{\\beta K_x}\\right) (la parabole verte dans le plan de phase définie par \\dot x =0).\nEn effet, ceci va permettre d’encadrer l’équilibre (x^*,y^*) en fonction du taux de migration.\nLorsque \\beta = 0 nous avons, par la première équation de (2) : \n0 = r_xx^*(1-\\frac{x^*}{K_x})\n \n\\Leftrightarrow\n \nx^*=K_x \\vee x^* = 0\n\nDonc lorsque le taux de migration est nul la “parabole” “correspondant à \\dot x = 0 a pour équation les droites x^*=0 et x^*=K_x que nous appellerons respectivement P_{10} et P_{20}.\nLorsque \\beta \\to + \\infty nous avons, encore une fois par la première équation de (2):\n\ny^* = r_xx^*\\frac{1}{r_x} = x^*\n\nAinsi quand le taux de migration tend vers l’infini la “parabole” \\dot x = 0 correspond à la droite y^*=x^* que nous apellons P_\\infty.\nNous noterons dans la suite A=(K_x,K_y), B l’intersection non trivial (pas (0,0)) entre P_\\infty et l’ellipse et C l’intersection non triviale (pas (K_x,0)) entre P_{20} et P_\\infty.\nPour calculer les coordonnées de B nous utilisons que y^*=x^* et nous le rentrons dans (7) ce qui donne : \nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right)+r_y\\left(1-\\frac{x^*}{K_y}\\right)\\right) = 0\n \n\\Leftrightarrow\n \nx^* = \\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}}\n\n\nB = (\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}},\\frac{r_x+r_y}{\\frac{r_x}{K_x}+\\frac{r_y}{K_y}})\n\nPour calculer les coordonnées de C nous utilisons que y^*=x^* dans la définition de P_{20}, ie comme P_{20} est défini par x^* =K_x alors y^*=K_x et donc nous avons: \nC=(K_x,K_x)\n\nReprésentons le tout sur le premier plan de phase:\n\n## Parabole xdot=0 b=0:\nax.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole b=0')\nax.plot(np.zeros_like(xt), xt, color = 'C9')\n\n## Parabole xdot=0 b=+inf:\nax.plot(xt, xt, color = 'C6', label = 'Parabole b=$+\\infty$')\n\n## Nous plaçons des textes indiquant les trois droites:\nax.text(0.05, yeq + 0.4, \"$P_{10}$\")\nax.text(Kx + 0.05, 2.8, \"$P_{20}$\")\nax.text(2.65, 2.45, \"$P_\\infty$\")\n\n## Nous plaçons les trois points:\n## A :\nax.plot(Kx, Ky, marker = '.',color = 'C0', markersize = 7)\nax.text(Kx + 0.1, Ky + 0.1, \"$A$\")\n\n## B :\nax.plot((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky), \n            marker = '.', color = 'C0', markersize = 7)\n\nax.text((rx + ry)/(rx/Kx + ry/Ky) - 0.1, (rx + ry)/(rx/Kx + ry/Ky) + 0.1, \"$B$\")\n\n## C : \nax.plot(Kx, Kx, marker = '.', color = 'C0', markersize = 7)\nax.text(Kx - 0.1, Kx + 0.1, \"$C$\")\n\nax.legend(loc = \"upper left\", fontsize = 6.5)\n\ndisplay(fig)\n\n\n\n\nFigure 6: Plan de phase complet\n\n\n\n\nLorsque \\beta augmente de 0 à +\\infty nous avons l’équilibre qui parcourt l’ellipse de A à B.\nPour que le système soit déflationniste nous voulons que la portion de l’ellipse de A à B soit complètement en dessous de la droite d (grise).\nPour ce faire nous pouvons voir sur notre plan de phase qu’il faut que C ait une coordonnée y plus grande que A afin que B soit toujours à gauche de A (et donc en dessous de d).\nMathématiquement nous voulons donc que K_x &gt; K_y.\nAinsi si nous avons r_x &lt; r_y et K_x&gt;K_y nous aurons tout le temps un modèle déflationniste pour les ravageurs.\nCeci est intéressant pour l’augmentorium, si nous avons la capacité de charge l’augmentorium qui est plus faible que celle de la culture alors le système est toujours répréssif pour la population totale de ravageurs.\nNous pouvons aussi voir graphiquement que dans ce cas là nous avons toujours x^* &lt; K_x, c’est ce que nous cherchons à obtenir.\nNous pouvons illustrer notre condition avec une simulation similaire à la partie précédente :\nNous utilisons le même modèle, nous changeons uniquement les paramètres :\n\n## Paramètres : \nrx2 = 0.5\nry2 = 1  #Nous avons bien rx2 &lt; ry2 \nKx2 = 2\nKy2 = 1  #Nous avons bien Kx2&gt;Ky2\n\n## En l'occurence il s'agit des paramètres de base que nous ##avions utilisé pour la simulation du premier plan de phase ##expliquant que nous nous retrouvions avec un équilibre ##déflationniste.\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n\nEt nous simulons à nouveau :\n\n\nCode\n## Nous créons la figure et l'axe:\n\nfig4, ax4 = plt.subplots(1, 1)\nfig4.suptitle(\"Somme des équilibres en fonction de β quand $r_x &lt; r_y$ et $K_x &gt; K_y$\")\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, c10, t1, args = (param2, i)) #Nous calculons pour chaque beta l'équilibre\n    ax4.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax4.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax4.text(3.2, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax4.set_xlabel('β')\nax4.set_ylabel('Population')\nax4.plot(Kx2+Ky2, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\n\n## Nous adaptons la fenêtre:\nax4.set_ylim(2.2, 3.2)\n\nax4.legend();\n\n\n\n\n\nFigure 7: Somme des équilibres déflationiste\n\n\n\n\nNous observons que nous avons bien une déflation du système quelque soit le taux de migration.\n\n\nConditions pour une inflation et/ou une déflation\nSur la base de la Figure 6 nous pouvons aussi déduire quand est-ce que nous pouvons avoir inflation selon les paramètres.\nIl s’agit de la même idée de preuve graphique qu’avant mais en complexifiant un peu. Pour cela nous allons avoir besoin d’un quatrième point que nous appellerons D et qui correspond à l’autre intersection entre l’ellipse et la droite d (pas (K_x,K_y)).\nPour trouver les coordonnées de D nous avons simplement que comme D est sur d alors nous avons y^* = -x^* + K_x + K_y et nous remplaçons y^* dans (7) ce qui donne : \nr_xx^*\\left(1-\\frac{x^*}{K_x}\\right) +r_y(-x^*+K_x+K_y)\\left(1-\\frac{-x^*+K_x+K_y}{K_y} \\right) = 0\n \n\\Leftrightarrow\n \nx^*\\left(r_x\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{r_yK_x}{K_y}\\left(1-\\frac{x^*}{K_x} \\right) \\right) + \\frac{r_y(K_x+K_y)}{K_y}(x^*-K_x) = 0\n \n\\Leftrightarrow\n \n\\left(1-\\frac{x^*}{K_x}\\right)\\left(x^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right]-\\frac{r_yK_x(K_x+K_y)}{K_y}\\right) = 0\n\nCe qui donne soit x^* = K_x et nous retrouvons alors A, soit :\n\nx^*\\left[r_x+\\frac{r_yK_x}{K_y}\\right] = \\frac{r_yK_x(K_x+K_y)}{K_y}\n \n\\Leftrightarrow\n \nx^* = \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n\nEt donc d’après la définition de y^* : \ny^* = - \\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} + K_x + K_y\n \n\\Leftrightarrow\n \ny^* = \\frac{(K_x+K_y)(r_xK_y+r_yK_x)-r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x}\n \n\\Leftrightarrow\n \ny^*=\\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x}\n\nAinsi, D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} ) .\nAjoutons D à un nouveau plan de phase :\n\n## Temps d'intégration :\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \nrx = 0.5\nry = 1.5\nKx = 1\nKy = 2\nb = 1\n\nparam1 = np.array([rx, ry, Kx, Ky, b])\n\n## Condition initiale:\nc10 = [2, 0]\n\n## Nous définissons un monome y, un polynôme p et nous prenons ses solutions:\ny = np.polynomial.Polynomial([0, 1])\n\npol = y * ((1/b) * (-rx - ry + rx*ry/b)) + \\\n(y**2) * (ry/(Ky * b) * (1 - (rx/b)) + rx/(b * Kx) * (1 - (2*ry/b) + ry**2 /(b**2))) + \\\n2 * (y**3) * ((rx * ry)/((b**2) * Kx * Ky)) * (1 - (ry/b)) + \\\n(y**4) * ((rx * (ry**2))/((b**3) * (Ky**2) * Kx))\n\n## Solution que nous obtenons avec un masque booléen qui sélectionne les racines réelles et strictement positives:\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() &gt; 0)]\nyeq = sol[0].real\n\nxeq = (ry * yeq * ((1/ry) - (1/b) + (yeq/(b * Ky)))).real\n\nfig2, ax = plt.subplots(1, 1, figsize = (8,5))\nfig2.suptitle('Plan de phase du système')\n\n## Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\n## Pour xdot = 0:\nax.plot(xt,xt * (1/b) * (rx * ((xt/Kx) - 1) + b), \n                    color = 'C2', label = '$\\dot x=0$')\nax.plot(np.zeros_like(xt), xt, color = '0.8', markersize = 6)\n\n## Pour ydot = 0:\nax.plot(xt * (1/b) * (ry * ((xt/Ky) - 1) + b), xt,\n                    color = 'C3', label = '$\\dot y=0$')\nax.plot(xt, np.zeros_like(xt), color = '0.8', markersize = 6)\n\n## Nous réduisons la vue à ce qui nous intéresse:\nax.set_xlim(left = -.3, right = 3)\nax.set_ylim(top = 3, bottom = -.3)\n\n## Nous traçons la droite la somme des capacités:\nx = np.arange(0, 10, 0.01)\nax.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = '0.8')\n\n## Nous nommons les axes:\nax.set_xlabel('$x$', fontsize = '12') ;\nax.set_ylabel('$y$', fontsize = '12') ;\n\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\n\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\n\nax.contour(X2, Y2, (X + Y), [0], colors = 'C1')\n\nax.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n## Localisation de la légende:\nax.legend(loc = 'upper left', fontsize = 8)\n\n## Nous plaçons les différents points d'intérêts...\nxv = np.arange(0, 10)\n\nax.plot(0, Ky, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, 0, marker = '.', markersize = 7, color = 'k')\nax.plot(Kx, Ky, marker = '.', markersize = 6, color = 'k')\n\n##...et nous les relions aux axes:\nxc = np.arange(0, Kx, 0.01)\nax.plot(xc, Ky * np.ones_like(xc), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nyc=np.arange(0,Ky,0.01)\nax.plot(Kx * np.ones_like(yc), yc, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\n#Nous nommons les points:\nax.text(-0.2, Ky, '$K_y$')\nax.text(Kx, -0.2, '$K_x$')\n\n#Nous plaçons les points d'équilibres :\nys = np.arange(0, yeq, 0.01)\nxs = np.arange(0, xeq, 0.01)\n\nax.plot(xeq * np.ones_like(ys), ys, linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\nax.plot(xs, yeq * np.ones_like(xs), linestyle = 'dashed', \n                color = 'k', linewidth = 0.5)\n\nax.text(-0.2, yeq, '$y^*$')\nax.text(xeq, -0.2, '$x^*$')\n\n## Parabole xdot=0 b=0:\nax.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole b=0')\nax.plot(np.zeros_like(xt), xt, color = 'C9')\n\n## Parabole xdot=0 b=+inf:\nax.plot(xt, xt, color = 'C6', label = 'Parabole b=$+\\infty$')\n\n## Nous plaçons des textes indiquant les trois droites:\nax.text(0.05, yeq + 0.4, \"$P_{10}$\")\nax.text(Kx + 0.05, 2.8, \"$P_{20}$\")\nax.text(2.65, 2.45, \"$P_\\infty$\")\n\n## Nous plaçons les trois points:\n## A :\nax.plot(Kx, Ky, marker = '.',color = 'C0', markersize = 7)\nax.text(Kx + 0.1, Ky + 0.1, \"$A$\")\n\n## B :\nax.plot((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky), \n            marker = '.', color = 'C0', markersize = 7)\n\nax.text((rx + ry)/(rx/Kx + ry/Ky), (rx + ry)/(rx/Kx + ry/Ky) + 0.1, \"$B$\")\n\n## C : \nax.plot(Kx, Kx, marker = '.', color = 'C0', markersize = 7)\nax.text(Kx - 0.1, Kx + 0.1, \"$C$\")\n\n## Nous ajoutons D:\nax.plot((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx), \n        (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx),\n        color = 'C0', marker = '.', markersize = 7)\n\nax.text((ry * Kx * (Kx + Ky))/(rx * Ky + ry * Kx) + 0.07, \n        0.08 + (rx * Ky * (Kx + Ky))/(rx * Ky + ry * Kx), \"$D$\")\n\n## Nous représentons les deux équilibres:\nax.plot(xeq.real, yeq.real, label = '$(x^*,y^*)$', marker = '.', markersize = 6, color = 'k')\nax.plot(0, 0, label = '$(0,0)$',\n                    marker = '.', markersize = 6, color = 'k')\n\nax.legend(loc = \"lower right\", fontsize = 6.5);\n\n\n\n\nFigure 8: Plan de phase complet\n\n\n\n\nNous voyons maintenant aisément que si B est entre A et D alors les équilibres vont parcourir des valeurs inflationistes seulement (arc orange au dessus de la droite grise).\nSi B est en dessous de D (la coordonnée y de B est plus petite que celle de D) alors nous avons d’abord des équilibres inflationistes (de A à D) puis déflationnistes (de D à B).\nMathématiquement nous avons donc :\nSi K_y &gt; K_x (la coordonnée y de B est plus grande que celle de A) et K_xr_y &gt; K_yr_x (la coordonnée y de B est plus grande que celle de D) alors le système est toujours inflationniste.\nSi K_xr_y &lt; K_yr_x (la coordonnée y de B est plus petite que celle de D) alors le système est d’abord inflationniste puis déflationniste.\nNous pouvons vérifier ces deux assertions avec des simulations similaires à la partie précédente :\nNous utilisons le même modèle, nous changeons uniquement les paramètres :\n\n## Paramètres condition 1: \nrx3 = 0.4\nry3 = 1  #Nous avons bien rx3 &lt; ry3 \nKx3 = 1\nKy3 = 2  #Nous avons bien Ky3&gt;Kx3\n\n#Nous avons la première condition de Kxry &gt; Kyrx\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres condition 2: \nrx4 = 0.6\nry4 = 1  #Nous avons bien rx4 &lt; ry4 \nKx4 = 1  \nKy4 = 2  \n\n#Nous avons la deuxième condition de Kxry &gt; Kyrx\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n\nEt nous simulons à nouveau :\n\n\nCode\n## Nous créons la figure et l'axe:\n\nfig5, (ax5, ax6) = plt.subplots(1, 2, figsize = (7, 5))\nax5.set_title(\"Somme des équilibre en fonction de β quand $r_x &lt; r_y$ et $K_y &gt; K_x$ et $K_xr_y &gt; K_yr_x$\", fontsize = 6)\nax6.set_title(\"Somme des équilibre en fonction de β quand $r_x &lt; r_y$ et $K_xr_y &lt; K_yr_x$\", fontsize = 6)\n\nplt.subplots_adjust(wspace = 0.4) #Nous ajustons l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param3, i)) #Nous calculons pour chaque beta l'équilibre\n    ax5.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, c10, t1, args = (param4, i))\n    ax6.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt=np.arange(0, 4, 0.01)\n\nax5.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax5.text(3.2, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\nax6.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax6.text(3.2, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n## Légendes:\nax5.set_xlabel('β')\nax5.set_ylabel('Population')\nax5.plot(Kx3 + Ky3, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\nax6.set_xlabel('β')\nax6.plot(Kx4 + Ky4, 0, color = 'C0', label = 'Somme des équilibres')\n\n## Nous adaptons la fenêtre:\nax5.set_ylim(2.9, 3.2)\nax6.set_ylim(2.9, 3.1)\n\nax5.legend();\nax6.legend();\n\n\n\n\n\nFigure 9: Somme des équilibres avec inflation et/ou déflation\n\n\n\n\nNous observons que nous avons bien dans la partie gauche tout le temps inflation et dans la partie droite d’abord inflation puis déflation."
  },
  {
    "objectID": "modelesansmigrationass.html#animation",
    "href": "modelesansmigrationass.html#animation",
    "title": "Modèle logistique structuré sans migration asymétrique",
    "section": "Animation",
    "text": "Animation\nPour mieux comprendre comment se déplace le système en fonction des paramètres :\n\n\nCode\n#Technique pour utiliser une fenêtre geogebra:\n\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/ajaycvqe\" style = \"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\n\ndisplay.HTML(fig01)\n\n\n\n\n\nFigure 10: Animation Geogebra"
  },
  {
    "objectID": "modeleavecmigrationass.html#définition-du-modèle",
    "href": "modeleavecmigrationass.html#définition-du-modèle",
    "title": "Modèle logistique structuré avec migration asymétrique",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nLe but d’un augmentorium est de confiner les ravageurs dans un espace clos qui ne laisse pas (ou peu) s’échapper ceux-ci.\nAinsi, il s’établit une migration asymétrique entre les deux structures que nous pouvons modéliser en établissant le modèle suivant d’après Arditi R. (2018) :\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{1}\navec :\n- x la population de ravageurs dans la culture,\n- y la population de ravageurs dans l’augmentorium,\n- r_x et r_y le taux de croissance dans la culture et dans l’augmentorium,\n- K_x et K_y les capacités de charges de la culture de de l’augmentorium,\n- \\beta la force de migration entre les structures,\n- \\gamma_x et \\gamma_y caractérisant l’asymétrie de migration.\n\nNouvelles hypothèses propres à l’augmentorium\nCe modèle est plus proche de celui d’un augmentorium.\nComme les ravageurs se reproduisent mieux dans l’augmentorium que dans la culture nous pouvons dire que r_x&lt;r_y.\nNous pouvons aussi dire que le taux de fuite des ravageurs (\\frac{1}{\\gamma_y}) se doit d’être beaucoup plus petit que le taux de migration (\\frac{1}{\\gamma_x}).\nNous avons donc \\gamma_x &lt;&lt; \\gamma_y."
  },
  {
    "objectID": "modeleavecmigrationass.html#dynamique-du-modèle",
    "href": "modeleavecmigrationass.html#dynamique-du-modèle",
    "title": "Modèle logistique structuré avec migration asymétrique",
    "section": "Dynamique du modèle",
    "text": "Dynamique du modèle\nEncore une fois nous simulons la dynamique des deux populations en fonction du temps en codant comme dans la première partie\nNous définissons le système sous Python:\n\n\nCode\ndef aug(etat, t, param):\n    rx, ry, Kx, Ky, b, gx, gy = param\n    x, y = etat\n    s=[rx * x * (1 - x/Kx) + b * (y/gy - x/gx),\n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s\n\n\nEt nous définissons les paramètres, le temps d’intégration etc. :\n\n\nCode\n# Temps d'intégration:\nti = np.arange(0, 10, 0.01)\n\n# Etats initiaux:\nx0 = 2\ny0 = 0\ne0 = [x0, y0]\n\n# Paramètres: \n\nrx = 0.5\nry = 1\nKx = 2\nKy = 1\nb = 1\ngx = 0.5\ngy = 3\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Simulation:\ns = odeint(aug, e0, ti, args = (param_aug, ))\n\n\nNous traçons la figure :\n\n\nCode\nfig,ax = plt.subplots(1, 1)\nfig.suptitle('Dynamique des ravageurs dans le temps avec augmentorium')\n\nax.plot(ti, s[ :, 0], color = 'C1', label = 'culture')\nax.plot(ti, s[ :, 1], color = 'C0', label = 'augmentorium')\n\n# Ajout d'élements:\nax.grid()\nax.legend()\nax.set_xlabel('Temps, t');\nax.set_ylabel('Densité de pop.');\n\n\n\n\n\nFigure 1: Simulation de la dynamique du modèle\n\n\n\n\nCette dynamique, comme en première partie, présente un équilibre de maintien de la population.\nNéanmoins nous observons que, pour les mêmes paramètres que dans la première partie, la population dans la culture est bien plus faible.\nLa migration asymétrique vers l’augmentorium semble être bénéfique à la culture."
  },
  {
    "objectID": "modeleavecmigrationass.html#plan-de-phase",
    "href": "modeleavecmigrationass.html#plan-de-phase",
    "title": "Modèle logistique structuré avec migration asymétrique",
    "section": "Plan de phase",
    "text": "Plan de phase\n\nEquilibres et leur stabilité\nA l’équilibre nous avons le système suivant :\n\n\\left\\{\\begin{array}{l}\n\\dot x = 0 \\Leftrightarrow 0 = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = 0 \\Leftrightarrow 0 = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{2} \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\ny^*=\\gamma_y\\left(\\frac{x}{\\gamma_x}-\\frac{r_xx}{\\beta}\\left(1-\\frac{x}{K_x}\\right)\\right)\\\\\nx^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)\n\\end{array}\\right.\n\\tag{3}\nNous voyons tout de suite que nous avons deux paraboles qui se croisent en (0,0) et en (x^*,y^*).\nNous allons donc avoir deux équilibres, ceux-ci vivent sur une ellipse de même équation qu’en première partie.\nEn fonction des racines des paraboles nous allons avoir des plans de phases différents que nous allons tracer via les mêmes techniques qu’en première partie :\n\n\nCode\n#Nous créons la figure avec les 3 sous figures:\nfig2, (ax2, ax3, ax4) = plt.subplots(1, 3, figsize = (9, 4))\n\nfig2.suptitle('Plan de phase de la population')\nax2.set_title('β=1')\nax3.set_title('β=10')\nax4.set_title('β=0.1')\n\n#Plan de phase 1:#\n# Paramètres: \nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\nb1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam_aug1 = np.array([rx1, ry1, Kx1, Ky1, b1, gx1, gy1])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy1 * (xt/gx1 - rx1 * xt/b1 * (1 - xt/Kx1)), color = 'C2', label = '$\\dot x=0$')\nax2.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax2.plot(gx1 * (yt/gy1 - ry1 * yt/b1 * (1 - yt/Ky1)), yt, color = 'C3', label = '$\\dot y=0$')\nax2.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax2.set_xlim(left = -0.03, right = 0.5)\nax2.set_ylim(top = 1.5, bottom = -0.06)\n\nax2.set_xlabel('Ravageur dans la culture', fontsize = '12');\nax2.set_ylabel('Ravageur dans l\\'augmentorium', fontsize = '12');\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\nX, Y = np.meshgrid(xg, yg)\n\n#Nous utilisons quiver:\ndx, dy = aug([X, Y], 0, param_aug1)\nax2.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 15, width = 0.0035);\n\n#Plan de phase 2:#\n#Paramètres: \nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\nb2 = 10\ngx2 = 0.5\ngy2 = 3\n\nparam_aug2 = np.array([rx2, ry2, Kx2, Ky2, b2, gx2, gy2])  \n\n#Isocline nulles:\n#xdot = 0\nax3.plot(xt, gy2 * (xt/gx2 - rx2 * xt/b2 * (1 - xt/Kx2)), color = 'C2', label = '$\\dot x=0$')\nax3.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0\nax3.plot(gx2 * (yt/gy2 - ry2 * yt/b2 * (1 - yt/Ky2)), yt, color = 'C3', label = '$\\dot y=0$')\nax3.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration de la figure:\nax3.set_xlim(left = -0.02, right = 0.35)\nax3.set_ylim(top = 1.4, bottom = -0.06)\n\nax3.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n\n#Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.08)\nyg = np.arange(-0.5, 3, 0.08)\n\nX, Y = np.meshgrid(xg, yg)\n\n#Nous utilisons quiver:\ndx, dy = aug([X, Y], 0, param_aug2)\nax3.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 40, width = 0.003);\n\n#Plan de phase 3:\n#Paramètres: \nrx3 = 0.5\nry3 = 1\nKx3 = 2\nKy3 = 1\nb3 = 0.1\ngx3 = 0.5\ngy3 = 3\n\nparam_aug3=np.array([rx3, ry3, Kx3, Ky3, b3, gx3, gy3])\n\n#Isocline nulles:\n#xdot = 0 \nax4.plot(xt, gy3 * (xt/gx3 - rx3 * xt/b3 * (1 - xt/Kx3)), color = 'C2', label = '$\\dot x=0$')\nax4.plot(np.zeros_like(xt), xt, color = 'k', markersize = 6)\n\n#ydot = 0 \nax4.plot(gx3 * (yt/gy3 - ry3 * yt/b3 * (1 - yt/Ky3)), yt, color = 'C3', label = '$\\dot y=0$')\nax4.plot(xt, np.zeros_like(xt), color = 'k', markersize = 6)\n\n#Illustration:\nax4.set_xlim(left = -0.08, right = 1.9)\nax4.set_ylim(top=1.5, bottom = -0.06)\n\nax4.set_xlabel('Ravageur dans la culture', fontsize = '12');\n\n# Ajout du champ de vecteur\nxg = np.arange(-0.5, 3, 0.18)\nyg = np.arange(-0.5, 3, 0.18)\n\nX, Y = np.meshgrid(xg, yg)\n\ndx, dy = aug([X, Y], 0, param_aug3)\nax4.quiver(X, Y, dx, dy, angles = 'xy', color = 'grey', scale = 10, width = 0.0035);\n\n#Nous légendons:\nax4.legend();\n\n\n\n\n\nFigure 2: 3 profils de plan de phase\n\n\n\n\nEn fonction des valeurs de \\beta nous observons des profils différents de plan de phase. Pour mieux le visualiser nous pourrons utiliser l’animation Geogebra mise à disposition à la fin de l’analyse.\nD’après le champ de vecteurs nous voyons clairement que l’équilibre en (0,0) est instable et l’équilibre (x^*,y^*) est stable.\nPour calculer l’équilibre nous procédons de la même manière que dans la première partie, c’est à dire en croisant les deux paraboles \\dot x=0 et \\dot y =0 :\nNous avons x^*=\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)\nDonc : \\small\ny^*=\\gamma_y\\left(\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\gamma_x}-\\frac{r_x\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{\\beta}\\left[1-\\frac{\\gamma_x\\left(\\frac{y}{\\gamma_y}-\\frac{r_yy}{\\beta}\\left(1-\\frac{y}{K_y}\\right)\\right)}{K_x}\\right]\\right)\n \n\\Leftrightarrow\n \n-\\frac{r_y\\gamma_yy^*}{\\beta} + \\frac{r_y \\gamma_y {y^*}^2}{\\beta K_y} - \\frac{r_x\\gamma_xy^*}{\\beta} + \\frac{r_xr_y\\gamma_x \\gamma_y y^*}{\\beta^2} \\\\\n- \\frac{r_xr_y\\gamma_x\\gamma_y{y^*}^2}{\\beta^2K_y} + \\frac{r_x\\gamma_x^2{y^*}^2}{\\beta K_x\\gamma_y} - \\frac{r_xr_y\\gamma_x^2{y^*}^2}{\\beta^2K_x} \\\\\n+ 2\\frac{r_xr_y\\gamma_x^2{y^*}^3}{\\beta^2K_xK_y} + \\frac{r_xr_y^2\\gamma_x^2 \\gamma_y {y^*}^2}{\\beta^3K_x} - 2\\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^3}{\\beta^3K_xK_y} \\\\\n+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y{y^*}^4}{\\beta^3K_xK_y^2} = 0\n\nCe qui donne, en mettant les monomes y^* en facteur et en simplifiant ensuite par \\frac{y^*}{\\beta} :\n\n\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta}-\\gamma_yr_y-\\gamma_xr_x +\\\\ y^*\\left[\\frac{r_y\\gamma_y}{K_y}-\\frac{r_xr_y\\gamma_x\\gamma_y}{\\beta K_y}+ \\frac{r_xr_y^2\\gamma_x^2\\gamma_y}{\\beta^2K_x}+\\frac{r_x\\gamma_x^2}{\\gamma_yK_x}-\\frac{2r_xr_y\\gamma_x^2}{\\beta K_x}   \\right] +\\\\[.2cm]\n\\frac{2r_yr_x\\gamma_x^2{y^*}^2}{\\beta K_xK_y}\\left(1-\\frac{r_y\\gamma_y}{\\beta}\\right) + \\frac{r_xr_y^2\\gamma_x^2\\gamma_y {y^*}^3}{\\beta^2K_xK_y^2} = 0\n\\tag{4}\nCe polynôme est résoluble par numpy similairement à la première partie :\n\n\nCode\n# Paramètres pour calculer le polynôme\nrx = 0.5\nry = 1\nKx = 2.5\nKy = 2\nb = 1\ngx = 1.5\ngy = 3\n\n#Points d'équilibres, utilisation de numpy : monome, polynome et racines:\n#Calcul:\n#Monome y\nx = np.polynomial.Polynomial([0, 1])\n\n#Polynome :\npol = -gy * ry - gx * rx + (rx * ry * gx * gy)/b + x * ((ry * gy)/(Ky) - (ry * rx * gy * gx)/(b * Ky) + \\\n rx * ry**2 * gx**2 * gy/(b**2 * Kx) + rx * gx**2/(gy * Kx) - 2 * rx * ry * gx**2/(b * Kx)) + \\\n (x**2) * 2 * (ry * rx *gx**2)/(b * Kx * Ky) * (1 - ry * gy/b) + (x**3) * gy * rx * ((ry * gx)**2)/(b**2 * Kx * Ky**2)\n\n#Solution\nsol = pol.roots()[ (np.isreal( pol.roots() )) * (pol.roots() &gt; 0)]\nyeq = sol[0].real\n\n#Calcul de x avec sa définition:\nxeq = gx * (yeq/gy - ry * yeq/b * (1 - yeq/Ky))\n\n\n\n\nAnalyse du plan de phase\nNous allons tracer le plan de phase complet et l’analyser d’après la méthode d’Arditi R. (2018) :\nDans cette analyse nous allons considérer, sans perte de généralité, que r_x &lt; r_y (nous prenons l’ellipse dans un seul sens, voir l’animation).\nPour cela nous traçons l’ellipse de la même manière que dans la première figure.\nEnsuite nous allons tracer la droite d correspondant à K_x+K_y=x^*+y^* car ceci va permettre de voir si le système subit une inflation ou une déflation.\nEnfin, similairement à la partie prédédente nous allons tracer les droites données par \\beta = 0 et \\beta \\to +\\infty dans la parabole définie par \\dot x =0 (parabole verte sur le plan de phase).\nLes droites sont différentes du modèle précédent donc nous allons les recalculer :\nLorsque \\beta = 0 nous avons exactement les mêmes deux droites que dans le modèle précédent en x^* =0 et en x^*=K_x car le fait que le nouveau modèle ajoute de l’asymétrie dans les migrations est effacé par une migration nulle. Nous les appellerons respectivement P_{10} et P_{20}.\nLorsque \\beta \\to +\\infty nous avons d’après (3) : \ny^* = \\frac{\\gamma_y}{\\gamma_x}x^*\n\nNous appellerons cette droite P_{\\infty}.\nIntroduisons les mêmes points que précédemment c’est à dire :\n\nA, l’intersection entre P_{20} et l’ellipse, c’est à dire la valeur de l’équilibre quand \\beta = 0.\nB, l’intersection entre P_{\\infty} et l’ellipse, c’est à dire la valeur de l’équilibre quand \\beta \\to +\\infty.\nC, l’intersection entre P_{20} et P_{\\infty}.\nD, l’intersection entre la droite d et l’ellipse qui n’est pas le point A.\n\nReprésentons le plan de phase avec ces éléments :\n\n\nCode\n#Nous créons la figure:\nfig2, ax2 = plt.subplots(1, 1, figsize = (8, 5))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase:\n# Paramètres égaux à ceux utilisés pour calculer les équilibres:\n\nparam_aug = np.array([rx, ry, Kx, Ky, b, gx, gy])\n\n# Isocline nulles:\nxt = np.arange(-10, 10, 0.01)\nyt = np.arange(-10, 10, 0.01)\n\n#xdot = 0 \nax2.plot(xt, gy * (xt/gx - rx * xt/b * (1 - xt/Kx)), color = 'C2', label = '$\\dot x = 0$')\n\n#ydot = 0\nax2.plot(gx * (yt/gy - ry * yt/b * (1 - yt/Ky)), yt, color = 'C3', label = '$\\dot y = 0$')\n\n#Cadrage:\nax2.set_xlim(left = -0.30, right = 4.5)\nax2.set_ylim(top = 6, bottom = -0.70)\n\nax2.set_xlabel('$x^*$', fontsize = '12')\nax2.set_ylabel('$y^*$', fontsize = '12')\n\n#Axe x et y:\nax2.plot(xt, np.zeros_like(xt), color = 'k', linestyle = 'dashed')\nax2.plot(np.zeros_like(yt), yt, color = 'k', linestyle = 'dashed')\n\n#Droite capacité:\nx = np.arange(0, 10, 0.01)\nax2.plot(x, -x + Kx + Ky, label = '$K_x+K_y$', color = \"0.8\")\n\n#Plot des équilibres:\nax2.plot(xeq, yeq, marker = '.', markersize = 12)\nax2.plot(0, 0, marker = '.', markersize = 12, color = 'C5')\n\n#Ellipse:\nxg2 = np.arange(-5, 5, 0.01)\nyg2 = np.arange(-5, 5, 0.01)\nX2, Y2 = np.meshgrid(xg2, yg2)\n\nX = rx * X2 * (1 - X2/Kx)\nY = ry * Y2 * (1 - Y2/Ky)\nax2.contour(X2, Y2, (X + Y), [0], colors = 'C1')\nax2.plot(0, 0, color = 'C1', label = 'Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx * np.ones_like(xt), xt, color = 'C9', label = 'Parabole β = 0')\nax2.plot(np.zeros_like(xt), xt, color = 'C9')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt, xt * gy/gx, color = 'C6', label = 'Parabole β = $+\\infty$')\n\n#A:\nax2.plot(Kx, Ky, color = 'black', marker = '.')\nax2.text(Kx - 0.1, Ky - 0.1, '$A$')\n\n#C:\nax2.plot(Kx, gy * Kx/gx, color = 'black', marker = '.')\nax2.text(Kx, gy * Kx/gx - 0.1, 'C')\n\n#B:\nax2.plot(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky),((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) \\\n                                        , color = 'black', marker = '.')\n\nax2.text(((gx/gy) * rx + ry)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) - 0.1, ((gy/gx) * ry + rx)/((gx/gy) * rx/Kx + (gy/gx) * ry/Ky) + 0.1 \\\n                                        , '$B$')\n\n#D:\nax2.plot(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx), rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx), color = 'black', marker = '.')\nax2.text(ry * Kx * (Kx + Ky)/(rx * Ky + ry * Kx) - 0.1, rx * Ky * (Kx + Ky)/(rx * Ky + ry * Kx) + 0.1, '$D$')\n\n## Nous plaçons des textes indiquant les trois droites:\nax2.text(0.1, yeq, \"$P_{10}$\")\nax2.text(Kx + 0.05, 4, \"$P_{20}$\")\nax2.text(3, 5.5, \"$P_\\infty$\")\n\n#Légende:\nax2.legend(loc=\"upper left\");\n\n\n\n\n\nFigure 3: Plan de phase complet du modèle\n\n\n\n\n\nPremière condition de déflation\nLa première condition d’inflation est exactement la même que dans le modèle précédent et la preuve est en tout point égale (elle repose sur une analyse de l’équation de l’ellipse qui est la même dans les deux modèles). Nous ne détaillerons pas ici cette preuve mais nous savons donc que :\nSi r_x = r_y alors le système est tout le temps déflationniste.\n\n\nDeuxième condition de déflation\nNous allons faire une preuve graphique de cette condition similaire à l’ancien modèle.\nL’équilibre vit sur l’ellipse et parcourt l’arc orange entre A et B au fur et à mesure que \\beta augmente.\nAinsi pour avoir déflation nous allons vouloir avoir cet arc entièrement sous la droite d en gris.\nIl est alors facile de voir que pour cela nous voulons que la coordonnée en y de C soit plus grande que celle de A (C est plus haut sur la droite cyan que A), entraînant que la coordonnée en x de B est plus petite que celle de A (B se trouve plus à gauche sur l’ellipse que A).\nPour cela nous avons besoin de connaître les coordonnées de A et C.\nLe point A est défini comme la valeur de l’équilibre sans migration. Il est alors facile de constater que dans ce cas nous sommes face à un système avec une croissance logistique seulement et donc l’équilibre est atteint pour les capacités de charge.\nNous avons donc A = (K_x,K_y).\nPour C nous savons que c’est l’intersection entre P_{20} et P_{\\infty}, ainsi comme P_{20} est défini par x^* = K_x et P_{\\infty} par y^* =\\frac{\\gamma_y}{\\gamma_x}x^* nous avons :\nC = (K_x,\\frac{\\gamma_yK_x}{\\gamma_x}).\nLa condition mathématique qui en découle est donc que le système est déflationniste si \\frac{\\gamma_yK_x}{\\gamma_x} &gt; K_y.\nSi \\frac{\\gamma_y}{\\gamma_x} &gt; \\frac{K_y}{K_x} alors le système (1) est toujours déflationniste.\n\n\nConditions d’inflation et/ou de déflation\nSimilairement à la première partie nous allons avoir des conditions sur l’inflation.\nEn effet, nous voyons bien sur le plan de phase que si B est entre A et D alors l’arc d’ellipse que parcourent les équilibres en fonction de \\beta est constamment inflationniste.\nAinsi nous voulons que B soit à droite de A ce qui revient à prendre la condition inverse de celle énoncée plus haut (c’est à dire la coordonnées y de C plus petite que celle de A), c’est à dire \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x}.\nEnsuite pour avoir B entre A et D nous allons vouloir que la pente de P_{\\infty} soit plus haute que celle de la droite passant par (0,0) et D que nous appellerons \\aleph.\nPour voir ceci nous allons ajouter la droite \\aleph au plan de phase précédent :\n\n\nCode\n## Ajout de la droite :\nax2.plot(xt, (rx * Ky)/(ry * Kx) * xt, color = 'C5', label = \"Droite א\")\n\nax2.legend(loc=\"upper left\")\n\ndisplay(fig2)\n\n\n\n\n\nFigure 4: Plan de phase complet du modèle\n\n\n\n\nNous avons calculé dans la partie précédente que D = (\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xK_y+r_yK_x} ) ce qui ne change pas dans cette partie car nous considérons des quantités indépendantes des taux de migration.\nLa pente de la droite passant par D et (0,0) est donc égale à \\frac{r_xK_y}{r_yK_x} ce qui donne la condition suivante \\frac{\\gamma_y}{\\gamma_x} &gt; \\frac{r_xK_y}{r_yK_x}.\nSi \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} nous avons un système inflationniste pour tout \\beta.\nIl est alors aisé de voir que si la pente de P_{\\infty} est plus petite que celle de \\aleph nous avons les équilibres qui parcourent d’abord des valeurs au dessus de d puis en dessous (pour aller de A à C).\nLa condition mathématique est donc la suivante :\nSi \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x} alors le système est d’abord inflationniste puis déflationniste lorsque \\beta augmente.\n\n\n\nAnimation\n\n\nCode\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bhhpgtqv\" style = \"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\n\ndisplay.HTML(fig01)\n\n\n\n\n\nFigure 5: Animation Geogebra du plan de phase complet"
  },
  {
    "objectID": "modeleavecmigrationass.html#analyse-du-plan-de-phase",
    "href": "modeleavecmigrationass.html#analyse-du-plan-de-phase",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Analyse du plan de phase",
    "text": "Analyse du plan de phase\nOn va tracer le plan de phase complet et l’analyser.\nPour cela on trace l’ellipse de la même manière que dans la première figure.\nEnsuite on va tracer la droite correspondant à K_x+K_y=x^*+y^*. Ceci va permettre de voir si le système subit une inflation ou une déflation.\nEnfin on trace la parabole donnée par \\dot x =0 pour \\beta = 0 et \\beta = \\infty.\n\n\nCode\n#On crée la figure:\nfig2,ax2=plt.subplots(1,1,figsize=(11,6))\nfig2.suptitle('Plan de phase de la population')\n\n#Plan de phase 1:\n# Paramètres: \nrx=0.5\nry=1\nKx=2\nKy=1\nb=1\ngx=1\ngy=3\n\nparam_aug=np.array([rx,ry,Kx,Ky,b,gx,gy])\n\n# Isocline nulles:\nxt=np.arange(-10,10,0.01)\nyt=np.arange(-10,10,0.01)\n\n#xdot = 0 \nax2.plot(xt,gy*(xt/gx-rx*xt/b*(1-xt/Kx)),color='C2',label='$\\dot x=0$')\n\n#ydot = 0\nax2.plot(gx*(yt/gy-ry*yt/b*(1-yt/Ky)),yt,color='C3',label='$\\dot y=0$')\n\n#Cadrage:\nax2.set_xlim(left=-0.50,right=3)\nax2.set_ylim(top=3,bottom=-0.50)\nax2.set_xlabel('$x$',fontsize='12')\nax2.set_ylabel('$y$',fontsize='12')\n\n#Axe x et y:\nax2.plot(xt,np.zeros_like(xt),color='k',linestyle='dashed')\nax2.plot(np.zeros_like(yt),yt,color='k',linestyle='dashed')\n\n#Droite capacité:\nx=np.arange(0,10,0.01)\nax2.plot(x,-x+Kx+Ky,label='$K_x+K_y$',color='C9')\n\n#Plot des équilibres:\nax2.plot(xeq,yeq,label='Equilibre stable',marker='.',markersize=12)\nax2.plot(0,0,label='Equilibre Instable',marker='.',markersize=12,color='C5')\n\n#Ellipse:\nxg2=np.arange(-5,5,0.01)\nyg2=np.arange(-5,5,0.01)\nX2,Y2=np.meshgrid(xg2,yg2)\n\nX=rx*X2*(1-X2/Kx)\nY=ry*Y2*(1-Y2/Ky)\nax2.contour(X2,Y2,(X+Y),[0],colors='C1')\nax2.plot(0,0,color='C1',label='Ellipse des solutions')\n\n#Parabole xdot=0 b=0:\nax2.plot(Kx*np.ones_like(xt),xt,color='C4',label='Parabole b=0')\n\n#Parabole xdot=0 b=+inf:\nax2.plot(xt,xt*gy/gx,color='C6',label='Parabole b=$+\\infty$')\n\n#A:\nax2.plot(Kx,Ky,color='black',marker='.')\nax2.text(Kx-0.1,Ky-0.1,'$A$')\n\n#B:\nax2.plot(Kx,gy*Kx/gx,color='black',marker='.')\n\n#C:\nax2.plot(((gx/gy)*rx+ry)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky),((gy/gx)*ry+rx)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky),color='black',marker='.')\nax2.text(((gx/gy)*rx+ry)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky)-0.1,((gy/gx)*ry+rx)/((gx/gy)*rx/Kx+(gy/gx)*ry/Ky)+0.1,'$C$')\n\n#D:\nax2.plot(ry*Kx*(Kx+Ky)/(rx*Ky+ry*Kx),rx*Ky*(Kx+Ky)/(rx*Ky+ry*Kx),color='black',marker='.')\nax2.text(ry*Kx*(Kx+Ky)/(rx*Ky+ry*Kx)-0.1,rx*Ky*(Kx+Ky)/(rx*Ky+ry*Kx)-0.1,'$D$')\n\n#Légende:\nax2.legend()\n\n\n&lt;matplotlib.legend.Legend at 0x7f9bf81ea8c0&gt;\n\n\n\n\n\nSi r_x&lt;r_y, alors :\n\n\nSi on note A l’intersection entre la parabole en 0 et l’ellipse et B l’intersection entre la parabole en 0 et en +\\infty alors pour que x^* &lt; K_x (ce que l’on veut) il faut que la coordonnée en y de B soit supérieur à celle de A.\nLe point A est défini par : A=(K_x,K_y)\nLe point B est défini par : B=\\left(K_x,\\frac{\\gamma_yK_x}{\\gamma_x}\\right)\n\nAutrement dit, si \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} alors on a toujours l’augmentorium qui est efficace, ie le système est déflationiste quelque soit le taux de migration \\beta.\n\n\nSi on note C l’intersection entre l’ellipse et la parabole en +\\infty on a alors la valeur de l’équilibre en \\beta =+\\infty.\nLe point C est défini par : C=\\left(\\frac{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)r_x + r_y}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} , \\frac{\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)r_y + r_x}{\\left(\\frac{\\gamma_x}{\\gamma_y}\\right)\\frac{r_x}{K_x}+\\left(\\frac{\\gamma_y}{\\gamma_x}\\right)\\frac{r_y}{K_y}} \\right)\nMaintenant notons D la valeur de l’intersection entre le droite des capacités et l’ellipse.\nLe point D est défini par : D=\\left(\\frac{r_yK_x(K_x+K_y)}{r_xK_y+r_yK_x} , \\frac{r_xK_y(K_x+K_y)}{r_xKy+r_yK_x}\\right)\nAinsi, quand \\beta augmente le point d’équilibre se déplace entre A et C. On voit donc que l’équilibre peut soit être tout le temps déflationiste si C est avant A (point précédent) sur l’ellipse soit être constamment inflationiste si C est entre A et D soit être les deux si C est après D.\nVoyons ceci en terme de coefficient de droite, on a alors les exactes mêmes conditions mais sur les pentes des droites passant par ces points, qu’on peut calculer. On a déja par le premier point la condition sur les paramètres pour avoir le système déflationiste.\n\nSi \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x} alors on a des équilibres à la fois inflationiste et déflationiste. En effet ceci traduit que C est après D, graphiquement on voit que l’équilibre est au début au dessus de la droite cyan et à la fin en dessous (après avoir passé D).\nSi \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} alors les équilibres sont constamment inflationiste.\n\n\nEnfin on observe que si la droite cyan est tangente à l’ellipse alors on a que le système est constamment déflationiste. Ceci correspond au même calcul que dans la première partie et on trouve que si r_x=r_y le système est tout le temps déflationiste pour tout \\beta.\n\n\nMaintenant si on prend r_x&gt;r_y on a un autre cas qui apparaît.\nEn effet, et on le voit bien sur l’animation, on peut alors avoir C entre D et A avec C plus haut que A et ainsi on peut avoir un cas où le système est complètement inflationiste avec des valeurs de la somme des équilibres plus grands que C. Cette situation ne nous intéresse que peu car ce n’est pas un cas qui est biologiquement réaliste.\n\nPreuves:\n\nPoint B:\nLa première coordonnée est forcément K_x car on considère le croisement avec la parabole en \\beta = 0.\nOn sait que la parabole en \\beta = +\\infty est définie par y = \\frac{\\gamma_y}{\\gamma_x}x.\nOn a le résultat pour x=K_x.\nPoint C:\nLa parabole en \\beta = +\\infty est définie par y = \\frac{\\gamma_y}{\\gamma_x}x et l’ellipse par $r_xx(1- {K_x}) + r_yy(1-) = 0 $. Il suffit de remplacer dans l’expression de l’ellipse la valeur de y donnée par la parabole pour trouver la première coordonnée.\nPour trouver la deuxième on utilise l’expression de la parabole.\nPoint D: On fait la même que précédemment. La droite des capacités est définie par y= -x +K_x+K_y qu’on remplace dans l’expression de l’ellipse pour trouver la première coordonnée (après simplifacation). La deuxième est déduite de la la première grâce à l’expression de la droite.\n\nPour les conditions sur les équilibres on se rappelle que la pente de la parabole en \\beta = +\\infty est définie par \\frac{\\gamma_y}{\\gamma_x}.\nAinsi, quand cette pente est inférieure à celle de la droite passant par le point D (qui a une pente de \\frac{r_xK_y}{r_yK_x}) on a soit déflationiste soit inflationiste. On a donc pour condition \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x}.\nEnsuite pour que le système soit entièrement inflationiste on veut que la pente de \\beta = +\\infty soit entre celle de la droite passant par D et celle passant par A (première condition détaillée au premier point de l’analyse.) Ceci donne le résultat.\n\n\nAnimation\n\n\nCode\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width=\"800\" height=\"600\" src=\"https://www.geogebra.org/classic/bhhpgtqv\" style=\"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)\n\n\n\n\n\nFigure 1: Animation Geogebra permettant de voir quels paramètres influencent le système."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "Présentation",
    "section": "Remerciements",
    "text": "Remerciements\n\nJe tiens à remercier Ludovic Mailleret et son équipe pour m’avoir gentillement accueilli et fait confiance. Merci spécialement à Ludovic qui m’a beaucoup supporté et qui a pris de son temps pour m’aider."
  },
  {
    "objectID": "modeleavecmigrationass.html#somme-des-équilibres-en-fonction-de-la-migration",
    "href": "modeleavecmigrationass.html#somme-des-équilibres-en-fonction-de-la-migration",
    "title": "Modèle logistique structuré avec migration asymétrique",
    "section": "Somme des équilibres en fonction de la migration",
    "text": "Somme des équilibres en fonction de la migration\n\nIllustration des propositions précédentes\nNous allons illustrer les propositions précédentes en traçant la somme des équilibres en fonction de \\beta. Pour cela nous allons simuler avec odeint (pendant un temps assez large pour atteindre l’équilibre) pour chaque valeur de \\beta.\nNous définissons une fonction qui dépend de \\beta :\n\n\nCode\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, gy = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n\net nous posons le temps d’intégration, les paramètres et les conditions initiales :\n\n\nCode\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\n\n#4:\nrx4 = 1\nry4 = 2\nKx4 = 2\nKy4 = 1.5\ngx4 = 2\ngy4 = 0.8\n\nparam4 = np.array([rx4, ry4, Kx4, Ky4, gx4, gy4])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 100, 0.01)\n\n#Condition initiale:\ne0 = [1, 1]\n\n\nEt enfin nous traçons les quatre figures :\n\n\nCode\nfig, (ax, ax1, ax2, ax3) = plt.subplots(1, 4, figsize = (9, 4))\nplt.subplots_adjust(wspace = 0.5)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i)) #Nous calculons pour chaque beta l'équilibre\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n\nfor i in np.arange(0, 10, 0.01):\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n    s3 = odeint(aug2, e0, t, args = (param4, i))\n    ax3.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n#Plot de la droite Kx+Ky:    \nxt = np.arange(0, 4, 0.01)\nxt2 = np.arange(0, 10, 0.001)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt2, (Kx2 + Ky2) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.10, Kx2 + Ky2 + 0.006, '$K_x+K_y$')\n\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.12, Kx3 + Ky3 + 0.006, '$K_x+K_y$')\n\nax3.plot(xt2, (Kx4 + Ky4) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax3.text(3.12, Kx4 + Ky4 + 0.006, '$K_x+K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax2.set_xlabel('β')\nax3.set_xlabel('β')\nax.set_ylabel('Population')\nax.plot(0, 0, color = 'C0', label = 'Somme des équilibres')\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (1, -0.65, 0.5, 0.5))\n\n#Titres:\nax.set_title('Déflation');\nax1.set_title('Les deux');\nax2.set_title('Inflation');\nax3.set_title('Inflation');\n\n\n\n\n\nFigure 6: 4 profils de population totale en fonction du taux de migration β\n\n\n\n\nNous obtenons 4 profils de courbe. Le premier profil montre une déflation du système et a été obtenu pour la condition décrite plus haut de \\frac{\\gamma_y}{\\gamma_x} &gt; \\frac{K_y}{K_x}.\nLe deuxième profil correspond à une inflation du système puis une déflation quand \\beta augmente, cette courbe a bien été obtenue en respectant la condition de \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{r_xK_y}{r_yK_x}.\nLes deux derniers profils, correspondant à une inflation permanente du système, sont obtenus en respectant les conditions décrites plus haut. Nous obtenons deux profils différents, un avec une inflation croissante quand \\beta augmente et l’autre avec une inflation croissante puis décroissante (et qui atteint un plateau).\nCe phénomène se voit graphiquement sur l’animation ou le plan de phase. En effet, nous avons dans le premier cas P_{\\infty} qui coupe l’ellipse dans sa phase montante (l’écart entre l’ellipse et la droite d augmente) alors que dans le second cas P_{\\infty} coupe l’ellipse alors que l’écart entre celle-ci et d diminue.\n\n\nCas de l’augmentorium\nDans le cas de l’augmentorium il est important de considérer l’équilibre x^* seul par rapport à K_x (sa valeur s’il n’y a pas de migration).\nEn effet même si nous avons inflation dans le système, si x^*&lt;K_x alors nous considérons l’augmentorium comme efficace.\nAvec les hypothèses énoncées plus haut sur la situation de l’augmentorium il n’est pas possible d’obtenir un système inflationniste (indépendamment de si K_x&gt;K_y ou l’inverse). Il est facile de voir ceci grâce à notre animation.\nNéanmoins avec des hypothèses plus souples (mais en gardant que r_x&lt;r_y), par exemple que les taux de fuites sont plus forts que les taux de migration vers l’augmentorium (dus à une fuite du dispositif par exemple) nous allons voir que l’augmentorium n’est pas forcément bénéfique.\nEn effet, nous pouvons, sur le plan de phase tracé plus haut, voir que dès que nous sommes dans un cas où nous avons de l’inflation (et même si nous revenons sur de la déflation après) alors nous avons x^* &gt; K_x ce qui est mauvais pour la culture.\nNous allons tracer l’équilibre x^* en fonction de \\beta en considérant un cas où le système était déflationniste et un cas où le système était inflationniste (pour la somme des équilibres) :\n\n\nCode\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, gy1])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\n\nparam2 = np.array([rx2, ry2, Kx2, Ky2, gx2, gy2])\n\n#2:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\n\nparam3 = np.array([rx3, ry3, Kx3, Ky3, gx3, gy3])\nfig, (ax, ax1, ax2) = plt.subplots(1, 3, figsize = (9, 4))\nplt.subplots_adjust(wspace= 0.3)\n\nax.set_title('$x^*$ avec déflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\nax1.set_title('$x^*$ avec déflation et inflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\nax2.set_title('$x^*$ avec inflation des équilibres totaux ($x^* + y^*$)', fontsize = 6)\n\n#Boucle en fonction de beta\nfor i in np.arange(0, 4, 0.01):\n    s = odeint(aug2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0], marker = '.', color = 'C0')\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n    s1 = odeint(aug2, e0, t, args = (param2, i))\n    ax1.plot(i, s1[-1][0], marker = '.', color = 'C0')\n    ax1.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n    s2 = odeint(aug2, e0, t, args = (param3, i))\n    ax2.plot(i, s2[-1][0], marker = '.', color = 'C0')\n    ax2.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = \"0.8\", markersize = '4')\n\n#Droite Kx:\nxt = np.arange(0, 4, 0.01)\nax.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 - 0.15, '$K_x$')\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 + Ky1 - 0.15, '$K_x + K_y$')\n\nax1.plot(xt, Kx2 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 - 0.15, '$K_x$')\nax1.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx2 + Ky2 - 0.15, '$K_x + K_y$')\n\nax2.plot(xt, Kx3 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.5, Kx3 - 0.15, '$K_x$')\nax2.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax2.text(3.5, Kx3 + Ky3 - 0.15, '$K_x + K_y$')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\nax.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\nax1.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\nax2.plot(0, 0, color = 'C0', label = 'Eq. culture ($x^*$)')\n\nax.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\nax1.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\nax2.plot(0, 0, color = \"0.8\", label = 'Eq. total ($x^* + y^*$)')\n\n# Nous limitons le cadre :\nax1.set_ylim(bottom=1);\nax2.set_ylim(bottom=1);\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (0.4, -0.65, 0.5, 0.5));\n\n\n\n\n\nFigure 7: Simulation de l’équilibre dans la culture en fonction de β pour différentes conditions d’inflation de la population totale\n\n\n\n\nEn bleu nous observons le comportement de l’équilibre dans la culture seulement et en gris nous retrouvons les courbes tracées juste au dessus. Nous voyons bien que dès que le système subit une inflation des équilibres totaux la situation devient mauvaise pour la culture.\nEn revanche quand nous avons déflation des équilibres totaux alors la situtaion est bénéfique à la culture.\n\n\n\n\n\n\nNote\n\n\n\nOn voit très bien ceci sur notre Figure 3 en regardant où se place l’ellipse orange par rapport à la droite cyan représentant K_x\n\n\nIl faut garder en tête que ceci n’est vrai que pour r_x&lt;r_y.\nEnsuite, le taux de fuite est un paramètre clé de notre méthode. Nous allons donc tracer la somme des équilibres et l’équilibre x^* en fonction de \\gamma_y.\nAttention ! Un fort taux de fuite correspond à un \\gamma_y faible.\n\n\nCode\n#Définition d'un nouveau modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1  \nKx1 = 1\nKy1 = 2\ngx1 = 0.5\nb = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1]\n\n#Figure:\nfig, ax = plt.subplots(1, 1, figsize = (8, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.5, Kx1 - 0.1, '$K_x$')\n\n# Nous plaçons une droite gx en pointillé:\nax.plot(gx1 * np.ones_like(xt), xt, linestyle = 'dashed', color = '0.8')\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.01):\n    s = odeint(aug3, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax.plot(i, s[-1][0], marker = '.', color = 'k')\n\n#Légendes:\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, Kx1 + Ky1, color = 'C0', label = 'Somme des équilibres ($x^*+y^*$)')\nax.plot(0, Kx1, color = 'k', label = 'Eq. culture ($x^*$)')\n\nax.set_title('$x^* + y^*$ et $x^*$ en fonction du taux de fuite', fontsize = 7)\n\nax.legend(fontsize = '7');\nax.set_ylabel(\"Densité de pop.\");\n\n\n\n\n\nFigure 8: Population totale et dans la culture en fonction du taux de fuite\n\n\n\n\nDans la figure gauche nous avons représenté la somme des équilibres (x^*+y^*) de la même manière que précédemment mais cette fois en faisant varier le taux de fuite.\nNous observons alors un nouveau profil qui correspond à une déflation, puis une inflation puis enfin une déflation au fur et à mesure que \\gamma_y augmente.\nDans la figure droite nous avons cette fois uniquement l’équilibre dans la culture (x^*). Nous observons que pour des \\gamma_y petits nous avons inflation puis nous retournons à une déflation.\nPour représenter cette figure nous avons considéré que r_x&lt;r_y et K_x&lt;K_y sans perte de généralité.\nPour interpréter ceci il faut comprendre que les des petites valeurs de \\gamma_y correspondent à de grandes valeurs de taux de fuite.\nAinsi quand \\gamma_y \\to 0 l’augmentorium se vide en ravageurs et nous avons ainsi toute la population dans la culture et l’équilibre dans la culture tend vers sa capacité de charge car nous sommes seulement face à une croissance logistique.\nNous C’est pourquoi, lorsque les taux de fuite sont grands nous observons une inflation de la culture car nous avons, des populations de ravageurs qui viennent de l’augmentorium qui s’ajoutent aux ravageurs déjà présents dans la culture.\nLa somme des équilibres est donc trompeuse dans ce cas là, en effet le système subit une déflation car l’augmentorium n’est presque plus occupé pour de forts taux de fuite mais il ne faut pas croire que c’en est bénéfique pour la culture.\nCe modèle considère uniquement la population de ravageurs. Or, la méthode de l’augmentorium repose énormément sur l’action des prédateurs nous allons donc considérer maintenant un modèle qui prend en compte ces prédateurs."
  },
  {
    "objectID": "modeleavecmigrationass.html#conclusion",
    "href": "modeleavecmigrationass.html#conclusion",
    "title": "Modèle logistique structuré avec migration assymétrique",
    "section": "Conclusion",
    "text": "Conclusion\nCe modèle considère uniquement la population de ravageurs. Or, la méthode de l’augmentorium repose énormément sur l’action des prédateurs on va donc considérer maintenant un modèle qui prend en compte ces prédateurs."
  },
  {
    "objectID": "modelsimpleaug.html#définition-du-modèle",
    "href": "modelsimpleaug.html#définition-du-modèle",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nCe modèle est un modèle de prédation de Lotka-Volterra où les proies se répartissent en deux structures et les prédateurs diffusent librement entre les deux strcutures.\nNous partirons pour être plus général du postulat que la prédation et les naissances sont diférentielles entre les structures mais certaines analyses se baseront sur une égalité des naissances par exemple.\nNous considérons le modèle suivant :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\navec:\n- r_x le taux de croissance de x dans la culture,\n- r_y le taux de croissance de y dans l’augmentorium,\n- K_x la capacité maximale de la culture,\n- K_y la capacité maximale de l’augmentorium,\n- \\beta la force de migration,\n- \\gamma_x le taux d’assymétrie de la migration culture vers augmentorium,\n- \\gamma_y le taux d’assymétrie de la migration augmentorium vers culture,\n- p_x,p_y la prédation de z sur x ou y,\n- n_x,n_y le taux de conversion proie prédateur dans la culture ou l’augmentorium (naissance due à la prédation),\n- m la mortalité des prédateurs z.\nOn a donc maintenant un espace structuré en deux zones, s’échangeant assymétriquement de la population (qui grandit logisitiquement), le tout controlé par une population de prédateurs ne chassant et ne se reproduisant pas de la même manière dans les deux zones.\n\nNouvelles hypothèses :\nOn pose p_y &gt; p_x et n_y&gt;n_x.\nEn effet l’augmentorium est un lieu propice au développement des individus que ce soit les parasites ou les ravageurs.\nAinsi la prédation exercé sur les ravageurs est plus forte dans l’augmentorium et les naissances des prédateurs sont plus fortes dans l’augmentorium que dans la culture."
  },
  {
    "objectID": "modelsimpleaug.html#dynamique-des-populations",
    "href": "modelsimpleaug.html#dynamique-des-populations",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Dynamique des populations",
    "text": "Dynamique des populations\nOn va encore une fois simuler comment se comporte les trois populations en fonction du temps.\nLe code commenté est acessible dans la boite cachée ci dessous:\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat,t,param):\n    x,y,z=etat\n    rx,Kx,ry,Ky,gx,gy,b,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Paramètres Simulation 1 : \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\ngx1=0.5\ngy1=3\nb1=1\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,b1,px1,py1,nx1,ny1,m1])\n\n#Paramètres Simulation 2: \nrx2=0.5\nry2=1\nKx2=2\nKy2=1\ngx2=0.5\ngy2=3\nb2=1\npx2=0.5\npy2=1\nnx2=0.5\nny2=1\nm2=2\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,b2,px2,py2,nx2,ny2,m2])\n\n#Temps d'intégration 1,2:\nt3=np.arange(0,200,0.01)\nt4=np.arange(0,50,0.01)\n\n#Condition initiale de 1,2:\nx0=2\ny0=0\nz0=0.5\nc0=np.array([x0,y0,z0])\n\n#Simulation 1,2:\ns3=odeint(a,c0,t3,args=(param_a1,))\ns4=odeint(a,c0,t4,args=(param_a2,))\n\n#Plot de la figure: \nfig,ax = plt.subplots(1,2,figsize=(14,5))\nfig.suptitle('Simulation du modèle d\\'augmentorium')\nplt.subplots_adjust(hspace=0.4)\n\n#Plot de l'axe 1:\nax[0].plot(t3,s3[:,0],color='C0',label='Ravageur dans la culture')\nax[0].plot(t3,s3[:,1],color='C1',label='Ravageur dans l\\'augmentorium')\nax[0].plot(t3,s3[:,2],color='C6',label='Prédateurs totaux')\n\n#Plot de l'axe 2:\nax[1].plot(t4,s4[:,0],color='C0',label='Ravageur dans la culture')\nax[1].plot(t4,s4[:,1],color='C1',label='Ravageur dans l\\'augmentorium')\nax[1].plot(t4,s4[:,2],color='C6',label='Prédateurs totaux')\n\n\n#Légendes et titres:\nax[0].set_ylabel('Population, x,y,z')\nax[0].legend(fontsize=8)\nax[0].grid()\nax[0].set_xlabel('Temps, t')\nax[0].set_ylim(top=2,bottom=-0.05)\nax[0].set_title('Coexistence des trois populations',fontsize=7.5)\n\nax[1].set_xlabel('Temps, t')\nax[1].set_ylabel('Population, x,y,z')\nax[1].legend(fontsize=8)\nax[1].grid()\nax[1].set_ylim(top=2,bottom=-0.05)\n\nax[1].set_title('Disparition des parasites, maintien des ravageurs',fontsize=7.5)\n\n\nText(0.5, 1.0, 'Disparition des parasites, maintien des ravageurs')\n\n\n\n\n\nLes profils de dynamique se répartissent en deux grandes catégories. Ceux où la population de prédateurs survit et celle où elle disparaît. Il semble donc il y a voir deux équilibres stables dans ce système.\nPour de faibles temps t on observe des oscillations à la Lotka-Volterra.\nLe profil de la dynamique de la population sans prédateurs est similaire au modèle avec seulement les proies et la migration assymétrique. On verra dans la suite que ces deux modèles sont complètement confondus (sans prédateurs)."
  },
  {
    "objectID": "modelsimpleaug.html#plan-de-phase",
    "href": "modelsimpleaug.html#plan-de-phase",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Plan de phase",
    "text": "Plan de phase\nPour tracer le plan de phase on pose toutes les variations égales à 0 (situation d’équilibre) :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n0 = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n0 = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n qui devient :\n\n\\left\\{\\begin{array}{l}\nz_1 = \\frac{r_x}{p_x}\\left(1-\\frac{x}{K_x}\\right)+\\frac{\\beta}{p_xx}\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\nz_2 = \\frac{r_y}{p_y}\\left(1-\\frac{y}{K_y}\\right)+\\frac{\\beta}{p_yy}\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\\\\\nz=0 \\lor n_xx+n_yy=m\n\\end{array}\\right.\n\nOn se retrouve avec deux surfaces et deux plans dont les intersections seront les équilibres. Voyons ceci avec une animation :\n\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width=\"600\" height=\"500\" src=\"https://www.geogebra.org/classic/bw3wqnzg\" style=\"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)"
  },
  {
    "objectID": "modelaug.html",
    "href": "modelaug.html",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "",
    "text": "Modules à importer :\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport plotly.express as px"
  },
  {
    "objectID": "modelaug.html#définition-du-modèle",
    "href": "modelaug.html#définition-du-modèle",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nCe modèle est un modèle de prédation de Lotka-Volterra où les proies se répartissent en deux structures et les prédateurs diffusent librement entre les deux strcutures.\nNous partirons pour être plus général du postulat que la prédation et les naissances sont diférentielles entre les structures mais certaines analyses se baseront sur une égalité des naissances par exemple.\nNous considérons le modèle suivant d’après Freedman H. I. (1977):\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{1}\navec:\n- r_x le taux de croissance de x dans la culture,\n- r_y le taux de croissance de y dans l’augmentorium,\n- K_x la capacité maximale de la culture,\n- K_y la capacité maximale de l’augmentorium,\n- \\beta la force de migration,\n- \\gamma_x le taux d’asymétrie de la migration culture vers augmentorium,\n- \\gamma_y le taux d’asymétrie de la migration augmentorium vers culture,\n- p_x,p_y la prédation de z sur x ou y,\n- n_x,n_y le taux de conversion proie prédateur dans la culture ou l’augmentorium (naissance due à la prédation),\n- m la mortalité des prédateurs z.\nNous avons donc maintenant un espace structuré en deux zones, s’échangeant asymétriquement de la population (qui grandit logisitiquement), le tout controlé par une population de prédateurs ne chassant et ne se reproduisant pas de la même manière dans les deux zones.\n\nHypothèses propres à l’augmentorium\nSi nous voulons simuler une condition d’augmentorium alors nous poserons p_y &gt; p_x et n_y&gt;n_x.\nEn effet l’augmentorium est un lieu propice au développement des individus que ce soit les prédateurs ou les ravageurs.\nAinsi la prédation exercé sur les ravageurs est plus forte dans l’augmentorium et les naissances des prédateurs sont plus fortes dans l’augmentorium que dans la culture.\nDans la suite nous resterons général pour analyser le modèle."
  },
  {
    "objectID": "modelaug.html#dynamique-des-populations",
    "href": "modelaug.html#dynamique-des-populations",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Dynamique des populations",
    "text": "Dynamique des populations\nNous allons encore une fois simuler comment se comporte les trois populations en fonction du temps.\nLe code commenté est acessible dans la boite cachée ci dessous:\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat, t, param):\n    x, y, z = etat\n    rx, Kx, ry, Ky, gx, gy, b, px, py, nx, ny, m = param\n    xdot, ydot, zdot = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx) - px * z * x, ry * y * (1 - y/Ky) + b * (x/gx - y/gy) - py * y * z, z * (nx * x + ny * y - m)]\n    return [xdot, ydot, zdot]\n\n#Paramètres Simulation 1 : \nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\nb1 = 1\npx1 = 0.5\npy1 = 1\nnx1 = 0.5\nny1 = 1\nm1 = 0.5\n\nparam_a1 = np.array([rx1, Kx1, ry1, Ky1, gx1, gy1, b1, px1, py1, nx1, ny1, m1])\n\n#Paramètres Simulation 2: \nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 0.5\ngy2 = 3\nb2 = 1\npx2 = 0.5\npy2 = 1\nnx2 = 0.5\nny2 = 1\nm2 = 2\n\nparam_a2 = np.array([rx2, Kx2, ry2, Ky2, gx2, gy2, b2, px2, py2, nx2, ny2, m2])\n\n#Temps d'intégration 1,2:\nt3 = np.arange(0, 90, 0.01)\nt4 = np.arange(0, 50, 0.01)\n\n#Condition initiale de 1,2:\nx0 = 2\ny0 = 0\nz0 = 0.5\nc0 = np.array([x0, y0, z0])\n\n#Simulation 1,2:\ns3 = odeint(a, c0, t3, args = (param_a1,))\ns4 = odeint(a, c0, t4, args = (param_a2,))\n\n#Plot de la figure: \nfig, ax = plt.subplots(1, 2, figsize = (8, 4))\nfig.suptitle('Simulation du modèle d\\'augmentorium')\nplt.subplots_adjust(hspace = 0.4)\n\n#Plot de l'axe 1:\nax[0].plot(t3, s3[:, 0], color = 'C0', label = 'Ravageurs dans la culture')\nax[0].plot(t3, s3[:, 1], color = 'C1', label = 'Ravageurs dans l\\'augmentorium')\nax[0].plot(t3, s3[:, 2], color = 'C6', label = 'Prédateurs totaux')\n\n#Plot de l'axe 2:\nax[1].plot(t4, s4[:, 0], color = 'C0', label = 'Ravageurs dans la culture')\nax[1].plot(t4, s4[:, 1], color = 'C1', label = 'Ravageurs dans l\\'augmentorium')\nax[1].plot(t4, s4[:, 2], color = 'C6', label = 'Prédateurs totaux')\n\n\n#Légendes et titres:\nax[0].set_ylabel('Population, x,y,z')\nax[0].legend(fontsize = 8)\nax[0].grid()\nax[0].set_xlabel('Temps, t')\nax[0].set_ylim(top = 2, bottom = -0.05)\nax[0].set_title('Coexistence des trois populations', fontsize = 7.5)\n\nax[1].set_xlabel('Temps, t')\nax[1].set_ylabel('Population, x,y,z')\nax[1].legend(fontsize = 8)\nax[1].grid()\nax[1].set_ylim(top = 2, bottom = -0.05)\n\nax[1].set_title('Disparition des prédateurs, maintien des ravageurs',fontsize = 7.5);\n\n\n\n\n\nFigure 1: Simulation de la dynamique de la population\n\n\n\n\nLes profils de dynamique se répartissent en deux grandes catégories. Ceux où la population de prédateurs survit et celle où elle disparaît. Il semble donc que le système possède un équilibre stable qui varie selon les paramètres du système.\nPour de faibles temps t nous observons des oscillations à la Lotka-Volterra.\nLe profil de la dynamique de la population sans prédateurs est similaire au modèle avec seulement les proies et la migration asymétrique. Nous verrons dans la suite que ces deux modèles sont complètement confondus (sans prédateurs)."
  },
  {
    "objectID": "modelaug.html#plan-de-phase",
    "href": "modelaug.html#plan-de-phase",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Plan de phase",
    "text": "Plan de phase\nPour tracer le plan de phase on pose toutes les variations égales à 0 (situation d’équilibre) :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)-p_xx^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)-p_yy^*z^* \\\\\n0 = z^*\\left(n_xx^*+n_yy^* - m\\right)\n\\end{array}\\right.\n\\tag{2}\nqui devient :\n\n\\left\\{\\begin{array}{l}\nz^* = \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right)+\\frac{\\beta}{p_xx^*}\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)\\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right)+\\frac{\\beta}{p_yy^*}\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)\\\\\nz^*=0 \\lor n_xx^*+n_yy^*=m\n\\end{array}\\right.\n\\tag{3}\nOn se retrouve avec deux surfaces et deux plans dont les intersections seront les équilibres. Voyons ceci avec une animation :\n\n\nCode\nimport IPython.display as display\nfig01 = \"\"\"\n&lt;iframe width=\"700\" height=\"550\" src=\"https://www.geogebra.org/classic/bw3wqnzg\" style=\"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\ndisplay.HTML(fig01)\n\n\n\n\n\n\nEn vert on a l’intersection entre la surface définie par \\dot x =0 et les plans z=0 et n_xx+n_yy=m.\nEn rouge on a l’intersection entre la surface définie par \\dot y =0 et les plans z=0 et n_xx+n_yy=m.\nOn a donc que l’intersetion des courbes vertes et rouges sont les équilibres. Il est facile de voir qu’il n’en existe que trois différents dont un seul correspond à la coexistence des trois populations.\n\nCalcul des équilibres\nSi z=0 alors (1) devient:\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{4}\nqui est exactement le système considéré précedemment. Pour l’analyse de ses équilibres se référer à ceci.\nOn va donc s’intéresser uniquement à l’équilibre de coexistence qu’on notera (x^* , y^* , z^*).\nNous allons calculer pour différentes valeurs de \\beta les valeurs de l’équilibre.\n\nLorsque \\beta = 0\n(2) devient : \n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)-p_xx^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)-p_yy^*z^* \\\\\n0 = z^*\\left(n_xx^*+n_yy^* - m\\right)\n\\end{array}\\right.\n\\tag{5} \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\nz^* = \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) \\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right) \\\\\ny^* = \\frac{1}{n_y}\\left(m-n_xx^*\\right)\n\\end{array}\\right.\n\\tag{6} et ainsi :\n\n\\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) = \\frac{r_y}{p_y}\\left(1-\\frac{m}{n_yK_y}+\\frac{n_xx^*}{n_y}\\right)\n et donc : \nx^*=\\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\n\nOn déduit y^* et z^* avec leur définition d’après (6): \n\\left\\{\\begin{array}{l}\nx^* =  \\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x} \\\\\ny^* = \\frac{K_y\\left(r_yn_xp_xK_x+r_xp_ym - r_xn_xp_yK_x\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x} \\\\\nz^* = r_xr_y\\left(\\frac{n_xK_x+n_yK_y-m}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\right)\n\\end{array}\\right.\n\\tag{7}\n\n\n\n\n\n\nWarning\n\n\n\nLe document de Freedman (1977) contient deux erreurs, un B_1 à la place d’un \\beta_1 dans l’expression de y^* (respectivement x_{20} dans son article) et un p_y à la place d’un p_x dans l’expression de z^* (respectivement un \\beta_2 à la place d’un \\beta_1 selon ses notations).\n\n\nPour que ces équilibres soient positifs il faut que :\n\n-\\frac{mr_y}{K_yn_yp_y} &lt; \\frac{r_x}{p_x} - \\frac{r_y}{p_y} &lt; \\frac{mr_x}{K_xn_xp_x}\n\\tag{8}\net\n\nn_xK_x+n_yK_y &gt; m\n\\tag{9}\nOn verra dans la suite que la condition (9) est l’invasion des prédateurs.\n\n\nLorsque \\beta \\ne 0 et petit\nPour \\beta petit on va utiliser l’égalité de Taylor pour trouver (x_*,y^*,z^*). On a alors, si on note (x^*(\\beta),y^*(\\beta),z^*(\\beta)):\n\n\\left\\{\\begin{array}{l}\nx^*(0) = \\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\\\\ny^*(0) = \\frac{K_y\\left(r_yn_xp_xK_x+r_xp_ym - r_xn_xp_yK_x\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\\\\nz^*(0) = r_xr_y\\left(\\frac{n_xK_x+n_yK_y-m}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\right)\n\\end{array}\\right. \\\\\n\nSoit \\mathbb{F(x,y,z,\\beta)} tel que : \n\\mathbb{F(x,y,z,\\beta)} = \\left\\{\\begin{array}{l}\nr_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\nr_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\nz\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right. \\\\\n On veut ainsi résoudre : \n\\mathbb{F\\left(\\mathcal{x}^*(\\beta) , \\mathcal{y}^*(\\beta) , \\mathcal{z}^*(\\beta) , \\beta\\right)}=0\n\nor, d’après la formule de Taylor on a à l’ordre 1 en dimension 4 on a:\n\n\\mathbb{F\\left(\\mathcal{x}^*(\\beta) , \\mathcal{y}^*(\\beta) , \\mathcal{z}^*(\\beta) , \\beta\\right)}=\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)} + \\\\\n\\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta + \\mathbb{J}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}}\\small\\begin{pmatrix} \\mathcal{x}^*(\\beta) - \\mathcal{x}^*(\\mathcal{0}) \\\\ \\mathcal{y}^*(\\beta) - \\mathcal{y}^*(\\mathcal{0}) \\\\ \\mathcal{z}^*(\\beta) - \\mathcal{z}^*(\\mathcal{0}) \\end{pmatrix} + o(\\beta)\n\\tag{10} \n\\Leftrightarrow\n \n\\begin{pmatrix} \\mathcal{x}^*(\\beta) \\\\ \\mathcal{y}^*(\\beta) \\\\ \\mathcal{z}^*(\\beta) \\end{pmatrix} =\n\\begin{pmatrix} \\mathcal{x}^*(\\mathcal{0}) \\\\  \\mathcal{y}^*(\\mathcal{0}) \\\\  \\mathcal{z}^*(\\mathcal{0}) \\end{pmatrix} - \\mathbb{J^{\\mathcal{-1}}}\\tiny{\\mathbb{F\\left(\\mathcal{x}_2^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} \\small\\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta + o(\\beta)\n\nOn a, \\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta = \\begin{pmatrix} -\\frac{\\mathcal{x}^*(\\mathcal{0})}{\\gamma_x}+\\frac{\\mathcal{y}^*(\\mathcal{0})}{\\gamma_y}\\\\\\frac{\\mathcal{x}^*(\\mathcal{0})}{\\gamma_x}-\\frac{\\mathcal{y}^*(\\mathcal{0})}{\\gamma_y}\\\\ 0\\end{pmatrix} .\net, \n\\mathbb{J}\\small{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} =\n\\begin{pmatrix} -\\frac{r_xx^*(0)}{K_x} & 0 & -p_xx^*(0) \\\\ 0 & -\\frac{r_yy^*(0)}{K_y} & -p_yy^*(0) \\\\ n_xz^*(0) & n_yz^*(0) & 0 \\end{pmatrix}\n\nil est alors facile de calculer que, \ndet(\\mathbb{J}) = -x^*(0)y^*(0)z^*(0)\\left(\\frac{r_xn_yp_y}{K_x}+\\frac{r_yn_xp_x}{K_y}\\right) \\ne 0\n\nLa jacobienne est donc bien inversible et on peut la calculer (méthode des cofacteurs) ce qui donne : \n\\mathbb{J^{\\mathcal{-1}}}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} =\\small \\frac{1}{\\frac{r_xp_yn_y}{K_x}+\\frac{r_yp_xn_x}{K_y}} \\begin{pmatrix} -\\frac{p_yn_y}{x^*(0)} & \\frac{p_xn_y}{y^*(0)} & \\frac{r_yp_x}{z^*(0)K_y} \\\\ \\frac{p_yn_x}{x^*(0)} & -\\frac{p_xn_x}{y^*(0)} & \\frac{r_xp_y}{z^*(0)K_x} \\\\ -\\frac{r_yn_x}{x^*(0)K_y} & -\\frac{r_xn_y}{y^*(0)K_x}& -\\frac{r_xr_y}{z^*(0)K_xK_y} \\end{pmatrix}\n\\tag{11}\nEn mettant en œuvre le calcul on trouve : \n\\left\\{\\begin{array}{l}\nx^*(\\beta) = x^*(0) - \\frac{\\beta n_yK_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{p_y}{x^*(0)}+\\frac{p_x}{y^*(0)}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\\\\\ny^*(\\beta) = y^*(0) - \\frac{\\beta n_xK_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{p_y}{x^*(0)}+\\frac{p_x}{y^*(0)}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\\\\\nz^*(\\beta) = z^*(0) - \\frac{\\beta K_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{r_xn-y}{y^*(0)K_x}-\\frac{r_yn_x}{x^*(0)K_y}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\n\\end{array}\\right.\\\\\n\\tag{12}\n\n\nLorsque \\beta est quelconque\n(2) donne, en exprimant y^* en fonction de x^*: \n\\left\\{\\begin{array}{l}\nz^* =  \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{\\beta}{p_x}\\left(\\frac{m}{n_y\\gamma_y x^*}-\\frac{n_x}{n_y\\gamma_y}-\\frac{1}{\\gamma_x}\\right)   \\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{m-n_xx^*}{n_yK_y}\\right) + \\frac{\\beta n_y}{p_y}\\left(\\frac{x^*}{\\gamma_x\\left(m-n_xx^*\\right)}-\\frac{1}{n_y\\gamma_y}\\right) \\\\\ny^* =\\frac{1}{n_y}\\left(m- n_xx^*\\right)\n\\end{array}\\right.\n\\tag{13}\nOn trouve x^* en faisant l’intersection entre les deux premières équations, on trouve y^* avec la troisième équation et z^* avec la première équation.\nPour calculer l’équilibre on utilise numpy:\n\n\nCode\n#Calcul de x*:\nx=np.polynomial.Polynomial([0,1])\n#Polynome :\npol1= (m1-nx1*x)*x*rx1/px1*(1-x/Kx1) + (m1-nx1*x)*b1/px1*((m1-nx1*x)/(ny1*gy1) - x/gx1) - (m1-nx1*x)*x*ry1/py1*(1-(m1-nx1*x)/(ny1*Ky1)) - x*b1*ny1/py1*(x/gx1 - (m1-nx1*x)/(ny1*gy1))\n#On utilise un masque booléen adapté à la situation --&gt; solution réelle, positive et qui vérifie la condtion imposée par la troisième équation du système:\nsolx=pol1.roots()[(np.isreal(pol1.roots())) *(pol1.roots() &gt; 0)*(pol1.roots()&lt;m1/ny1)]\n\n#Calcul de y*:\nsoly=1/ny1*(m1-nx1*solx)\n\n#Calcul de z*:\nsolz=rx1/px1*(1-solx/Kx1) + b1/px1*(m1/(ny1*gy1*solx) -nx1/(ny1*gy1)- 1/gx1)\n\n\n\n\n\nStabilité des équilibres\nSans prédateurs (z=0) on a les mêmes équilibres que dans la partie précédente, la stabilité est donc la même que dans la partie précédente.\nOn va calculer pour différentes valeurs de \\beta la stabilité.\n\nLorsque \\beta=0\nLa jacobienne du système est: \n\\mathbb{J_{\\mathcal{x^*_2},\\mathcal{y^*_2},\\mathcal{z^*_2},\\mathcal{0}}}  =  \\begin{pmatrix} -\\frac{r_xx_2^*(0)}{K_x} & 0 & -p_xx_2^*(0) \\\\ 0 & -\\frac{r_yy_2^*(0)}{K_y} & -p_yy_2^*(0) \\\\ n_xz_2^*(0) & n_yz_2^*(0) & 0 \\end{pmatrix}\n\nEn calculant le polynôme caractéristique on en déduit que toutes les parties réelles des valeurs propres sont négatives et que donc l’équilibre est stable. La preuve est faite par Freedman dans son théorème 4.1.\n\n\nLorsque \\beta \\ne 0 et \\beta petit\n\n\\mathbb{J_{\\mathcal{x^*},\\mathcal{y^*},\\mathcal{z^*},\\mathcal{\\beta}}}  =  \\begin{pmatrix} -\\frac{r_xx^*(0)}{K_x} -\\frac{\\beta}{\\gamma_x} & \\frac{\\beta}{\\gamma_y} & -p_xx^*(0) \\\\ \\frac{\\beta}{\\gamma_x} & -\\frac{r_yy^*(0)}{K_y}-\\frac{\\beta}{\\gamma_y} & -p_yy^*(0) \\\\ n_xz^*(0) & n_yz^*(0) & 0 \\end{pmatrix} = \\mathbb{J_{\\mathcal{x^*},\\mathcal{y^*},\\mathcal{z^*},\\mathcal{0}}} + \\beta \\begin{pmatrix} -\\frac{1}{\\gamma_x} & \\frac{1}{\\gamma_y} & 0 \\\\ \\frac{1}{\\gamma_x} & -\\frac{1}{\\gamma_y} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n\nComme \\beta est petit on a la matrice qui est petite et qui n’influence pas le signe des valeurs propres. Donc l’équilibre est encore stable."
  },
  {
    "objectID": "modelaug.html#equilibres-en-fonction-des-paramètres",
    "href": "modelaug.html#equilibres-en-fonction-des-paramètres",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Equilibres en fonction des paramètres",
    "text": "Equilibres en fonction des paramètres\nDans cette partie on va distinguer les cas où n_x = n_y et p_x=p_y de ceux où ils sont différents.\nEn effet, l’un des postulats de l’augmentorium est que le dévellopement des ravageurs et prédateurs est favorisé dans celui-ci mais on peut supposer que la prédation et les naissances dans l’augmentorium sont égales.\nIl est intéressant de considérer la somme des équilibre des proies en fonction de la force de migration (\\beta) et les équilibres dans la culture en fonction du taux de fuite (\\gamma_y) et du taux de migration (\\gamma_x).\n\nPrédation et naissances égales\nDans ce cas (1) devient :\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-pxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-pyz \\\\\n\\dot z = z\\left(n\\left(x+y\\right) - m\\right)\n\\end{array}\\right.\n\\tag{14}\n\nSomme des équilibres des proies en fonction de \\beta\nA l’équilibre, on a :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)-px^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)-py^*z^* \\\\\nx^*+y^* = \\frac{m}{n}\n\\end{array}\\right.\n\\tag{15}\nOn voit, avec la troisième équation du système, que la somme des équilibres des proies est toujours égale à \\frac{m}{n} quelque soit \\beta du moment que les prédateurs sont présents.\nIntuitivement on considère que la présence d’un équilibre des prédateurs positifs (invasion des prédateurs) est soumise à la condition que pour une population aussi petite soit elle de prédateurs (\\beta \\to 0) et pour les proies à l’équilibre on ait un taux de croissance positif pour les prédateurs.\nMathématiquement cette assomption est équivalente à la condition, si on note (x_0^*(\\beta),y^*_0(\\beta)) l’équilibre sans prédateurs pour un taux \\beta, que x_0^* + y_0^* &gt; \\frac{m}{n} \\Leftrightarrow \\exists z^* \\ne 0.\nPour \\beta = 0 on a que s’il existe un équilibre des prédateurs positif alors on a K_x+K_y&gt;\\frac{m}{n} par l’égalité (7). Ceci est donc la condition d’invasion des prédateurs (9) mentionnée plus tôt.\nSi \\beta = \\infty on va réduire le système (14) en équation de Lotka-Volterra avec croissance logistique. Ainsi la présence d’un équilibre des prédateurs impliquera la condition d’invasion supposée.\nLa démarche à partir du système (14) est la suivante :\n\n\\dot x - \\dot y = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right) - r_yy^*\\left(1-\\frac{y^*}{K_y}\\right) + pz\\left(y-x\\right) -2\\beta \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\tag{16}\nQuand \\beta \\to \\infty, \\dot x - \\dot y devient : \n\\dot x - \\dot y = -2\\beta \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\net donc on a forcément que \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right) \\to 0 ie que \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\nOn pose N = x+y qui est, avec l’assertion précédente, équivalent à \n\\frac{N}{\\gamma_x+\\gamma_y} = \\frac{x+y}{\\gamma_x+\\gamma_y} = \\frac{\\frac{x\\gamma_x}{\\gamma_x}+\\frac{y\\gamma_y}{\\gamma_y}}{\\gamma_x+\\gamma_y} = \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}\n\\tag{17}\nOn a ainsi : \n\\dot N = \\dot x + \\dot y = \\frac{r_xx\\gamma_x}{\\gamma_x}\\left(1-\\frac{x}{K_x}\\right) + \\frac{r_yy\\gamma_y}{\\gamma_y}\\left(1-\\frac{y}{K_y}\\right)-pzN\n \n\\Leftrightarrow\n \n\\dot N = \\frac{r_xN\\gamma_x}{\\gamma_x+\\gamma_y}\\left(1-\\frac{x}{K_x}\\right) + \\frac{r_yN\\gamma_y}{\\gamma_x+\\gamma_y}\\left(1-\\frac{y}{K_y}\\right)-pzN\n \n\\Leftrightarrow\n \n\\dot N = \\left(\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right)N\\left(1-\\frac{\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}}{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}N\\right)-pzN\n\\tag{18}\nEn posant r_N = \\left(\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right) et K_N=\\frac{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}{\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}} le système devient :\n \\left\\{\\begin{array}{l}\n\\dot N = r_NN\\left(1-\\frac{N}{K_N}\\right)-pzN \\\\\n\\dot z = z\\left(nN - m\\right)\n\\end{array}\\right.\n\\tag{19}\nqui est bien un système de L-V avec croissance logistique.\nSi \\exists z^* &gt; 0 alors on a N^*=\\frac{m}{n}.\nDe plus, on a : pz^* = r_N\\left(1-\\frac{N^*}{K_N}\\right) et donc si z^*&gt;0 on a N^* &lt; K_N qui est équivalent à \\frac{m}{n} &lt; K_N.\nSi on considère le système précédent sans prédateurs on a :\n \\left\\{\\begin{array}{l}\n\\dot N_0 = r_NN_0\\left(1-\\frac{N_0}{K_N}\\right)\n\\end{array}\\right.\n\net on a donc N_0^* = K_N.\nOr, posons la condition mathématique intuitive : \nx^*_0(+\\infty)+y^*_0(+\\infty) &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \n\\frac{x^*_0(+\\infty)\\gamma_x}{\\gamma_x}+\\frac{y^*_0(+\\infty)\\gamma_y}{\\gamma_y} &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \n\\frac{N_0^*(+\\infty)\\gamma_x}{\\gamma_x+\\gamma_y}+\\frac{N^*_0(+\\infty)\\gamma_y}{\\gamma_x+\\gamma_y} &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \nK_N &gt; \\frac{m}{n}\n\nL’intuition biologique est donc confirmée par des preuves mathématiques.\nOn va donc tracer les graphes de la somme des équilibres du système (1) avec et sans prédateurs et constater cette saturation à lorsque la condition x_0^* + y_0^* &gt; \\frac{m}{n} est validée.\nPour plot on va simuler avec odeint pendant un temps assez large pour atteindre l’équilibre :\n\n\nCode\n#Définition d'une fonction qui prend en compte le changement de migration:\ndef a(etat,t,param,i):\n    x,y,z=etat\n    b=i\n    rx,Kx,ry,Ky,gx,gy,p,n,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-p*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-p*y*z,z*(n*(x+y)-m)]\n    return [xdot,ydot,zdot]\n\n#Définition du modèle sans prédateurs:\ndef aug(etat,t,param,i):\n    rx,Kx,ry,Ky,gx,gy=param\n    b=i\n    x,y=etat\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx),ry*y*(1-y/Ky)+b*(x/gx-y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\np1=1\nm11=1\nn11=0.25\nm12=3\nn12=2\n\nparam11=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,p1,n11,m11])\nparam12=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,p1,n12,m12])\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\np2=1\nm21=1\nn21=0.3278\nm22=1\nn22=0.335\n\nparam21=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,p2,n21,m21])\nparam22=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,p2,n22,m22])\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\np3=0.5\nm31=1\nn31=0.2832\nm32=1\nn32=0.289\n\nparam31=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,p3,n31,m31])\nparam32=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,p3,n32,m32])\n\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\np4=1\nm41=1\nn41=0.436\nm42=1\nn42=0.45\n\nparam41=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,p4,n41,m41])\nparam42=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,p4,n42,m42])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt=np.arange(0,800,0.01)\n\n#Condition initiale:\ne0=[1,1,1]\n\n#Figure:\nfig,ax=plt.subplots(2,4,figsize=(12,9))\nplt.subplots_adjust(wspace=0.4,hspace=0.3)\n\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0,4,0.01):\n    s11=odeint(a,e0,t,args=(param11,i)) #On calcule pour chaque beta l'équilibre\n    ax[0][0].plot(i,s11[-1][0]+s11[-1][1],marker='.',markersize=3,color='C0')\n    s12=odeint(a,e0,t,args=(param12,i))\n    ax[0][1].plot(i,s12[-1][0]+s12[-1][1],marker='.',markersize=3,color='C0')\n    \n    s11sp=odeint(aug,e0[0:2],t,args=(param11[0:6],i))\n    ax[0][0].plot(i,s11sp[-1][0]+s11sp[-1][1],marker='.',markersize=1,color='0.7')\n    s12sp=odeint(aug,e0[0:2],t,args=(param12[0:6],i))\n    ax[0][1].plot(i,s12sp[-1][0]+s12sp[-1][1],marker='.',markersize=1,color='0.7')\n    \n    \n    s21=odeint(a,e0,t,args=(param21,i))\n    ax[0][2].plot(i,s21[-1][0]+s21[-1][1],marker='.',markersize=3,color='C0')             \n    s22=odeint(a,e0,t,args=(param22,i))\n    ax[0][3].plot(i,s22[-1][0]+s22[-1][1],marker='.',markersize=3,color='C0')              \n    \n    s21sp=odeint(aug,e0[0:2],t,args=(param21[0:6],i))\n    ax[0][2].plot(i,s21sp[-1][0]+s21sp[-1][1],marker='.',markersize=1,color='0.7')\n    s22sp=odeint(aug,e0[0:2],t,args=(param22[0:6],i))\n    ax[0][3].plot(i,s22sp[-1][0]+s22sp[-1][1],marker='.',markersize=1,color='0.7')\n    \n    \n    s31=odeint(a,e0,t,args=(param31,i))\n    ax[1][0].plot(i,s31[-1][0]+s31[-1][1],marker='.',markersize=3,color='C0')\n    s32=odeint(a,e0,t,args=(param32,i))\n    ax[1][1].plot(i,s32[-1][0]+s32[-1][1],marker='.',markersize=3,color='C0')\n    \n    s31sp=odeint(aug,e0[0:2],t,args=(param31[0:6],i))\n    ax[1][0].plot(i,s31sp[-1][0]+s31sp[-1][1],marker='.',markersize=1,color='0.7')\n    s32sp=odeint(aug,e0[0:2],t,args=(param32[0:6],i))\n    ax[1][1].plot(i,s32sp[-1][0]+s32sp[-1][1],marker='.',markersize=1,color='0.7')\n    \nfor i in np.arange(0,10,0.01):\n    s41=odeint(a,e0,t,args=(param41,i))\n    ax[1][2].plot(i,s41[-1][0]+s41[-1][1],marker='.',markersize=3,color='C0')\n    s42=odeint(a,e0,t,args=(param42,i))\n    ax[1][3].plot(i,s42[-1][0]+s42[-1][1],marker='.',markersize=3,color='C0')\n    \n    s41sp=odeint(aug,e0[0:2],t,args=(param41[0:6],i))\n    ax[1][2].plot(i,s41sp[-1][0]+s41sp[-1][1],marker='.',markersize=1,color='0.7')\n    s42sp=odeint(aug,e0[0:2],t,args=(param42[0:6],i))\n    ax[1][3].plot(i,s42sp[-1][0]+s42sp[-1][1],marker='.',markersize=1,color='0.7')\n\n#Plot de la droite Kx+Ky:    \nxt=np.arange(0,4,0.01)\nxt2=np.arange(0,4,0.01)\nxt3=np.arange(0,10,0.01)\n\nax[0][0].plot(xt,(Kx1+Ky1)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt2,(Kx1+Ky1)*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[0][2].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][3].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt2,(Kx3+Ky3)*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt,(Kx3+Ky3)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][2].plot(xt3,(Kx4+Ky4)*np.ones_like(xt3),linestyle='dashed',color='k',markersize='6')\nax[1][3].plot(xt3,(Kx4+Ky4)*np.ones_like(xt3),linestyle='dashed',color='k',markersize='6')\n\n#Plot de m/n:\nax[0][0].plot(xt,m11/n11*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[0][1].plot(xt,m12/n12*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[0][2].plot(xt,m21/n21*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[0][3].plot(xt,m22/n22*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[1][0].plot(xt,m31/n31*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')\nax[1][1].plot(xt,m32/n32*np.ones_like(xt),linestyle='dashed',color='g',markersize='6')         \nax[1][2].plot(xt3,m41/n41*np.ones_like(xt3),linestyle='dashed',color='g',markersize='6')\nax[1][3].plot(xt3,m42/n42*np.ones_like(xt3),linestyle='dashed',color='g',markersize='6')  \n\n#Légendes:\nax[0][0].set_xlabel('β')\nax[0][1].set_xlabel('β')\nax[0][2].set_xlabel('β')\nax[0][3].set_xlabel('β')\nax[1][0].set_xlabel('β')\nax[1][1].set_xlabel('β')\nax[1][2].set_xlabel('β')\nax[1][3].set_xlabel('β')\n\nax[0][0].set_ylabel('Population')\nax[0][0].plot(0,0,color='0.8',label='Somme des équilibres sans prédateurs')\nax[0][0].plot(0,0,color='C0',label='Somme des équilibres avec prédateurs')\nax[0][0].plot(0,0,linestyle='dashed',color='g',markersize='6',label='m/n')\nax[0][0].plot(0,0,linestyle='dashed',color='k',markersize='6',label='Kx+Ky')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(6.55, -0.5, 0.5, 0.5),fontsize=10)\n\n#Titres:\nax[0][0].set_title('Déflation')\nax[0][1].set_title('Déflation')\nax[0][2].set_title('Les deux')\nax[0][3].set_title('Déflation')\nax[1][0].set_title('Inflation')\nax[1][1].set_title('Déflation')\nax[1][2].set_title('Inflation')\nax[1][3].set_title('Déflation')\n\n\nText(0.5, 1.0, 'Déflation')\n\n\n\n\n\nDans ces simulations on a posé les 4 situations possibles de courbes comme avec le modèle précédent avec, soit \\frac{m}{n} plus grand que la somme des capacités soit \\frac{m}{n} plus petits que la somme des capacités. On se retrouve donc avec 8 profils différents. On aurait pu inclure les profils où \\frac{m}{n} est complètement au dessus ou en dessous mais ils n’avaient pas grand intérêt.\nLorsque les prédateurs sont présents, ie que x^*_0(\\beta)+y^*_0(\\beta)&gt;\\frac{m}{n}, c’est à dire quand la courbe grise est au dessus de la droite verte on a bien que x^*(\\beta)+y^*(\\beta)=\\frac{m}{n}. Quand ils sont absents (la courbe grise est en dessous de la droite verte) on observe bien que x^*(\\beta)=x_0^*(\\beta), y^*(\\beta)=y^*_0(\\beta) (les courbes bleu et grise sont confondues).\nOn observe que lorsqu’on a \\frac{m}{n} &lt; K_x + K_y on a toujours un système déflationiste, en effet on a alors que soit le système sans prédateurs avait une somme au dessus de \\frac{m}{n} et on ainsi que l’équilibre vaut \\frac{m}{n} (qui est par l’observation sous K_x + K_y et donc déflation) soit le système était en dessous de \\frac{m}{n} et donc on a la somme correspondant à l’équilibre sans prédateurs mais qui est en dessous de K_x + K_y par observation.\nCes graphiques traduisent bien l’effet de l’ajout des prédateurs dans un système : si celui ci est déja déflationiste il le reste, si celui ci était inflationiste et déflationiste ou complètement inflationiste il peut devenir déflationiste.\nAutrement dit si on reprend les conditions sur les inflations et déflations posées précédemment on a :\nSi le système sans prédateurs est de base déflationiste alors le système avec prédateurs est aussi déflationiste (avec survie ou pas des prédateurs).\nAinsi d’après les conditions du modèle précédent on a que si \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} alors le système avec prédateurs est toujours déflationiste.\nDe plus, si \\frac{\\gamma_y}{\\gamma_x}&lt;\\frac{K_y}{K_x} alors on a soit un système inflationiste si \\frac{m}{n} &lt; K_x+K_y soit un système inflationiste et déflationiste mais moins inflationiste quand sans les prédateurs si \\frac{m}{n} &lt; (x^*+y^*)_{max}.\nEnfin si \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} alors si on a x^*(\\infty)+y^*(\\infty) &gt; \\frac{m}{n} &gt; K_x+K_y alors le système est inflationiste mais moins que son pendant sans prédateurs.\n\n\nEquilibre de la culture en fonction de \\gamma_x et \\gamma_y\nOn va maintenant voir l’évolution de l’équilibre dans la culture en fonction de \\gamma_x (le taux de migration) et de \\gamma_y (le taux de fuite):\n\n\nCode\n#On définit un modèle qui prend en compte le changement de b et un autre qui prend en compte le changement de gy\ndef a1(etat,t,param,h):\n    x,y,z=etat\n    rx,Kx,ry,Ky,b,gy,p,n,m = param\n    gx=h\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-p*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-p*y*z,z*(n*(x+y)-m)]\n    return xdot,ydot,zdot\n\ndef a2(etat,t,param,h):\n    x,y,z=etat\n    rx,Kx,ry,Ky,gx,b,p,n,m = param\n    gy=h\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-p*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-p*y*z,z*(n*(x+y)-m)]\n    return xdot,ydot,zdot\n\n#Paramètres Simulation b1: \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\nb1=1\ngy1=4\np1=1\nn1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,b1,gy1,p1,n1,m1])\n\n#Paramètres Simulation b2: \nrx2=0.5\nry2=1\nKx2=1\nKy2=2\nb2=1\ngy2=4\np2=1\nn2=1\nm2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,b2,gy2,p2,n2,m2])\n\n#Paramètres Simulation gy1: \nrx3=0.5\nry3=1\nKx3=2\nKy3=1\ngx3=0.5\nb3=1\np3=1\nn3=1\nm3=0.5\n\nparam_a3=np.array([rx3,Kx3,ry3,Ky3,gx3,b3,p3,n3,m3])\n\n#Paramètres Simulation gy2: \nrx4=0.5\nry4=1\nKx4=1\nKy4=2\ngx4=0.5\nb4=1\np4=1\nn4=1\nm4=0.5\n\nparam_a4=np.array([rx4,Kx4,ry4,Ky4,gx4,b4,p4,n4,m4])\n\n#Temps d'intégration:\nt1=np.arange(0,300,0.01)\n\n#Conditions initiales:\nx0=1\ny0=1\nz0=1\nc0=np.array([x0,y0,z0])\n\n#On trace la figure:\nfig1,ax=plt.subplots(2,2,figsize=(10,5))\n\n#Boucle qui met à jour b et simule à chaque fois l'équilibre :\nfor i in np.arange(0.01,3,0.01):\n    sa1=odeint(a1,c0,t1,args=(param_a1,i))\n    ax[0][0].plot(i,sa1[-1][0],marker='.',color='C0')\n    sa2=odeint(a1,c0,t1,args=(param_a2,i))\n    ax[0][1].plot(i,sa2[-1][0],marker='.',color='C0')\n\n#Boucle qui met à jour gy et simule l'équilibre:\nfor i in np.arange(0.01,5,0.01):\n    sa3=odeint(a2,c0,t1,args=(param_a3,i))\n    ax[1][0].plot(i,sa3[-1][0],marker='.',color='C0')\n    sa4=odeint(a2,c0,t1,args=(param_a4,i))\n    ax[1][1].plot(i,sa4[-1][0],marker='.',color='C0')\n\n#On plot la ligne correspondant à Kx\nxt=np.arange(0.01,3,0.01)\nxt2=np.arange(0.01,5,0.01)\nax[0][0].plot(xt,Kx1*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt,Kx2*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt2,Kx3*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt2,Kx4*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\n\n##Légendes et titres:\nfig1.suptitle(\"Simulation de l\\'équilibre dans la culture en fonction du taux de migration et du taux de fuite\")\n\n#Abssices:\nax[0][0].set_xlabel(\"Taux de migration, Ɣx\")\nax[0][1].set_xlabel(\"Taux de migration, Ɣx\")\nax[1][0].set_xlabel(\"Taux de fuite, Ɣy\")\nax[1][1].set_xlabel(\"Taux de fuite, Ɣy\")\n\n#Titre des sous figures:\nax[0][0].set_title(\"$K_x&gt;K_y$\")\nax[0][1].set_title(\"$K_x&lt;K_y$\")\nax[1][0].set_title(\"$K_x&gt;K_y$\")\nax[1][1].set_title(\"$K_x&lt;K_y$\")\n\n#Ordonnées:\nax[0][0].set_ylabel(\"Densité de pop.\")\nax[1][0].set_ylabel(\"Densité de pop.\")\n\n#Légende générale:\nax[0][0].plot(0,0,color='C0',label='Equilibre dans la culture')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(0.9, -0.69, 0.5, 0.5))\n\n#Ecartement des figures:\nplt.subplots_adjust(hspace=0.5)\n\n#Texte Kx:\nax[0][0].text(2.75,Kx1-0.2,'$K_x$')\nax[0][1].text(2.75,Kx2-0.1,'$K_x$')\nax[1][0].text(4.75,Kx3-0.2,'$K_x$')\nax[1][1].text(4.75,Kx4-0.1,'$K_x$')\n\n\nText(4.75, 0.9, '$K_x$')\n\n\n\n\n\nEn haut on observe l’équilibre en fonction du taux de migration. On voit que quelque soit la culture on a un équilibre qui est bien en dessous de la capactié biotique de la culture. La technique de l’augmentorium semble être efficace.\nOn observe que quand le taux de migration est fort (\\gamma_x petit) alors on a un équilibre dans la culture faible et celui augmente au fur et à mesure que le taux de migration ralentit. Mettre de l’effort dans la tache de ramasser les fruits et les séquestrer n’est donc pas vain.\nMaintenant quand on regarde le taux de fuite, s’il est élevé (valeur petite de \\gamma_y) alors on a un équilibre dans la culture plus grand que si il est faible. Plus \\gamma_y est grand (et donc plus le taux de fuite est faible) moins l’équilibre dans la culture est élevé.\nCe paramètre est donc crucial et c’est quelque chose qu’il faut continuer d’améliorer (en mettant en place des sas, de la lumière à l’opposé de l’entrée pour attirer les ravageurs etc.).\n\n\n\nPrédation et naissances différentielles\nMaintenant on va considérer le modèle plus complexe de naissances (n) et de la prédation (p) différentes entre la culture et l’augentorium.\nCe postulat n’est pas annodin car on peut vraisemblablement penser que l’augmentorium fournit une structure positive à la croissance grâce à la grande concentration de ressources qu’il renferme et à son relatif cloisonnement de l’extérieur.\n\nSomme des équilibres des proies en fonction de \\beta\nPrécédemment on observait une saturation de la somme des proies à \\frac{m}{n}. Mais cette observation résultait de la trop forte simplification du modèle considéré. En considérant notre modèle actuel et en faisant l’hypothèse que z^* \\ne 0 alors on a la condition n_xx^*+n_yy^* = m.\nL’intuition mathématique, via le même raisonnement biologique précédent, est que l’invasion des prédateurs ie \\exists z^* &gt; 0 est vérifiée si seulement si n_xx_0^*(\\beta) + n_yy_0^*(\\beta)&gt;m où x_0^*(\\beta) et y_0^*(\\beta) sont les équilibres du système sans prédateurs.\nMontrons le mathématiquement pour \\beta = 0 et \\beta = +\\infty :\nPour \\beta =0, on a le système suivant :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{20}\nqui a l’équilibre implique que : \n\\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right)\n qui donne, via la condition z &gt; 0, après réarrangement: \nx^* = \\frac{K_x\\left(r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\\right)}{r_xp_yn_yK_y+r_yp_xn_xK_x}\n\\tag{21}\nPar l’expression de z^* on a K_x &gt; x^* autrement dit : \nK_x &gt; \\frac{K_x\\left(r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\\right)}{r_xp_yn_yK_y+r_yp_xn_xK_x}\n \n\\Leftrightarrow\n \nr_xp_yn_yK_y+r_yp_xn_xK_x &gt; r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\n \n\\Leftrightarrow\n \nr_yp_x(n_xK_x+n_yK_y) &gt; r_yp_xm \\Leftrightarrow n_xK_x + n_yK_y &gt; m\n\nOr x_0^*(0) = K_x et y_0^*(0) car ce ne sont que des croissances logistiques.\nAinsi la condition n_xx_0^*(0) + n_yy_0^*(0)&gt;m équivaut à n_xK_x + n_yK_y &gt; m\nLa condition d’un équilibre positif implique bien cette condition d’invasion.\nPour \\beta =+\\infty, on va simplifier le système (1).\nOn pose N = x+y et en faisant tendre \\beta \\to +\\infty et en considérant \\dot x - \\dot y on a forcément \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\nCette condition permet de dire que \\frac{N}{\\gamma_x+\\gamma_y} = \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\n\n\\dot N = \\frac{r_xx\\gamma_x}{\\gamma_x}\\left(1-\\frac{x\\gamma_x}{K_x\\gamma_x}\\right) + \\frac{r_yy\\gamma_y}{\\gamma_y}\\left(1-\\frac{y\\gamma_y}{K_y\\gamma_y}\\right) - z\\left(\\frac{p_xx\\gamma_x}{\\gamma_x}+\\frac{p_yy\\gamma_y}{\\gamma_y}\\right)\n\nEn réarrangeant l’expression de droite en prenant en compte la condition précédente on a: \n\\dot N = \\underbrace{\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}}_{r_N} N \\left(1 - N \\underbrace{\\frac{\\left(\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}\\right)}{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}}_{\\frac{1}{K_N}} \\right) - zN\\underbrace{\\left(\\frac{p_x\\gamma_x+p_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right)}_{p_N}\n\nPour \\dot z on a : \n\\dot z = z\\left(\\frac{n_xx\\gamma_x}{\\gamma_x}+\\frac{n_yy\\gamma_y}{\\gamma_y}-m\\right)\n \n\\Leftrightarrow\n \n\\dot z = z\\left( N \\underbrace{\\frac{n_x\\gamma_x+n_y\\gamma_y}{\\gamma_x+\\gamma_y}}_{n_N} - m\\right)\n\nLe système (1) devient donc pour \\beta \\to +\\infty :\n \\left\\{\\begin{array}{l}\n\\dot N = r_N N \\left(1-\\frac{N}{K_N}\\right) - p_NzN \\\\\n\\dot z = z\\left(n_N N - m\\right)\n\\end{array}\\right.\n\\tag{22}\nqui est exactement un système proie-prédateur de Lotka-Volterra.\nSi \\exists z^* &gt; 0 on a à la fois N^*=\\frac{m}{n_N} et aussi N^* &lt; K_N et donc on a la condition suivante, s’il existe un équilibre non nul, K_N n_N &gt; m.\nOr, en prenant n_xx_0^*(+\\infty) + n_yy_0^*(+\\infty) &gt; m on a : \n\\frac{n_xx_0^*(+\\infty)\\gamma_x}{\\gamma_x} + \\frac{n_yy_0^*(+\\infty)\\gamma_y}{\\gamma_y} &gt; m\n \n\\Leftrightarrow\n \n\\frac{N^*_0}{\\gamma_x+\\gamma_y}(n_x\\gamma_x+n_y\\gamma_y) &gt; m\n\navec N^*_0 qui est l’équilibre du système de L-V pour z=0. Cet équilibre est trivialement égal à K_N et donc on a: \nK_N n_N &gt; m\n\nNos intuitions biologiques étant validées mathématiquement pour \\beta = 0 et \\beta = +\\infty on peut logiquement se dire que c’est aussi le cas pour un \\beta \\in ]0,+\\infty].\nOn va simuler numériquement la somme des équilibres des proies du système (1) par la même méthode que précédemment en faisant aussi aparaître la courbe n_xx^*_0+n_yy^*_0 et m ainsi que la somme des équilibres des proies du système (1) sans prédateurs pour pouvoir voir quand on a disparition des prédateurs et donc x^*_0 + y^*_0 = x^*+y^*.\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat,t,param,i):\n    x,y,z=etat\n    b=i\n    rx,Kx,ry,Ky,gx,gy,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Définition du modèle sans prédateurs:\ndef aug2(etat,t,param,i):\n    rx,Kx,ry,Ky,gx,gy=param\n    b=i\n    x,y=etat\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx),ry*y*(1-y/Ky)+b*(x/gx-y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm11=1\nm12=1.5\n\nparam11p=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,px1,py1,nx1,ny1,m11])\nparam11sp=param11p[0:6]\nparam12p=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,px1,py1,nx1,ny1,m12])\nparam12sp=param12p[0:6]\n\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\npx2=0.5\npy2=3\nnx2=0.5\nny2=1\nm21=1\nm22=1.9\n\nparam21p=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,px2,py2,nx2,ny2,m21])\nparam21sp=param21p[0:6]\nparam22p=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,px2,py2,nx2,ny2,m22])\nparam22sp=param22p[0:6]\n\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\npx3=1\npy3=0.5\nnx3=0.5\nny3=1\nm31=1.5\nm32=2.45\n\nparam31p=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,px3,py3,nx3,ny3,m31])\nparam31sp=param31p[0:6]\nparam32p=np.array([rx3,Kx3,ry3,Ky3,gx3,gy3,px3,py3,nx3,ny3,m32])\nparam32sp=param32p[0:6]\n\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\npx4=3\npy4=0.5\nnx4=0.5\nny4=1\nm41=1.4\nm42=1.82\n\nparam41p=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,px4,py4,nx4,ny4,m41])\nparam41sp=param41p[0:6]\nparam42p=np.array([rx4,Kx4,ry4,Ky4,gx4,gy4,px4,py4,nx4,ny4,m42])\nparam42sp=param42p[0:6]\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt=np.arange(0,600,0.01)\n\n#Condition initiale:\ne0p=[1,1,1]\ne0sp=[1,1]\n\n#Figure:\nfig,ax=plt.subplots(2,4,figsize=(20,10))\nplt.subplots_adjust(hspace=0.4)\n\nxt=np.arange(0,4,0.01)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0,4,0.01):\n    s1p=odeint(a,e0p,t,args=(param11p,i)) #On calcule pour chaque beta l'équilibre\n    s1sp=odeint(aug2,e0sp,t,args=(param11sp,i))\n    ax[0][0].plot(i,s1p[-1][0]+s1p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][0].plot(i,nx1*s1sp[-1][0]+ny1*s1sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][0].plot(xt,m11*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][0].plot(i,s1sp[-1][0]+s1sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s1p=odeint(a,e0p,t,args=(param12p,i)) #On calcule pour chaque beta l'équilibre\n    s1sp=odeint(aug2,e0sp,t,args=(param12sp,i))\n    \n    ax[0][1].plot(i,s1p[-1][0]+s1p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][1].plot(i,nx1*s1sp[-1][0]+ny1*s1sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][1].plot(xt,m12*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][1].plot(i,s1sp[-1][0]+s1sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    \n    s2p=odeint(a,e0p,t,args=(param21p,i)) #On calcule pour chaque beta l'équilibre\n    s2sp=odeint(aug2,e0sp,t,args=(param21sp,i))\n    \n    ax[0][2].plot(i,s2p[-1][0]+s2p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][2].plot(i,nx2*s2sp[-1][0]+ny2*s2sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][2].plot(xt,m21*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][2].plot(i,s2sp[-1][0]+s2sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s2p=odeint(a,e0p,t,args=(param22p,i)) #On calcule pour chaque beta l'équilibre\n    s2sp=odeint(aug2,e0sp,t,args=(param22sp,i))\n    \n    ax[0][3].plot(i,s2p[-1][0]+s2p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[0][3].plot(i,nx2*s2sp[-1][0]+ny2*s2sp[-1][1],marker='.',markersize=1,color='r')\n    ax[0][3].plot(xt,m22*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[0][3].plot(i,s2sp[-1][0]+s2sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    \n    s3p=odeint(a,e0p,t,args=(param31p,i)) #On calcule pour chaque beta l'équilibre\n    s3sp=odeint(aug2,e0sp,t,args=(param31sp,i))\n    \n    ax[1][0].plot(i,s3p[-1][0]+s3p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][0].plot(i,nx3*s3sp[-1][0]+ny3*s3sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][0].plot(xt,m31*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][0].plot(i,s3sp[-1][0]+s3sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s3p=odeint(a,e0p,t,args=(param32p,i)) #On calcule pour chaque beta l'équilibre\n    s3sp=odeint(aug2,e0sp,t,args=(param32sp,i))\n    \n    ax[1][1].plot(i,s3p[-1][0]+s3p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][1].plot(i,nx3*s3sp[-1][0]+ny3*s3sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][1].plot(xt,m32*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][1].plot(i,s3sp[-1][0]+s3sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    \n    s4p=odeint(a,e0p,t,args=(param41p,i)) #On calcule pour chaque beta l'équilibre\n    s4sp=odeint(aug2,e0sp,t,args=(param41sp,i))\n   \n    ax[1][2].plot(i,s4p[-1][0]+s4p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][2].plot(i,nx4*s4sp[-1][0]+ny4*s4sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][2].plot(xt,m41*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][2].plot(i,s4sp[-1][0]+s4sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n    s4p=odeint(a,e0p,t,args=(param42p,i)) #On calcule pour chaque beta l'équilibre\n    s4sp=odeint(aug2,e0sp,t,args=(param42sp,i))\n    \n    ax[1][3].plot(i,s4p[-1][0]+s4p[-1][1],marker='.',markersize=2,color='C0') #On plot un point qui correspond à la valeur de la somme des éq. en fonction de beta\n    ax[1][3].plot(i,nx4*s4sp[-1][0]+ny4*s4sp[-1][1],marker='.',markersize=1,color='r')\n    ax[1][3].plot(xt,m42*np.ones_like(xt),linestyle=\"dashed\",color='g')\n    ax[1][3].plot(i,s4sp[-1][0]+s4sp[-1][1],marker='.',markersize=1,color='0.8')\n    \n#Plot de la droite Kx+Ky:    \nax[0][0].plot(xt,(Kx1+Ky1)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt,(Kx1+Ky1)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][2].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][3].plot(xt,(Kx2+Ky2)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt,(Kx3+Ky3)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt,(Kx3+Ky3)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][2].plot(xt,(Kx4+Ky4)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][3].plot(xt,(Kx4+Ky4)*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\n\n#Légendes:\nax[0][0].set_xlabel('β')\nax[0][1].set_xlabel('β')\nax[0][2].set_xlabel('β')\nax[0][3].set_xlabel('β')\nax[1][0].set_xlabel('β')\nax[1][1].set_xlabel('β')\nax[1][2].set_xlabel('β')\nax[1][3].set_xlabel('β')\n\nax[0][0].set_ylabel('Population')\nax[0][0].plot(0,0,color='0.8',label='Somme des équilibres sans prédateurs')\nax[0][0].plot(0,0,color='C0',label='Somme des équilibres avec prédateurs')\nax[0][0].plot(0,0,linestyle='dashed',color='r',markersize='6',label='nx*x+ny*y')\nax[0][0].plot(0,0,linestyle='dashed',color='g',markersize='6',label='m')\nax[0][0].plot(0,0,linestyle='dashed',color='k',markersize='6',label='Kx+Ky')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(5.2, -0.5, 0.5, 0.5),fontsize=10)\n\n#Titres:\nax[0][0].set_title('Déflation')\nax[0][1].set_title('Déflation')\nax[0][2].set_title('Déflation')\nax[0][3].set_title('Les deux')\nax[1][0].set_title('Déflation')\nax[1][1].set_title('Les deux')\nax[1][2].set_title('Déflation')\nax[1][3].set_title('Les deux')\n\n\nText(0.5, 1.0, 'Les deux')\n\n\n\n\n\nOn observe que si m est toujours plus grand que n_xx_0^*+n_yy_0^* alors les prédateurs disparaissent et on a que la somme des équilibres est égale à x_0^*+y_0^* (la courbe bleu est tout le temps confondue avec la courbe grise).\nEnsuite, quand m est toujours plus petit que n_xx_0^*+n_yy_0^* alors les prédateurs sont toujours en vie et on a que la somme des équilibres est égale à x^*+y^*.\nEnfin, quand m croise n_xx_0^*+n_yy_0^* on observe que la somme des équilibres est à la fois x^*+y^* et x_0^*+y_0^*. Si n_xx_0^*+n_yy_0^* est croissant alors on a d’abord que la somme des équilibres est égale à x_0^*+y_0^* puis x^*+y^* et inversement si n_xx_0^*+n_yy_0^* est décroissante.\n\n\nEquilibre de la culture en fonction de \\gamma_x et \\gamma_y\nOn va maintenant tracer l’équilibre dans la culture en fonction du taux de migration et de fuite.\n\n\nCode\n#On définit un modèle qui prend en compte le changement de b et un autre qui prend en compte le changement de gy\ndef a1(etat,t,param,i):\n    x,y,z=etat\n    gx=i\n    rx,Kx,ry,Ky,b,gy,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\ndef a2(etat,t,param,i):\n    x,y,z=etat\n    gy=i\n    rx,Kx,ry,Ky,gx,b,px,py,nx,ny,m = param\n    xdot,ydot,zdot=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z*x,ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z,z*(nx*x+ny*y-m)]\n    return [xdot,ydot,zdot]\n\n#Paramètres Simulation b1: \nrx1=0.5\nry1=1\nKx1=2\nKy1=1\nb1=1\ngy1=4\npx1=0.5\npy1=1\nnx1=0.5\nny1=1\nm1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,b1,gy1,px1,py1,nx1,ny1,m1])\n\n#Paramètres Simulation b2: \nrx2=0.5\nry2=1\nKx2=1\nKy2=2\nb2=1\ngy2=4\npx2=0.5\npy2=1\nnx2=0.5\nny2=1\nm2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,b2,gy2,px2,py2,nx2,ny2,m2])\n\n#Paramètres Simulation gy1: \nrx3=0.5\nry3=1\nKx3=2\nKy3=1\ngx3=0.5\nb3=1\npx3=0.5\npy3=1\nnx3=0.5\nny3=1\nm3=0.5\n\nparam_a3=np.array([rx3,Kx3,ry3,Ky3,gx3,b3,px3,py3,nx3,ny3,m3])\n\n#Paramètres Simulation gy2: \nrx4=0.5\nry4=1\nKx4=1\nKy4=2\ngx4=0.5\nb4=1\npx4=0.5\npy4=1\nnx4=0.5\nny4=1\nm4=0.5\n\nparam_a4=np.array([rx4,Kx4,ry4,Ky4,gx4,b4,px4,py4,nx4,ny4,m4])\n\n#Temps d'intégration:\nt1=np.arange(0,300,0.01)\n\n#Conditions initiales:\nx0=1\ny0=1\nz0=1\nc0=np.array([x0,y0,z0])\n\n#On trace la figure:\nfig1,ax=plt.subplots(2,2,figsize=(10,5))\n\n#Boucle qui met à jour b et simule à chaque fois l'équilibre :\nfor i in np.arange(0.01,3,0.01):\n    sa1=odeint(a1,c0,t1,args=(param_a1,i))\n    ax[0][0].plot(i,sa1[-1][0],marker='.',color='C0')\n    sa2=odeint(a1,c0,t1,args=(param_a2,i))\n    ax[0][1].plot(i,sa2[-1][0],marker='.',color='C0')\n\n#Boucle qui met à jour gy et simule l'équilibre:\nfor i in np.arange(0.01,5,0.01):\n    sa3=odeint(a2,c0,t1,args=(param_a3,i))\n    ax[1][0].plot(i,sa3[-1][0],marker='.',color='C0')\n    sa4=odeint(a2,c0,t1,args=(param_a4,i))\n    ax[1][1].plot(i,sa4[-1][0],marker='.',color='C0')\n\n#On plot la ligne correspondant à Kx\nxt=np.arange(0.01,3,0.01)\nxt2=np.arange(0.01,5,0.01)\nax[0][0].plot(xt,Kx1*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[0][1].plot(xt,Kx2*np.ones_like(xt),linestyle='dashed',color='k',markersize='6')\nax[1][0].plot(xt2,Kx3*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\nax[1][1].plot(xt2,Kx4*np.ones_like(xt2),linestyle='dashed',color='k',markersize='6')\n\n##Légendes et titres:\nfig1.suptitle(\"Simulation de l\\'équilibre dans la culture en fonction du taux de migration et du taux de fuite\")\n\n#Abssices:\nax[0][0].set_xlabel(\"Taux de migration, Ɣx\")\nax[0][1].set_xlabel(\"Taux de migration, Ɣx\")\nax[1][0].set_xlabel(\"Taux de fuite, Ɣy\")\nax[1][1].set_xlabel(\"Taux de fuite, Ɣy\")\n\n#Titre des sous figures:\nax[0][0].set_title(\"$K_x&gt;K_y$\")\nax[0][1].set_title(\"$K_x&lt;K_y$\")\nax[1][0].set_title(\"$K_x&gt;K_y$\")\nax[1][1].set_title(\"$K_x&lt;K_y$\")\n\n#Ordonnées:\nax[0][0].set_ylabel(\"Densité de pop.\")\nax[1][0].set_ylabel(\"Densité de pop.\")\n\n#Légende générale:\nax[0][0].plot(0,0,color='C0',label='Equilibre dans la culture')\n\n#On déplace la légende hors de la figure:\nax[0][0].legend(bbox_to_anchor=(0.9, -0.69, 0.5, 0.5))\n\n#Ecartement des figures:\nplt.subplots_adjust(hspace=0.5)\n\n#Texte Kx:\nax[0][0].text(2.75,Kx1-0.2,'$K_x$')\nax[0][1].text(2.75,Kx2-0.1,'$K_x$')\nax[1][0].text(4.75,Kx3-0.2,'$K_x$')\nax[1][1].text(4.75,Kx4-0.1,'$K_x$')\n\n\nText(4.75, 0.9, '$K_x$')\n\n\n\n\n\nOn observe des résultats similaires au système simplifié. L’analyse qui en résulte est la même.\nD’après les graphiques, l’effet de l’augmentorium sur l’équilibre dans la culture a l’air largement diminué dans tous les types de culture."
  },
  {
    "objectID": "modelaug.html#conclusion",
    "href": "modelaug.html#conclusion",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Conclusion",
    "text": "Conclusion\nCe modèle nous permet d’entrevoir mathématiquement pourquoi l’augmentorium est une technique efficace dans les cultures."
  },
  {
    "objectID": "modfinal.html#définition-du-modèle",
    "href": "modfinal.html#définition-du-modèle",
    "title": "Modèle proies-prédateurs structuré",
    "section": "Définition du modèle",
    "text": "Définition du modèle\nDans ce modèle on va considérer 4 populations correspondant aux proies et aux prédateurs dans l’augmentorium et dans la culture.\nVoici le modèle:\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_1xz_1 \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_2yz_2 \\\\\n\\dot z_1 = z_1\\left(n_1x - m_1 \\right) + \\delta\\left(\\frac{z_2}{\\mu _2}-\\frac{z_1}{\\mu _1}\\right) \\\\\n\\dot z_2 = z_2\\left(n_2y - m_2 \\right) + \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\\end{array}\\right.\n\\tag{1}"
  },
  {
    "objectID": "modelesansmigrationass.html#inflation-et-déflation-du-système",
    "href": "modelesansmigrationass.html#inflation-et-déflation-du-système",
    "title": "Modèle logistique structuré avec migration symétrique",
    "section": "Inflation et déflation du système :",
    "text": "Inflation et déflation du système :\n \nPassons mainenant à un modèle qui prend en compte que les migrations peuvent êtres assymétriques."
  },
  {
    "objectID": "modelesansmigrationass.html#inflation-et-déflation-du-système-en-fonction-de-la-migration",
    "href": "modelesansmigrationass.html#inflation-et-déflation-du-système-en-fonction-de-la-migration",
    "title": "Modèle logistique structuré sans migration asymétrique",
    "section": "Inflation et déflation du système en fonction de la migration",
    "text": "Inflation et déflation du système en fonction de la migration\nDans cette partie nous allons s’intéresser aux sommes des équilibres en fonction de \\beta.\nNous avons déja plus ou moins tracé les différents profils de courbe que nous pouvons obtenir pour cette partie (quand nous avons vérifié les propositions de conditions d’inflation/déflation) mais il existe un quatrième profil de courbe.\nNous allons utiliser les mêmes méthodes que précédemment :\n\n#Nous redéfinissons la même fonction:\ndef aug2(etat, t, param, h):\n    rx, ry, Kx, Ky = param\n    b = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y - x), \n    ry * y * (1 - y/Ky) + b * (x - y)]\n    return s \n\n## Temps d'intégration :\n\nt1 = np.arange(0, 400, 0.01)\n\n## Paramètres : \n#Paramètres de la condition b):\nrx1 = 0.5\nry1 = 1  \nKx1 = 2\nKy1 = 1  \n\nparam1 = np.array([rx1, ry1, Kx1, Ky1])\n\n## Paramètres condition c.1): \nrx2 = 0.4\nry2 = 1  \nKx2 = 1\nKy2 = 2  \n\nparam2 = np.array([rx2, ry2, Kx2, Ky2])\n\n## Paramètres condition c.2): \nrx3 = 0.6\nry3 = 1  \nKx3 = 1  \nKy3 = 2  \n\nparam3 = np.array([rx3, ry3, Kx3, Ky3])\n\n## Paramètres nouveau profil: \nrx4 = 0.5\nry4 = 2  \nKx4 = 0.5  \nKy4 = 1  \n\nparam4 = np.array([rx4, ry4, Kx4, Ky4])\n\n## Condition initiale:\n\nc10 = [2, 0]\n\n## Nous créons la figure et l'axe:\n\nfig6, (ax7, ax8, ax9, ax10) = plt.subplots(1, 4, figsize = (9, 5))\nax7.set_title(\"Déflation\", fontsize = 8)\nax8.set_title(\"Inflation\", fontsize = 8)\nax9.set_title(\"Les deux\", fontsize = 8)\nax10.set_title(\"Inflation\", fontsize = 8)\n\nplt.subplots_adjust(wspace = 0.45) #Nous ajustons l'écart entre figures\n\n## Boucle ou i prend les valeurs de beta:\n\nfor i in np.arange(0, 4, 0.01):\n    s1 = odeint(aug2, c10, t1, args = (param1, i)) \n    ax7.plot(i, s1[-1][0] + s1[-1][1], marker = '.', color = 'C0')\n\n    s2 = odeint(aug2, c10, t1, args = (param2, i))\n    ax8.plot(i, s2[-1][0] + s2[-1][1], marker = '.', color = 'C0')\n\n    s3 = odeint(aug2, c10, t1, args = (param3, i))\n    ax9.plot(i, s3[-1][0] + s3[-1][1], marker = '.', color = 'C0')\n\n    s4 = odeint(aug2, c10, t1, args = (param4, i))\n    ax10.plot(i, s4[-1][0] + s4[-1][1], marker = '.', color = 'C0')\n\n## Plot de la droite Kx+Ky:\n\nxt = np.arange(0, 4, 0.01)\n\nax7.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k',markersize = '6')\nax7.text(2.5, Kx1 + Ky1 + 0.01, '$K_x+K_y$')\n\nax8.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax8.text(2.5, Kx2 + Ky2 + 0.01, '$K_x+K_y$')\n\nax9.plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax9.text(2.5, Kx3 + Ky3 + 0.01, '$K_x+K_y$')\n\nax10.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax10.text(2.5, Kx4 + Ky4 + 0.01, '$K_x+K_y$')\n\n\n## Légendes:\nax7.set_xlabel('β')\nax7.set_ylabel('Population')\nax7.plot(Kx1 + Ky1, 0, color = 'C0', label = 'Somme des équilibres') #Si nous avions mis label dans la boucle la légende aurait été trop grande\n\nax8.set_xlabel('β')\n\nax9.set_xlabel('β')\n\nax10.set_xlabel('β')\n\n\n## Nous adaptons la fenêtre:\nax7.set_ylim(2.4, 3.1)\nax8.set_ylim(2.95, 3.15)\nax9.set_ylim(2.9, 3.1)\nax10.set_ylim(1.25, 1.75)\n\n#Nous déplaçons la légende hors de la figure:\nax7.legend(bbox_to_anchor = (1.75, -0.65, 0.5, 0.5));\n\n\n\n\nFigure 11: 4 profils de somme d’équilibre\n\n\n\n\nNous observons quatre profils différents. Les trois premiers ont déjà été obtenus précédemment.\nLe quatrième correspond à un système inflationniste où le maximum d’inflation est atteint pour \\beta \\to +\\infty contrairement à l’autre profil d’inflation.\nNous pouvons donc observer quatres profils mais en réalité il n’existe que trois possibilités : Déflation, inflation puis déflation et enfin inflation. Les deux profils d’inflations correspondent au même cas mais avec le point B qui croise l’ellipse à des endroits différents (cette remarque sera détaillée plus tard dans le rapport).\nCe modèle nous a permis de poser les bases de la modélisation que nous allons utiliser.\nNous allons maintenant passer à un modèle qui prend en compte que les migrations peuvent être assymétriques et donc nous allons nous rapprocher du cas de l’augmentorium."
  },
  {
    "objectID": "modfinal.html#réduction-du-modèle",
    "href": "modfinal.html#réduction-du-modèle",
    "title": "Modèle proies-prédateurs structuré",
    "section": "Réduction du modèle",
    "text": "Réduction du modèle\nL’augmentorium permet aux prédateurs de circuler presque librement entre les l’intérieur et l’extérieur. On va donc considérer que \\delta \\to +\\infty et voir si on peut se rapporter à un modèle plus simple.\nOn considère \\dot z_1 - \\dot z_2:\n\n\\dot z_1 - \\dot z_2 = z_1(n_1x-m_1)-z_2(n_2y-m_2) - \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\nLorsque \\delta = +\\infty on a \\dot z_1 - \\dot z_2 qui devient: \n\\dot z_1 - \\dot z_2 = - \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\net donc on a \\dot z_1 - \\dot z_2 \\to 0 \\Leftrightarrow \\frac{z_1}{\\mu _1} = \\frac{z_2}{\\mu _2}.\nSi on pose z=z_1+z_2 alors par la proposition précédente on a : \n\\frac{z}{\\mu _1+\\mu _2} = \\frac{\\frac{z_1\\mu _1}{\\mu _1}+\\frac{z_2\\mu _2}{\\mu _2}}{\\mu _1 +\\mu _2}=\\frac{z_1}{\\mu _1} = \\frac{z_2}{\\mu _2}\n\net donc : \n\\dot z = \\dot z_1 + \\dot z_2 = \\frac{z_1\\mu _1}{\\mu _1}\\left(n_1x - m_1 \\right) + \\frac{z_2\\mu _2}{\\mu _2}\\left(n_2y - m_2 \\right)\n \n\\Leftrightarrow\n \n\\dot z = \\frac{z}{\\mu _1 +\\mu _2}\\left(\\mu _1(n_1x-m_1)+\\mu _2(n_y-m_2)\\right)\n \n\\Leftrightarrow\n \n\\dot z = z \\left(\\underbrace{\\frac{\\mu _1n_1}{\\mu _1 +\\mu _2}}_{n_x}x + \\underbrace{\\frac{\\mu _2n_2}{\\mu _1 +\\mu _2}}_{n_y}y - \\underbrace{\\frac{\\mu _1m_1 + \\mu _2m_2}{\\mu _1 +\\mu _2}}_{m}\\right)\n\nOn a alors : \n\\dot z = z(n_xx+n_yy-m)\n\nMaintenant considérons les proies :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-\\frac{p_1xz_1\\mu _1}{\\mu _1} \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-\\frac{p_2yz_2\\mu _2}{\\mu _2} \\\\\n\\end{array}\\right.\n \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-\\overbrace{\\frac{p_1xz\\mu _1}{\\mu _1+\\mu _2}}^{p_x} \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-\\underbrace{\\frac{p_2yz\\mu _2}{\\mu _1+\\mu _2}}_{p_y}\n\\end{array}\\right.\n\nCeci donne donc le modèle d’augmentorium de la partie précédente :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{2}\nL’analyse de ce modèle est faite ici et toutes les propositions vues sont aussi applicables dans ce modèle.\nNous allons faire quelques simulations pour voir si le modèle suit les modèles précédents et voir son comportement pour des \\delta \\ne \\infty."
  },
  {
    "objectID": "modfinal.html#dynamique-du-modèle-non-réduit",
    "href": "modfinal.html#dynamique-du-modèle-non-réduit",
    "title": "Modèle proies-prédateurs structuré",
    "section": "Dynamique du modèle non réduit :",
    "text": "Dynamique du modèle non réduit :\nOn va voir la dynamique des 4 populations dans un premier temps :\n\n\nCode\n#Définition du modèle avec prédateurs:\n\ndef aug3(etat, t, param):\n    x, y, z1, z2 = etat\n    rx,Kx,ry,Ky,gx,gy,b,px,py,nx,ny,mx,my,d,mux,muy = param\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z1*x,\n    ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z2,\n    z1*(nx*x-mx)+d*(z2/muy-z1/mux),\n    z2*(ny*x-my)+d*(z1/mux-z2/muy)]\n    return s\n\n#Paramètres Simulation 1 : \nrx1=1\nry1=1.5\nKx1=3\nKy1=2\ngx1=0.5\ngy1=3\nb1=1\npx1=1\npy1=1.5\nnx1=1.5\nny1=2\nmx1=0.5\nmy1=0.5\nd1=1\nmux1=1.5\nmuy1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,b1,px1,py1,nx1,ny1,mx1,my1,d1,mux1,muy1])\n\n#Paramètres Simulation 2 : \nrx2=0.5\nry2=1\nKx2=3\nKy2=2\ngx2=0.5\ngy2=3\nb2=1\npx2=1\npy2=1.5\nnx2=1\nny2=1.5\nmx2=0.5\nmy2=0.5\nd2=1\nmux2=1.5\nmuy2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,b2,px2,py2,nx2,ny2,mx2,my2,d2,mux2,muy2])\n\n#Temps d'intégration 1:\nt=np.arange(0,100,0.01)\n\n#Condition initiale de 1:\nx0=2\ny0=0\nz10=0.5\nz20=0\nc0=np.array([x0,y0,z10,z20])\n\n#Simulation 1:\ns1=odeint(aug3,c0,t,args=(param_a1,))\ns2=odeint(aug3,c0,t,args=(param_a2,))\n\n#Plot de la figure: \nfig,(ax,ax1) = plt.subplots(1,2,figsize=(14,5))\nfig.suptitle('Simulation du modèle final d\\'augmentorium')\nplt.subplots_adjust(wspace=0.2)\n\n#Plot de l'axe 1:\nax.plot(t,s1[:,0],color='C0',label='Ravageurs dans la culture')\nax.plot(t,s1[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax.plot(t,s1[:,2],color='C6',label='Prédateurs dans la culture')\nax.plot(t,s1[:,3],color='C9',label='Prédateurs dans l\\'augmentorium')\n\n#Plot de l'axe 1:\nax1.plot(t,s2[:,0],color='C0',label='Ravageurs dans la culture')\nax1.plot(t,s2[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax1.plot(t,s2[:,2],color='C6',label='Prédateurs dans la culture')\nax1.plot(t,s2[:,3],color='C9',label='Prédateurs dans l\\'augmentorium')\n\n#Légendes et titres:\nax.set_ylabel('Population, x,y,z1,z2')\nax.legend(fontsize=8)\nax.grid()\nax.set_xlabel('Temps, t')\nax.set_title('Coexistence des quatres populations',fontsize=7.5)\n\nax1.set_ylabel('Population, x,y,z1,z2')\nax1.legend(fontsize=8)\nax1.grid()\nax1.set_xlabel('Temps, t')\nax1.set_title('Disparition des prédateurs',fontsize=7.5)\n\n\nText(0.5, 1.0, 'Disparition des prédateurs')\n\n\n\n\n\nOn observe deux situations, l’une avec un équilibre de coexistence des quatres populations et l’autre avec disparition des preédateurs."
  },
  {
    "objectID": "modelaug.html#espace-détat",
    "href": "modelaug.html#espace-détat",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Espace d’état",
    "text": "Espace d’état\nPour tracer l’espace d’état nous posons toutes les variations égales à 0 (situation d’équilibre) :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)-p_xx^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)-p_yy^*z^* \\\\\n0 = z^*\\left(n_xx^*+n_yy^* - m\\right)\n\\end{array}\\right.\n\\tag{2}\nqui devient :\n\n\\left\\{\\begin{array}{l}\nz^* = \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right)+\\frac{\\beta}{p_xx^*}\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)\\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right)+\\frac{\\beta}{p_yy^*}\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)\\\\\nz^*=0 \\lor n_xx^*+n_yy^*=m\n\\end{array}\\right.\n\\tag{3}\nNous nous retrouvons avec deux surfaces et deux plans dont les intersections seront les équilibres. Voyons ceci avec une animation :\n\n\nCode\nimport IPython.display as display\n\nfig01 = \"\"\"\n&lt;iframe width = \"700\" height = \"550\" src = \"https://www.geogebra.org/classic/bw3wqnzg\" style = \"border: 1px solid black\"&gt;&lt;/iframe&gt;\n\"\"\"\n\ndisplay.HTML(fig01)\n\n\n\n\n\nFigure 2: Animation Geogebra représentant l’espace de phase\n\n\n\nEn vert nous avons l’intersection entre la surface définie par \\dot x =0 et les plans z=0 et n_xx+n_yy=m.\nEn rouge nous avons l’intersection entre la surface définie par \\dot y =0 et les plans z=0 et n_xx+n_yy=m.\nNous avons donc que l’intersection des courbes vertes et rouges sont les équilibres. Il est facile de voir qu’il n’en existe que trois différents dont un seul correspond à la coexistence des trois populations.\n\nCalcul des équilibres\nSi z=0 alors (1) devient:\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx(1-\\frac{x}{K_x})+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)\\\\\n\\dot y = r_yy(1-\\frac{y}{K_y})+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\end{array}\\right.\n\\tag{4}\nqui est exactement le système considéré précedemment. Pour l’analyse de ses équilibres se référer à ceci.\nNous allons donc s’intéresser uniquement à l’équilibre de coexistence que nous noterons (x^* , y^* , z^*).\nNous allons calculer pour différentes valeurs de \\beta les valeurs de l’équilibre et leur stabilité.\nEn effet le calcul exact de l’équilibre pour un \\beta quelconque est difficile, et nous allons donc partir de cas plus simple avant d’effectuer des simulations Python pour le cas quelconque.\n\nLorsque \\beta = 0\nNous définissons le système (2) par \\mathbb{F(x,y,z,\\beta)} : \n\\mathbb{F(x,y,z,\\beta)} = \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\nde telle sorte que si nous cherchons l’équilibre pour \\beta =0 alors nous avons: \n\\mathbb{F(x^*,y^*,z^*,0)} = 0\n \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)-p_xx^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)-p_yy^*z^* \\\\\n0 = z^*\\left(n_xx^*+n_yy^* - m\\right)\n\\end{array}\\right.\n\\tag{5} \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\nz^* = \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) \\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right) \\\\\ny^* = \\frac{1}{n_y}\\left(m-n_xx^*\\right)\n\\end{array}\\right.\n\\tag{6} et ainsi :\n\n\\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) = \\frac{r_y}{p_y}\\left(1-\\frac{m}{n_yK_y}+\\frac{n_xx^*}{n_y}\\right)\n et donc : \nx^*=\\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\n\nNous déduisons y^* et z^* avec leur définition d’après (6): \n\\left\\{\\begin{array}{l}\nx^* =  \\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x} \\\\\ny^* = \\frac{K_y\\left(r_yn_xp_xK_x+r_xp_ym - r_xn_xp_yK_x\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x} \\\\\nz^* = r_xr_y\\left(\\frac{n_xK_x+n_yK_y-m}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\right)\n\\end{array}\\right.\n\\tag{7}\n\n\n\n\n\n\nWarning\n\n\n\nLe document de Freedman H. I. (1977) contient deux erreurs, un B_1 à la place d’un \\beta_1 dans l’expression de y^* (respectivement x_{20} dans son article) et un p_y à la place d’un p_x dans l’expression de z^* (respectivement un \\beta_2 à la place d’un \\beta_1 selon ses notations).\n\n\nPour que ces équilibres soient positifs il faut que :\n\n-\\frac{mr_y}{K_yn_yp_y} &lt; \\frac{r_x}{p_x} - \\frac{r_y}{p_y} &lt; \\frac{mr_x}{K_xn_xp_x}\n\\tag{8}\net\n\nn_xK_x+n_yK_y &gt; m\n\\tag{9}\nNous verrons dans la suite que (9) est la condition permettant l’invasion des prédateurs lorsque les proies sont à leur équilibre.\n\n\nLorsque \\beta \\ne 0 et petit\nPour \\beta petit nous allons utiliser l’égalité de Taylor pour trouver (x_*,y^*,z^*). Nous avons alors, en notant (x^*(\\beta),y^*(\\beta),z^*(\\beta)):\n\n\\left\\{\\begin{array}{l}\nx^*(0) = \\frac{K_x\\left(r_yp_xm+r_xn_yp_yK_y-r_yn_yp_xK_y\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\\\\ny^*(0) = \\frac{K_y\\left(r_yn_xp_xK_x+r_xp_ym - r_xn_xp_yK_x\\right)}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\\\\nz^*(0) = r_xr_y\\left(\\frac{n_xK_x+n_yK_y-m}{r_xn_yp_yK_y+r_yn_xp_xK_x}\\right)\n\\end{array}\\right. \\\\\n\nSoit \\mathbb{F(x,y,z,\\beta)} tel que : \n\\mathbb{F(x,y,z,\\beta)} = \\left\\{\\begin{array}{l}\nr_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\nr_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\nz\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right. \\\\\n\nNous voulons ainsi résoudre : \n\\mathbb{F\\left(\\mathcal{x}^*(\\beta) , \\mathcal{y}^*(\\beta) , \\mathcal{z}^*(\\beta) , \\beta\\right)}=0\n\nor, d’après la formule de Taylor nous avons à l’ordre 1 en dimension 4 nous avons:\n\n\\mathbb{F\\left(\\mathcal{x}^*(\\beta) , \\mathcal{y}^*(\\beta) , \\mathcal{z}^*(\\beta) , \\beta\\right)}=\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)} + \\\\\n\\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta + \\mathbb{J}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}}\\small\\begin{pmatrix} \\mathcal{x}^*(\\beta) - \\mathcal{x}^*(\\mathcal{0}) \\\\ \\mathcal{y}^*(\\beta) - \\mathcal{y}^*(\\mathcal{0}) \\\\ \\mathcal{z}^*(\\beta) - \\mathcal{z}^*(\\mathcal{0}) \\end{pmatrix} + o(\\beta)\n\\tag{10} \n\\Leftrightarrow\n \n\\begin{pmatrix} \\mathcal{x}^*(\\beta) \\\\ \\mathcal{y}^*(\\beta) \\\\ \\mathcal{z}^*(\\beta) \\end{pmatrix} =\n\\begin{pmatrix} \\mathcal{x}^*(\\mathcal{0}) \\\\  \\mathcal{y}^*(\\mathcal{0}) \\\\  \\mathcal{z}^*(\\mathcal{0}) \\end{pmatrix} - \\mathbb{J^{\\mathcal{-1}}}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} \\small\\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta + o(\\beta)\n\nNous avons, \\frac{\\partial \\mathbb{F}}{\\partial \\beta}\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) , \\mathcal{0}\\right)\\beta = \\begin{pmatrix} -\\frac{\\mathcal{x}^*(\\mathcal{0})}{\\gamma_x}+\\frac{\\mathcal{y}^*(\\mathcal{0})}{\\gamma_y}\\\\\\frac{\\mathcal{x}^*(\\mathcal{0})}{\\gamma_x}-\\frac{\\mathcal{y}^*(\\mathcal{0})}{\\gamma_y}\\\\ 0\\end{pmatrix} .\net, \n\\mathbb{J}\\small{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} =\n\\begin{pmatrix} -\\frac{r_xx^*(0)}{K_x} & 0 & -p_xx^*(0) \\\\ 0 & -\\frac{r_yy^*(0)}{K_y} & -p_yy^*(0) \\\\ n_xz^*(0) & n_yz^*(0) & 0 \\end{pmatrix}\n\nil est alors facile de calculer que, \ndet(\\mathbb{J}) = -x^*(0)y^*(0)z^*(0)\\left(\\frac{r_xn_yp_y}{K_x}+\\frac{r_yn_xp_x}{K_y}\\right) \\ne 0\n\nLa jacobienne est donc bien inversible et nous pouvons la calculer (méthode des cofacteurs) ce qui donne: \n\\mathbb{J^{\\mathcal{-1}}}\\tiny{\\mathbb{F\\left(\\mathcal{x}^*(\\mathcal{0}) , \\mathcal{y}^*(\\mathcal{0}) , \\mathcal{z}^*(\\mathcal{0}) ,\\mathcal{0}\\right)}} =\\small \\frac{1}{\\frac{r_xp_yn_y}{K_x}+\\frac{r_yp_xn_x}{K_y}} \\begin{pmatrix} -\\frac{p_yn_y}{x^*(0)} & \\frac{p_xn_y}{y^*(0)} & \\frac{r_yp_x}{z^*(0)K_y} \\\\ \\frac{p_yn_x}{x^*(0)} & -\\frac{p_xn_x}{y^*(0)} & \\frac{r_xp_y}{z^*(0)K_x} \\\\ -\\frac{r_yn_x}{x^*(0)K_y} & -\\frac{r_xn_y}{y^*(0)K_x}& -\\frac{r_xr_y}{z^*(0)K_xK_y} \\end{pmatrix}\n\\tag{11}\nEn mettant en œuvre le calcul nous trouvons: \n\\left\\{\\begin{array}{l}\nx^*(\\beta) = x^*(0) - \\frac{\\beta n_yK_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{p_y}{x^*(0)}+\\frac{p_x}{y^*(0)}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\\\\\ny^*(\\beta) = y^*(0) - \\frac{\\beta n_xK_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{p_y}{x^*(0)}+\\frac{p_x}{y^*(0)}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\\\\\nz^*(\\beta) = z^*(0) - \\frac{\\beta K_xK_y\\left(\\frac{y^*(0)}{\\gamma_y}-\\frac{x^*(0)}{\\gamma_x}\\right)\\left(\\frac{r_xn-y}{y^*(0)K_x}-\\frac{r_yn_x}{x^*(0)K_y}\\right)}{K_yr_xp_yn_y + K_xr_yp_xn_x} + o(\\beta)\n\\end{array}\\right.\\\\\n\\tag{12}\n\n\nLorsque \\beta est quelconque\n(2) donne, en exprimant y^* en fonction de x^*: \n\\left\\{\\begin{array}{l}\nz^* =  \\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) + \\frac{\\beta}{p_x}\\left(\\frac{m}{n_y\\gamma_y x^*}-\\frac{n_x}{n_y\\gamma_y}-\\frac{1}{\\gamma_x}\\right)   \\\\\nz^* = \\frac{r_y}{p_y}\\left(1-\\frac{m-n_xx^*}{n_yK_y}\\right) + \\frac{\\beta n_y}{p_y}\\left(\\frac{x^*}{\\gamma_x\\left(m-n_xx^*\\right)}-\\frac{1}{n_y\\gamma_y}\\right) \\\\\ny^* =\\frac{1}{n_y}\\left(m- n_xx^*\\right)\n\\end{array}\\right.\n\\tag{13}\nNous trouvons x^* en faisant l’intersection entre les deux premières équations, nous trouvons y^* avec la troisième équation et z^* avec la première équation.\nPour calculer l’équilibre nous utilisons numpy:\n\n\nCode\n#Calcul de x*:\nx = np.polynomial.Polynomial([0, 1])\n#Polynome :\npol1 = (m1 - nx1 * x) * x * rx1/px1 * (1 - x/Kx1) + (m1 - nx1 * x) * b1/px1 * ((m1 - nx1 * x)/(ny1 * gy1) - x/gx1) - (m1 - nx1 * x) * x * ry1/py1 * (1 - (m1 - nx1 * x)/(ny1 * Ky1)) - x * b1 * ny1/py1 * (x/gx1 - (m1 - nx1 * x)/(ny1 * gy1))\n\n#Nous utilisons un masque booléen adapté à la situation --&gt; solution réelle, positive et qui vérifie la condtion imposée par la troisième équation du système:\nsolx = pol1.roots()[(np.isreal(pol1.roots())) * (pol1.roots() &gt; 0) * (pol1.roots()&lt;m1/ny1)]\n\n#Calcul de y*:\nsoly = 1/ny1 * (m1 - nx1 * solx)\n\n#Calcul de z*:\nsolz = rx1/px1 * (1 - solx/Kx1) + b1/px1 * (m1/(ny1 * gy1 * solx) - nx1/(ny1 * gy1) - 1/gx1)\n\n\n\n\n\nStabilité des équilibres\nSans prédateurs (z=0) nous avons les mêmes équilibres que dans la partie précédente, la stabilité est donc la même que dans la partie précédente.\nNous allons calculer pour différentes valeurs de \\beta la stabilité.\n\nLorsque \\beta=0\nLa jacobienne du système est: \n\\mathbb{J_{\\mathcal{x^*_2},\\mathcal{y^*_2},\\mathcal{z^*_2},\\mathcal{0}}}  =  \\begin{pmatrix} -\\frac{r_xx_2^*(0)}{K_x} & 0 & -p_xx_2^*(0) \\\\ 0 & -\\frac{r_yy_2^*(0)}{K_y} & -p_yy_2^*(0) \\\\ n_xz_2^*(0) & n_yz_2^*(0) & 0 \\end{pmatrix}\n\nEn calculant le polynôme caractéristique nous en déduisons que toutes les parties réelles des valeurs propres sont négatives et que donc l’équilibre est stable. La preuve est faite par Freedman dans son théorème 4.1.\n\n\nLorsque \\beta \\ne 0 et \\beta petit\n\n\\mathbb{J_{\\mathcal{x^*},\\mathcal{y^*},\\mathcal{z^*},\\mathcal{\\beta}}}  =  \\begin{pmatrix} -\\frac{r_xx^*(0)}{K_x} -\\frac{\\beta}{\\gamma_x} & \\frac{\\beta}{\\gamma_y} & -p_xx^*(0) \\\\ \\frac{\\beta}{\\gamma_x} & -\\frac{r_yy^*(0)}{K_y}-\\frac{\\beta}{\\gamma_y} & -p_yy^*(0) \\\\ n_xz^*(0) & n_yz^*(0) & 0 \\end{pmatrix} = \\mathbb{J_{\\mathcal{x^*},\\mathcal{y^*},\\mathcal{z^*},\\mathcal{0}}} + \\beta \\begin{pmatrix} -\\frac{1}{\\gamma_x} & \\frac{1}{\\gamma_y} & 0 \\\\ \\frac{1}{\\gamma_x} & -\\frac{1}{\\gamma_y} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n\nComme \\beta est petit nous avons la matrice qui est petite et qui n’influence pas le signe des valeurs propres. Donc l’équilibre est encore stable."
  },
  {
    "objectID": "modelaug.html#equilibres-en-fonction-des-paramètres-du-modèle-simplifié",
    "href": "modelaug.html#equilibres-en-fonction-des-paramètres-du-modèle-simplifié",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Equilibres en fonction des paramètres du modèle simplifié",
    "text": "Equilibres en fonction des paramètres du modèle simplifié\nDans cette partie nous allons distinguer les cas où n_x = n_y et p_x=p_y de ceux où ils sont différents.\nEn effet, l’un des postulats de l’augmentorium est que le développement des ravageurs et prédateurs est favorisé dans celui-ci mais nous pouvons supposer que la prédation et les naissances dans l’augmentorium sont égales.\nIl est intéressant de considérer la somme des équilibre des proies en fonction de la force de migration (\\beta) et les équilibres dans la culture en fonction du taux de fuite (\\gamma_y) et du taux de migration (\\gamma_x).\nDans ce cas (1) devient :\n\n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-pxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-pyz \\\\\n\\dot z = z\\left(n\\left(x+y\\right) - m\\right)\n\\end{array}\\right.\n\\tag{14}\n\nSomme des équilibres des proies en fonction de \\beta\nA l’équilibre, nous avons :\n\n\\left\\{\\begin{array}{l}\n0 = r_xx^*\\left(1-\\frac{x^*}{K_x}\\right)+\\beta\\left(\\frac{y^*}{\\gamma_y}-\\frac{x^*}{\\gamma_x}\\right)-px^*z^* \\\\\n0 = r_yy^*\\left(1-\\frac{y^*}{K_y}\\right)+\\beta\\left(\\frac{x^*}{\\gamma_x}-\\frac{y^*}{\\gamma_y}\\right)-py^*z^* \\\\\nx^*+y^* = \\frac{m}{n}\n\\end{array}\\right.\n\\tag{15}\nNous voyons, avec la troisième équation du système, que la somme des équilibres des proies est toujours égale à \\frac{m}{n} quelque soit \\beta du moment que les prédateurs sont présents.\nIntuitivement nous considèrons que la présence d’un équilibre des prédateurs positifs (invasion des prédateurs) est soumise à la condition que pour une population aussi petite soit elle de prédateurs (z \\to 0) et pour les proies à l’équilibre nous ayons un taux de croissance positif pour les prédateurs.\nMathématiquement cette hypothèse est équivalente à la condition, si nous notons (x_0^*(\\beta),y^*_0(\\beta)) l’équilibre sans prédateurs pour un taux \\beta, que x_0^* + y_0^* &gt; \\frac{m}{n} \\Leftrightarrow \\exists z^* \\ne 0.\n\nPour \\beta = 0 nous avons que s’il existe un équilibre des prédateurs positif alors nous avons K_x+K_y&gt;\\frac{m}{n} par l’égalité (7). Ceci est donc la condition d’invasion des prédateurs (9) mentionnée plus tôt.\nSi \\beta \\to \\infty nous allons réduire le système (14) en équation de Lotka-Volterra avec croissance logistique. Ainsi la présence d’un équilibre des prédateurs sera équivalente à la condition d’invasion supposée .\n\nLa démarche (d’après Arditi R. (2018)) à partir du système (14) est la suivante :\n\n\\frac{\\dot x}{\\gamma_x} - \\frac{\\dot y}{\\gamma_y} = \\frac{r_x}{\\gamma_x}x\\left(1-\\frac{x}{K_x}\\right) - \\frac{r_y}{\\gamma_y}y\\left(1-\\frac{y}{K_y}\\right) + pz\\left(y-x\\right) -\\frac{\\beta}{\\gamma_x} \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right) -\\frac{\\beta}{\\gamma_y} \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\\tag{16}\nQuand \\beta \\to \\infty, \\frac{\\dot x}{\\gamma_x} - \\frac{\\dot y}{\\gamma_y} devient après simplification : \n\\frac{\\dot x}{\\gamma_x} - \\frac{\\dot y}{\\gamma_y} = -\\beta\\left(\\frac{1}{\\gamma_x}+\\frac{1}{\\gamma_y}\\right)\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)\n\net donc nous avons forcément que \\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right) \\to 0 ie que \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\nNous posons N = x+y qui est, avec l’assertion précédente, équivalent à \n\\frac{N}{\\gamma_x+\\gamma_y} = \\frac{x+y}{\\gamma_x+\\gamma_y} = \\frac{\\frac{x\\gamma_x}{\\gamma_x}+\\frac{y\\gamma_y}{\\gamma_y}}{\\gamma_x+\\gamma_y} = \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}\n\\tag{17}\nNous avons ainsi : \n\\dot N = \\dot x + \\dot y = \\frac{r_xx\\gamma_x}{\\gamma_x}\\left(1-\\frac{x}{K_x}\\right) + \\frac{r_yy\\gamma_y}{\\gamma_y}\\left(1-\\frac{y}{K_y}\\right)-pzN\n \n\\Leftrightarrow\n \n\\dot N = \\frac{r_xN\\gamma_x}{\\gamma_x+\\gamma_y}\\left(1-\\frac{x}{K_x}\\right) + \\frac{r_yN\\gamma_y}{\\gamma_x+\\gamma_y}\\left(1-\\frac{y}{K_y}\\right)-pzN\n \n\\Leftrightarrow\n \n\\dot N = \\left(\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right)N\\left(1-\\frac{\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}}{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}N\\right)-pzN\n\\tag{18}\nEn posant r_N = \\left(\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right) et K_N=\\frac{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}{\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}} le système devient :\n \\left\\{\\begin{array}{l}\n\\dot N = r_NN\\left(1-\\frac{N}{K_N}\\right)-pzN \\\\\n\\dot z = z\\left(nN - m\\right)\n\\end{array}\\right.\n\\tag{19}\nqui est bien un système de L-V avec croissance logistique.\nSi \\exists z^* &gt; 0 alors nous avons N^*=\\frac{m}{n}.\nDe plus, nous avons : pz^* = r_N\\left(1-\\frac{N^*}{K_N}\\right) et donc si z^*&gt;0 nous avons N^* &lt; K_N qui est équivalent à \\frac{m}{n} &lt; K_N.\nSi nous considérons le système précédent sans prédateurs nous avons :\n \\left\\{\\begin{array}{l}\n\\dot N_0 = r_NN_0\\left(1-\\frac{N_0}{K_N}\\right)\n\\end{array}\\right.\n\net nous avons donc N_0^* = K_N.\nOr, posons la condition mathématique intuitive : \nx^*_0(+\\infty)+y^*_0(+\\infty) &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \n\\frac{x^*_0(+\\infty)\\gamma_x}{\\gamma_x}+\\frac{y^*_0(+\\infty)\\gamma_y}{\\gamma_y} &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \n\\frac{N_0^*(+\\infty)\\gamma_x}{\\gamma_x+\\gamma_y}+\\frac{N^*_0(+\\infty)\\gamma_y}{\\gamma_x+\\gamma_y} &gt; \\frac{m}{n}\n \n\\Leftrightarrow\n \nK_N &gt; \\frac{m}{n}\n\nL’intuition biologique est donc confirmée par des preuves mathématiques pour \\beta=0 et \\beta \\to +\\infty ceci est suffisant pour penser que c’est vrai pour un \\beta \\in ]0,+\\infty[.\nNous allons donc tracer les graphes de la somme des équilibres du système (1) avec et sans prédateurs et constater cette saturation à lorsque la condition x_0^* + y_0^* &gt; \\frac{m}{n} est validée.\nPour cela nous nous appuierons sur 3 cas selon le comportement du système sans prédateurs. Nous prendrons en premier le cas où le système était déja déflationniste, en deuxième le cas où le système était à la fois inflationniste et déflationniste puis le cas où le système est tout le temps inflationniste.\nCeci va permettre de comprendre le rôle de l’ajout de prédateurs.\nPour faire nos simulations nous laissons tourner le modèle précédent et le modèle actuel indépendamment pour différentes valeur de \\beta et nous traçons dans les deux cas la somme des équilibres atteintes pour des temps d’intégration large.\n\nDéflation du système sans prédateurs\nPour plot nous allons simuler avec odeint pendant un temps assez large pour atteindre l’équilibre :\n\n\nCode\n#Définition d'une fonction qui prend en compte le changement de migration:\ndef a(etat, t, param, i):\n    x, y, z = etat\n    b = i\n    rx, Kx, ry, Ky, gx, gy, p, n, m = param\n    xdot, ydot, zdot = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx) - p * z * x, ry * y * (1 - y/Ky) + b * (x/gx - y/gy) - p * y * z, z * (n * (x + y) - m)]\n    return [xdot, ydot, zdot]\n\n#Définition du modèle sans prédateurs:\ndef aug(etat, t, param, i):\n    rx, Kx, ry, Ky, gx, gy = param\n    b = i\n    x, y = etat\n    s=[rx * x * (1 - x/Kx) + b * (y/gy - x/gx), ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\np1 = 1\nm11 = 1\nn11 = 0.25\nm12 = 3\nn12 = 2\n\nparam11 = np.array([rx1, Kx1, ry1, Ky1, gx1, gy1, p1, n11, m11])\nparam12 = np.array([rx1, Kx1, ry1, Ky1, gx1, gy1, p1, n12, m12])\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 1000, 0.01)\n\n#Condition initiale:\ne0 = [1, 1, 1]\n\n#Figure:\nfig, ax = plt.subplots(1, 2, figsize = (9, 5))\nplt.subplots_adjust(wspace = 0.3)\n\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s11 = odeint(a, e0, t, args = (param11, i)) #Nous calculons pour chaque beta l'équilibre\n    ax[0].plot(i, s11[-1][0] + s11[-1][1], marker = '.', markersize = 3, color = 'C0')\n    s12 = odeint(a, e0, t, args = (param12, i))\n    ax[1].plot(i, s12[-1][0] + s12[-1][1], marker = '.', markersize = 3, color = 'C0')\n    \n    s11sp = odeint(aug, e0[0:2], t, args = (param11[0:6], i))\n    ax[0].plot(i, s11sp[-1][0] + s11sp[-1][1], marker = '.', markersize = 1, color = '0.7')\n    s12sp = odeint(aug, e0[0:2], t, args = (param12[0:6], i))\n    ax[1].plot(i, s12sp[-1][0] + s12sp[-1][1], marker = '.', markersize = 1, color = '0.7')\n\n#Plot de la droite Kx+Ky:    \nxt = np.arange(0, 4, 0.01)\nxt2 = np.arange(0, 4, 0.01)\n\nax[0].plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax[1].plot(xt2, (Kx1 + Ky1) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\n\n#Plot de m/n:\nax[0].plot(xt, m11/n11 * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\nax[1].plot(xt, m12/n12 * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\n\n#Légendes:\nax[0].set_xlabel('β')\nax[1].set_xlabel('β')\n\n\nax[0].set_ylabel('Population')\nax[0].plot(0, Kx1 + Ky1, color = '0.8', label = 'Somme des équilibres du modèle sans prédateurs')\nax[0].plot(0, Kx1 + Ky1, color = 'C0', label = 'Somme des équilibres du modèle avec prédateurs')\nax[0].plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm/n')\nax[0].plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n#Nous déplaçons la légende hors de la figure:\nax[0].legend(bbox_to_anchor = (0.5, -0.6, 0.5, 0.5), fontsize = 10)\n\n#Titres:\nax[0].set_title('Déflation')\nax[1].set_title('Déflation');\n\n\n\n\n\nFigure 3: Somme des équilibres du système avec prédateurs avec inflation et déflation du système sans prédateurs\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDans la légende nous remarquons qu’en gris nous avons la somme des équilibres du modèle sans prédateurs et en bleu du modèle avec prédateurs. Ceci ne veut pas dire que la courbe bleu représente la somme des équilibres d’un système avec des prédateurs en vie tout le temps puisque nous avons vu à l’instant qu’ils ne sont pas présents sur la Figure 3 à gauche par exemple.\nQuand nous disons avec prédateurs c’est que le modèle prend en compte les prédateurs et donc il prend en compte quand leur population est nulle.\nQuand cette population est nulle nous avons montré que le modèle avec prédateurs était égal au modèle sans prédateurs de la partie précédente expliquant que les deux courbes se rejoignent mais il faut bien garder en tête que nous simulons deux modèles complètement différents (l’un en 2D l’autre en 3D).\n\n\nNous avons pris dans notre premier cas un système qui subissait une déflation de base et qui subit pour certaines valeurs de \\beta une invasion de prédateurs.\nNous retrouvons bien en gris (somme des équilibres sans prédateurs) le même profil de courbe que dans la partie précédente.\nEn orange nous retrouvons la droite correspondant à \\frac{m}{n} qui va permettre de voir l’installation des prédateurs quand la courbe grise la traversera.\nLa droite en noir correspond à K_x+K_y et va permettre de voir si nous avons inflationou déflation du système.\nEnfin la courbe bleu décrit la somme des équilibres dans le système (1) et présente à la fois la somme des équilibres si nous avons invasion des prédateurs (et donc mise en place de l’équilibre (x^*,y^*,z^*)) et à la fois la somme des équilibres si nous avons disparition des ravageurs.\nDans ce cas là, qui correspond à un cas où la courbe grise est en dessous de la droite orange (cf la condition d’invasion décrite plus haut), nous observons bien que la courbe bleu et la courbe grise sont confondues.\nIntuitivement nous pouvons se dire que rajouter des prédateurs à un système subissant déjà une déflation sans prédateurs ne peut faire qu’aller dans le sens de la déflation.\nNous pouvons observer sur notre figure que c’est bien le cas.\nA gauche nous observons que comme nous avons \\frac{m}{n} tout le temps plus grand que x_0^* + x^*_0 alors les prédateurs ne s’installent pas et donc la courbe bleu est confondu avec la courbe grise (x_0^* + x^*_0 = x^*+y^*). Comme les prédateurs ne sont pas présents nous observons la même déflation que dans le modèle précédent.\nA droite nous observons que \\frac{m}{n} est d’abord en dessous de x_0^* + x^*_0 et donc les prédateurs peuvent s’installer expliquant la saturation à \\frac{m}{n} et dès que x_0^* + x^*_0 passe en dessous de \\frac{m}{n} nous observons que la courbe bleu rejoint la courbe grise.\nAinsi nous voyons dans ce cas que l’ajout de prédateurs permet d’avoir une forte déflation même pour des forces de migration \\beta basse ce qui n’est pas le cas dans le modèle précédent (comme en témoigne la courbe grise).\n\n\nDélfation/Inflation du système sans prédateurs\nNous utilisons le même code python en changeant les paramètres:\n\n\nCode\n#Paramètres:\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\np2 = 1\nm21 = 1\nn21 = 0.3278\nm22 = 1\nn22 = 0.335\n\nparam21 = np.array([rx2, Kx2, ry2, Ky2, gx2, gy2, p2, n21, m21])\nparam22 = np.array([rx2, Kx2, ry2, Ky2, gx2, gy2, p2, n22, m22])\n\n#Figure:\nfig, ax = plt.subplots(1, 2, figsize = (9, 5))\nplt.subplots_adjust(wspace = 0.3)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s21 = odeint(a, e0, t, args = (param21, i))\n    ax[0].plot(i, s21[-1][0] + s21[-1][1], marker = '.', markersize = 3, color = 'C0')             \n    s22 = odeint(a, e0, t, args = (param22, i))\n    ax[1].plot(i, s22[-1][0] + s22[-1][1], marker = '.', markersize = 3, color = 'C0')              \n    \n    s21sp = odeint(aug, e0[0:2], t, args = (param21[0:6], i))\n    ax[0].plot(i, s21sp[-1][0] + s21sp[-1][1], marker = '.', markersize = 1, color = '0.7')\n    s22sp = odeint(aug, e0[0:2], t, args = (param22[0:6], i))\n    ax[1].plot(i, s22sp[-1][0] + s22sp[-1][1], marker = '.', markersize = 1, color = '0.7')\n\n\n#Plot de la droite Kx+Ky:\nax[0].plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax[1].plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\n\n#Plot de m/n:\nax[0].plot(xt, m21/n21 * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\nax[1].plot(xt, m22/n22 * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\n\n#Légendes:\nax[0].set_xlabel('β')\nax[1].set_xlabel('β')\n\nax[0].set_ylabel('Population')\nax[0].plot(0, Kx2 + Ky2, color = '0.8', label = 'Somme des équilibres du modèle sans prédateurs')\nax[0].plot(0, Kx2 + Ky2, color = 'C0', label = 'Somme des équilibres du modèle avec prédateurs')\nax[0].plot(0, Kx2 + Ky2, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm/n')\nax[0].plot(0, Kx2 + Ky2, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n#Nous déplaçons la légende hors de la figure:\nax[0].legend(bbox_to_anchor = (0.5, -0.6, 0.5, 0.5), fontsize = 10);\n\nax[0].set_title('Les deux');\nax[1].set_title('Déflation');\n\n\n\n\n\nFigure 4: Somme des équilibres du système avec prédateurs avec inflation et déflation du système sans prédateurs\n\n\n\n\nLa légende est en tout point similaire à la simulation précédente.\nA gauche nous observons d’abord que la courbe bleu et grise sont confondues (traduisant une absence de prédateurs), puis une saturation à \\frac{m}{n} (traduisant une présence de prédateurs) puis de nouveau une disparition des prédateurs avec les courbes bleu et grise qui se rejoignent.\nAinsi, dans ce cas la présence de prédateurs permet de limiter l’inflation en saturant à \\frac{m}{n}.\nA droite nous observons que encore une fois pour des valeurs de \\frac{m}{n} &lt; K_x+K_y nous avons déflation en permanence. Nous verrons que nous pouvons en déduire un cas général.\nNous observons donc une déflation, grace à la saturation pour de faibles valeurs de \\beta, alors que le modèle précédent montrait une inflation.\n\n\nInflation du système sans prédateurs\nNous utilisons encore le même code python en changeant les paramètres:\n\n\nCode\n#Paramètres:\n#3:\nrx3 = 1\nry3 = 2\nKx3 = 2\nKy3 = 1.5\ngx3 = 2\ngy3 = 1\np3 = 0.5\nm31 = 1\nn31 = 0.2832\nm32 = 1\nn32 = 0.289\n\nparam31 = np.array([rx3, Kx3, ry3, Ky3, gx3, gy3, p3, n31, m31])\nparam32 = np.array([rx3, Kx3, ry3, Ky3, gx3, gy3, p3, n32, m32])\n\n#Figure:\nfig, ax = plt.subplots(1, 2, figsize = (9, 5))\nplt.subplots_adjust(wspace = 0.3)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s31 = odeint(a, e0, t, args = (param31, i))\n    ax[0].plot(i, s31[-1][0] + s31[-1][1], marker = '.', markersize = 3, color = 'C0')\n    s32 = odeint(a, e0, t, args = (param32, i))\n    ax[1].plot(i, s32[-1][0] + s32[-1][1], marker = '.', markersize = 3, color = 'C0')\n    \n    s31sp = odeint(aug, e0[0:2], t, args = (param31[0:6], i))\n    ax[0].plot(i, s31sp[-1][0] + s31sp[-1][1], marker = '.', markersize = 1, color = '0.7')\n    s32sp = odeint(aug, e0[0:2], t, args = (param32[0:6], i))\n    ax[1].plot(i, s32sp[-1][0] + s32sp[-1][1], marker = '.', markersize = 1, color = '0.7')\n\n#Plot de la droite Kx+Ky: \nax[0].plot(xt2, (Kx3 + Ky3) * np.ones_like(xt2), linestyle = 'dashed', color = 'k', markersize = '6')\nax[1].plot(xt, (Kx3 + Ky3) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\n\n#Plot de m/n:\nax[0].plot(xt, m31/n31 * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\nax[1].plot(xt, m32/n32 * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')         \n\n#Légendes:\nax[0].set_xlabel('β')\nax[1].set_xlabel('β')\n\n\nax[0].set_ylabel('Population')\nax[0].plot(0, Kx3 + Ky3, color = '0.8', label = 'Somme des équilibres du modèle sans prédateurs')\nax[0].plot(0,  Kx3 + Ky3, color = 'C0', label = 'Somme des équilibres du modèle avec prédateurs')\nax[0].plot(0, Kx3 + Ky3, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm/n')\nax[0].plot(0, Kx3 + Ky3, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n#Nous déplaçons la légende hors de la figure:\nax[0].legend(bbox_to_anchor = (0.5, -0.6, 0.5, 0.5), fontsize = 10);\n\n#Titres\nax[0].set_title('Inflation');\nax[1].set_title('Déflation');\n\n\n\n\n\nFigure 5: Somme des équilibres du système avec prédateurs avec inflation du système sans prédateurs\n\n\n\n\nEncore une fois nous observons des courbes qui saturent à \\frac{m}{n} quand la condition d’invasion des prédateurs est vérifiée.\nNous pouvons voir sur la courbe de droite, et nous allons le montrer, que pour les trois profils (ou quatre si nous comptons que l’inflation peut en présenter deux) de courbe (déflation,inflation/déflation et inflation) si \\frac{m}{n} &lt; K_x + K_y le système subit une déflation en permanence.\nEn effet, si \\frac{m}{n} &lt; K_x + K_y alors nous distiguons deux cas :\n\nSoit x^*_0+y^*_0&gt;\\frac{m}{n} et donc nous avons invasion des prédateurs et saturation de la courbe à \\frac{m}{n} (qui est en dessous de K_x + K_y par hypothèse) et donc déflation constante.\nC’est le cas que nous observons dans la Figure 5 à droite.\nSoit x^*_0+y^*_0&lt;\\frac{m}{n} et donc les prédateurs disparaissent et donc x_0^* + x^*_0 = x^*+y^* ce qui montre que x^*+y^* &lt; \\frac{m}{n} &lt; K_x + K_y et qui explique que nous ayons une déflation constante. C’est le cas que nous observons dans la Figure 3 à droite pour des valeurs de \\beta plus grande que 2.\n\nCes graphiques traduisent bien l’effet de l’ajout des prédateurs dans un système : si celui ci est déja déflationniste il le reste, si celui ci était inflationniste et déflationniste ou complètement inflationniste alors son inflation est limitée par les prédateurs (jusqu’à même pouvoir devenir délfationiste, voir figure 3 à droite).\nSi nous reprenons les conditions d’inflations et déflations posées précédemment peut les adapter à ce modèle :\n\nSi le système sans prédateurs est de base déflationniste alors le système avec prédateurs est aussi déflationniste (avec survie ou pas des prédateurs).\nAinsi d’après les conditions du modèle précédent nous avons que si \\frac{\\gamma_y}{\\gamma_x}&gt;\\frac{K_y}{K_x} (condition de déflation du modèle précédent) alors le système avec prédateurs est toujours déflationniste.\nSi \\frac{\\gamma_y}{\\gamma_x}&lt;\\frac{K_y}{K_x} (condition d’inflation et de déflation du modèle précédent) alors nous avons soit un système inflationniste si \\frac{m}{n} &lt; K_x+K_y soit un système inflationniste et déflationniste mais moins inflationniste que sans les prédateurs si \\frac{m}{n} &lt; (x^*_0+y^*_0)_{max} (autrement dit la courbe grise est au dessus de la droite orange).\nSi \\frac{r_xK_y}{r_yK_x} &lt; \\frac{\\gamma_y}{\\gamma_x} &lt; \\frac{K_y}{K_x} (conditions d’inflation du modèle précédent) alors si nous avons x^*(\\infty)+y^*(\\infty) &gt; \\frac{m}{n} &gt; K_x+K_y alors le système est inflationniste mais moins que son pendant sans prédateurs.\n\n\n\n\nEquilibre de la culture en fonction de \\gamma_y\nNous allons maintenant voir l’évolution de l’équilibre dans la culture en fonction de \\gamma_y (le taux de fuite):\n\n\nCode\n#Nous définissons du nouveau modèle qui prend en compte le changement de gy :\ndef a2(etat, t, param, h):\n    x, y, z = etat\n    rx, Kx, ry, Ky, gx, b, p, n, m = param\n    gy = h\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx) - p * z * x, \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy) - p * y * z, \n    z * (n * (x + y) - m)]\n    return s\n\n#Définition de l'ancien modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1  \nKx1 = 1\nKy1 = 2\ngx1 = 0.5\nb = 1\np = 1\nn = 0.4\nm = 1\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b, p, n, m])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx1 - 0.1, '$K_x$')\n\n#Plot de m/n:\nax.plot(xt, m/n * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\nax.text(3.15, m/n - 0.1, 'm/n')\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.001):\n    s = odeint(a2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax1.plot(i, s[-1][0], marker = '.', color = 'C0')\n\n    s = odeint(aug3, e0[0:2], t, args = (param1[0:6], i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = '0.8', markersize = 3)\n    ax1.plot(i, s[-1][0], marker = '.', color = '0.8', markersize = 3)\n\n#Légendes:\nax1.set_xlabel('Ɣy, Fuite')\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, Kx1 + Ky1, color = 'C0', label = 'Somme des équilibres avec prédateurs')\nax1.plot(0, Kx1, color = 'C0', label = 'Eq. culture avec prédateurs ($x^*$)')\n\nax.set_title('Somme des équilibres en fonction du taux de fuite', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de fuite', fontsize = 7)   \nax.legend(fontsize = 7, loc = \"lower right\");\nax1.legend(fontsize = 7, loc = \"upper right\");\nax.set_ylabel(\"Densité de pop.\");\n\n\n\n\n\nFigure 6: Equilibres en fonction du taux de fuite sur un modèle simplifié\n\n\n\n\nEn gris nous pouvons voir la somme des équilibres du modèle sans prédateurs et en orange nous observons sur la figure gauche la droite \\frac{m}{n}.\nAinsi, nous pouvons voir quand est ce qu’en fonction du taux de fuite la population de prédateurs disparaît.\nPour représenter cette figure nous avons considéré que r_x&lt;r_y et K_x&lt;K_y sans perte de généralité.\nA gauche, nous observons que la somme des équilibres des ravageurs sans prédateurs est bien similaire à celle obtenue dans la partie précédente.\nQuand il n’y a pas de prédateurs nous observons bien comme précédemment que la courbe bleu et grise se rejoignent.\nEn revanche quand nous avons des prédateurs (la courbe grise est au dessus de \\frac{m}{n}) alors nous avons bien la saturation de la somme des équilibres.\nA droite nous observons la même simulation qu’à gauche (en terme de paramètres) mais nous représentons uniquement l’équilibre dans la culture qui est l’équilibre qui nous intéresse le plus.\nNous observons que pour les valeurs de taux de fuite de disparition des prédateurs à gauche nous avons aussi à droite la courbe bleu qui se sépare de la courbe grise.\nNous remarquons cette courbe bleu décroît plus vite vers la déflation que la courbe grise montrant l’effet bénéfique des parasites pour baisser les ravageurs dans le système.\nAinsi, dans ce modèle nous avons aussi que des forts taux de fuite engendrent une inflation dans la culture."
  },
  {
    "objectID": "modelaug.html#equilibres-en-fonction-des-paramètres-du-modèle-complet",
    "href": "modelaug.html#equilibres-en-fonction-des-paramètres-du-modèle-complet",
    "title": "Modèle avec proies structurées et prédateurs",
    "section": "Equilibres en fonction des paramètres du modèle complet",
    "text": "Equilibres en fonction des paramètres du modèle complet\nMaintenant nous allons considérer le modèle plus complexe de naissances (n) et de la prédation (p) différentes entre la culture et l’augmentorium.\nCe postulat n’est pas anodin car nous pouvons vraisemblablement penser que l’augmentorium fournit une structure positive à la croissance grâce à la grande concentration de ressources qu’il renferme et à son relatif cloisonnement de l’extérieur.\n\nSomme des équilibres des proies en fonction de \\beta\nPrécédemment nous observions une saturation de la somme des proies à \\frac{m}{n}. Mais cette observation résultait de la trop forte simplification du modèle considéré. En considérant notre modèle actuel et en faisant l’hypothèse que z^* \\ne 0 alors nous avons la condition n_xx^*+n_yy^* = m qui ne renseigne pas comme auparavant sur la taille de la population de ravageurs à l’équilibre.\nL’intuition mathématique, via le même raisonnement biologique précédent, est que l’invasion des prédateurs ie \\exists z^* &gt; 0 est vérifiée si seulement si n_xx_0^*(\\beta) + n_yy_0^*(\\beta)&gt;m où x_0^*(\\beta) et y_0^*(\\beta) sont les équilibres du système sans prédateurs.\nMontrons le mathématiquement pour \\beta = 0 et \\beta \\to +\\infty :\n\nPour \\beta =0, une autre manière de montrer la condition (autre que celle utilisée pour le modèle simplifié) est de considérer le système suivant donné par \\beta = 0:\n\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{20}\nqui pour un équilibre positif implique que : \n\\frac{r_x}{p_x}\\left(1-\\frac{x^*}{K_x}\\right) = \\frac{r_y}{p_y}\\left(1-\\frac{y^*}{K_y}\\right)\n qui donne, via la condition z &gt; 0, après réarrangement: \nx^* = \\frac{K_x\\left(r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\\right)}{r_xp_yn_yK_y+r_yp_xn_xK_x}\n\\tag{21}\nPar l’expression de z^* nous avons K_x &gt; x^* autrement dit : \nK_x &gt; \\frac{K_x\\left(r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\\right)}{r_xp_yn_yK_y+r_yp_xn_xK_x}\n \n\\Leftrightarrow\n \nr_xp_yn_yK_y+r_yp_xn_xK_x &gt; r_xp_yn_yK_y-r_yp_xn_yK_y+r_yp_xm\n \n\\Leftrightarrow\n \nr_yp_x(n_xK_x+n_yK_y) &gt; r_yp_xm \\Leftrightarrow n_xK_x + n_yK_y &gt; m\n\nOr x_0^*(0) = K_x et y_0^*(0) = K_y car ce ne sont que des croissances logistiques en l’absence de prédateurs.\nAinsi la condition n_xx_0^*(0) + n_yy_0^*(0)&gt;m équivaut à n_xK_x + n_yK_y &gt; m qui est la condition d’un équilibre z&gt;0.\nLa condition d’un équilibre positif implique bien la condition d’invasion.\n\nPour \\beta =+\\infty, nous allons simplifier le système (1).\n\nNous posons N = x+y et en faisant tendre \\beta \\to +\\infty et en considérant \\frac{\\dot x}{\\gamma_x} - \\frac{\\dot y}{\\gamma_y} nous avons forcément \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y} (similairement à la réduction du modèle simplifié).\nCette condition permet de dire que \\frac{N}{\\gamma_x+\\gamma_y} = \\frac{x}{\\gamma_x} = \\frac{y}{\\gamma_y}.\n\n\\dot N = \\frac{r_xx\\gamma_x}{\\gamma_x}\\left(1-\\frac{x\\gamma_x}{K_x\\gamma_x}\\right) + \\frac{r_yy\\gamma_y}{\\gamma_y}\\left(1-\\frac{y\\gamma_y}{K_y\\gamma_y}\\right) - z\\left(\\frac{p_xx\\gamma_x}{\\gamma_x}+\\frac{p_yy\\gamma_y}{\\gamma_y}\\right)\n\nEn réarrangeant l’expression de droite en prenant en compte la condition précédente nous avons: \n\\dot N = \\underbrace{\\frac{r_x\\gamma_x+r_y\\gamma_y}{\\gamma_x+\\gamma_y}}_{r_N} N \\left(1 - N \\underbrace{\\frac{\\left(\\frac{r_x\\gamma_x^2}{K_x}+\\frac{r_y\\gamma_y^2}{K_y}\\right)}{(\\gamma_x+\\gamma_y)^2(r_x\\gamma_x+r_y\\gamma_y)}}_{\\frac{1}{K_N}} \\right) - zN\\underbrace{\\left(\\frac{p_x\\gamma_x+p_y\\gamma_y}{\\gamma_x+\\gamma_y}\\right)}_{p_N}\n\nPour \\dot z nous avons : \n\\dot z = z\\left(\\frac{n_xx\\gamma_x}{\\gamma_x}+\\frac{n_yy\\gamma_y}{\\gamma_y}-m\\right)\n \n\\Leftrightarrow\n \n\\dot z = z\\left( N \\underbrace{\\frac{n_x\\gamma_x+n_y\\gamma_y}{\\gamma_x+\\gamma_y}}_{n_N} - m\\right)\n\nLe système (1) devient donc pour \\beta \\to +\\infty :\n \\left\\{\\begin{array}{l}\n\\dot N = r_N N \\left(1-\\frac{N}{K_N}\\right) - p_NzN \\\\\n\\dot z = z\\left(n_N N - m\\right)\n\\end{array}\\right.\n\\tag{22}\nqui est exactement un système proie-prédateur de Lotka-Volterra avec croissance logistique des proies.\nSi \\exists z^* &gt; 0 nous avons à la fois N^*=\\frac{m}{n_N} et aussi N^* &lt; K_N et donc nous avons la condition suivante, s’il existe un équilibre non nul, K_N n_N &gt; m.\nOr, en prenant n_xx_0^*(+\\infty) + n_yy_0^*(+\\infty) &gt; m nous avons : \n\\frac{n_xx_0^*(+\\infty)\\gamma_x}{\\gamma_x} + \\frac{n_yy_0^*(+\\infty)\\gamma_y}{\\gamma_y} &gt; m\n \n\\Leftrightarrow\n \n\\frac{N^*_0}{\\gamma_x+\\gamma_y}(n_x\\gamma_x+n_y\\gamma_y) &gt; m\n\navec N^*_0 qui est l’équilibre du système de L-V pour z=0. Cet équilibre est trivialement égal à K_N et donc nous avons: \nK_N n_N &gt; m\n\nNos intuitions biologiques étant validées mathématiquement pour \\beta = 0 et \\beta \\to +\\infty nous pouvons logiquement se dire que c’est aussi le cas pour un \\beta \\in ]0,+\\infty[.\nNous allons simuler numériquement la somme des équilibres des proies du système (1) par la même méthode que précédemment en faisant aussi aparaître la courbe n_xx^*_0+n_yy^*_0 et m ainsi que la somme des équilibres des proies du système (4) sans prédateurs pour pouvoir voir quand nous avons disparition des prédateurs et donc x^*_0 + y^*_0 = x^*+y^*.\n\nDéflation du système sans prédateurs\n\n\nCode\n#Définition du modèle avec prédateurs:\ndef a(etat, t, param, i):\n    x, y, z = etat\n    b = i\n    rx, Kx, ry, Ky, gx, gy, px, py, nx, ny, m = param\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx) - px * z * x, \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy) - py * y * z, \n    z * (nx * x + ny * y - m)]\n    return s\n\n#Définition du modèle sans prédateurs:\ndef aug2(etat, t, param, i):\n    rx, Kx, ry, Ky, gx, gy = param\n    b = i\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx),\n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1\nKx1 = 2\nKy1 = 1\ngx1 = 0.5\ngy1 = 3\npx1 = 0.5\npy1 = 1\nnx1 = 0.5\nny1 = 1\nm11 = 1\nm12 = 1.5\n\nparam11p = np.array([rx1, Kx1, ry1, Ky1, gx1, gy1, px1, py1, nx1, ny1, m11])\nparam11sp = param11p[0:6]\nparam12p = np.array([rx1, Kx1, ry1, Ky1, gx1, gy1, px1, py1, nx1, ny1, m12])\nparam12sp = param12p[0:6]\n\n#Temps d'intégration suffisament large pour atteindre l'équilibre:\nt = np.arange(0, 600, 0.01)\n\n#Condition initiale:\ne0p = [1, 1, 1]\ne0sp = [1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (8, 5))\nplt.subplots_adjust(wspace = 0.3)\n\nxt = np.arange(0, 4, 0.01)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s1p = odeint(a, e0p, t, args = (param11p, i)) #Nous calculons pour chaque beta l'équilibre\n    s1sp = odeint(aug2, e0sp, t, args = (param11sp, i))\n\n    ax.plot(i, s1p[-1][0] + s1p[-1][1], marker = '.', markersize = 2, color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n    ax.plot(i, nx1 * s1sp[-1][0] + ny1 * s1sp[-1][1], marker = '.', markersize = 1, color = 'r')\n\n    ax.plot(i, s1sp[-1][0] + s1sp[-1][1], marker = '.', markersize = 1, color = '0.8')\n    \n\n\n    s1p = odeint(a, e0p, t, args = (param12p, i)) #Nous calculons pour chaque beta l'équilibre\n    s1sp = odeint(aug2, e0sp, t, args = (param12sp, i))\n    \n    ax1.plot(i, s1p[-1][0] + s1p[-1][1], marker = '.', markersize = 2, color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n    ax1.plot(i, nx1 * s1sp[-1][0] + ny1 * s1sp[-1][1], marker = '.', markersize = 1, color = 'r')\n\n    ax1.plot(i, s1sp[-1][0] + s1sp[-1][1], marker = '.', markersize = 1,color = '0.8')\n\n    \n    \n#Plot de la droite Kx+Ky:    \nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\n\n#Plot de la droite m\nax.plot(xt, m11 * np.ones_like(xt), linestyle = \"dashed\", color = 'C1')\nax1.plot(xt, m12 * np.ones_like(xt), linestyle = \"dashed\", color = 'C1')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\n\n\nax.set_ylabel('Population')\nax.plot(0, Kx1 + Ky1, color = '0.8', label = 'Somme des équilibres sans prédateurs')\nax.plot(0, Kx1 + Ky1, color = 'C0', label = 'Somme des équilibres avec prédateurs')\nax.plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'r', markersize = '6', label = 'nx*x0+ny*y0')\nax.plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm')\nax.plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (0.5, -0.6, 0.5, 0.5), fontsize = 10);\n\n#Titres:\nax.set_title('Déflation');\nax1.set_title('Déflation');\n\n\n\n\n\nFigure 7: Somme des équilibres du système avec et sans prédateurs dans des conditions de déflation sans prédateurs\n\n\n\n\nNous observons sur cette figure un profil relativement différent du modèle simplifié.\nL’analyse des figures est néanmoins assez similaire. La majeure différence entre le modèle complet et simplifié est que la condition sur la somme des équilibres n’est plus présente car elle se complexifie.\nDans notre modèle actuel nous avons représenté encore une fois en gris la somme des équilibres du modèle sans prédateurs (x^*_0 + y^*_0) et en bleu la somme des équilibres du modèle avec prédateurs (x^* + y^*). Cette fois ci, en rouge, nous avons représenté la courbe n_xx^*_0+n_yy^*_0 et en orange la droite constante égale à m.\nDans le modèle simplifié la condition d’invasion des prédateurs était donnée par le fait que graphiquement la courbe grise était au dessus (ou en dessous) de la droite verte.\nMaintenant la condition d’invasion des prédateurs est équivalente à ce que la droite rouge soit au dessus de la droite orange. Enfin dans notre nouveau modèle nous n’observons pas le phénomène de saturation quand les prédateurs envahissent.\nPour ces deux figures nous avons pris des valeurs de paramètres qui provoquent une déflation dans le système sans prédateurs comme en témoignent les courbes grises. Nous nous intéressons donc à l’effet des prédateurs sur un système déjà déflationniste.\nSur la figure à gauche nous observons que la courbe rouge est en permanence au dessus de la droite orange. Donc les prédateurs restent en vie et nous observons que la courbe bleue et grise ne sont pas confondues. La courbe bleue est plus basse que la courbe grise montrant que les prédateurs augmente la déflation du système.\nSur la figure à droite nous avons cette fois la courbe rouge qui coupe la droite orange. Nous avons d’abord la courbe rouge au dessus et donc présence de prédateurs dans le système et quand \\beta augmente nous avons la courbe rouge qui passe en dessous de la courbe orange impliquant que les prédateurs disparaissent. Nous voyons bien dans ce cas là que les courbes bleue et grise se rejoignent.\nAinsi, similairement au modèle simplifié, nous savons que si le système est déjà déflationniste sans prédateurs il le reste avec des prédateurs et ceux-ci peuvent accentuer la déflation selon leur présence ou non en fonction des paramètres.\n\n\nInflation/déflation du système sans prédateurs\nPassons maintenant à une condition d’inflation et de déflation du système sans prédateurs pour voir l’effet des prédateurs sur les ravageurs :\n\n\nCode\n#Définition des paramètres\n#2:\nrx2 = 0.5\nry2 = 1\nKx2 = 2\nKy2 = 1\ngx2 = 5\ngy2 = 1\npx2 = 0.5\npy2 = 3\nnx2 = 0.5\nny2 = 1\nm21 = 1.5\nm22 = 1.9\n\nparam21p = np.array([rx2, Kx2, ry2, Ky2, gx2, gy2, px2, py2, nx2, ny2, m21])\nparam21sp = param21p[0:6]\nparam22p = np.array([rx2, Kx2, ry2, Ky2, gx2, gy2, px2, py2, nx2, ny2, m22])\nparam22sp = param22p[0:6]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (8, 5))\nplt.subplots_adjust(wspace = 0.3)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s2p = odeint(a, e0p, t, args = (param21p, i)) #Nous calculons pour chaque beta l'équilibre\n    s2sp = odeint(aug2, e0sp, t, args = (param21sp, i))\n    \n    ax.plot(i, s2p[-1][0] + s2p[-1][1], marker = '.', markersize = 2, color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n    ax.plot(i, nx2 * s2sp[-1][0] + ny2 * s2sp[-1][1], marker = '.', markersize = 1, color = 'r')\n\n    ax.plot(i, s2sp[-1][0] + s2sp[-1][1], marker = '.', markersize = 1,color = '0.8')\n    \n\n\n    s2p = odeint(a, e0p, t, args = (param22p, i)) #Nous calculons pour chaque beta l'équilibre\n    s2sp = odeint(aug2, e0sp, t, args = (param22sp, i))\n    \n    ax1.plot(i, s2p[-1][0] + s2p[-1][1], marker = '.', markersize = 2, color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n    ax1.plot(i, nx2 * s2sp[-1][0] + ny2 * s2sp[-1][1], marker = '.', markersize = 1, color = 'r')\n    \n    ax1.plot(i, s2sp[-1][0] + s2sp[-1][1], marker = '.', markersize = 1, color = '0.8')\n\n\n#Plot de la droite Kx+Ky: \nax.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.plot(xt, (Kx2 + Ky2) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\n\n#Plot de m:\nax.plot(xt, m21 * np.ones_like(xt), linestyle = \"dashed\", color = 'C1')\nax1.plot(xt, m22 * np.ones_like(xt), linestyle = \"dashed\", color = 'C1')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\n\n\nax.set_ylabel('Population')\nax.plot(0, Kx2 + Ky2, color = '0.8', label = 'Somme des équilibres sans prédateurs')\nax.plot(0, Kx2 + Ky2, color = 'C0', label = 'Somme des équilibres avec prédateurs')\nax.plot(0, Kx2 + Ky2, linestyle = 'dashed', color = 'r', markersize = '6', label = 'nx*x0+ny*y0')\nax.plot(0, Kx2 + Ky2, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm')\nax.plot(0, Kx2 + Ky2, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (0.5, -0.6, 0.5, 0.5), fontsize = 10);\n\n#Titres:\nax.set_title('Déflation');\nax1.set_title('Les deux');\n\n\n\n\n\nFigure 8: Somme des équilibres du système avec et sans prédateurs dans des conditions d’inflation et de déflation sans prédateurs\n\n\n\n\nLes légendes sont les mêmes que sur la figure précédente.\nCette fois ci nous voyons bien avec la courbe grise que nous avons d’abord inflation puis déflation du système sans prédateurs, et nous allons essayer de voir quel peut être l’effet de l’invasion de prédateurs sur cette la population totale de ravageurs (x^*+y^*).\nSur la figure à gauche nous observons qu’avec m en dessous de n_xx^*_0+n_yy^*_0 nous avons constamment présence de prédateurs et nous observons que la courbe bleue est toujours en dessous de K_x+K_y (en noir) impliquant que le système est déflationniste.\nEnsuite sur la figure à droite nous remarquons une situation similaire à la figure 1 à droite. On a d’abord présence des prédateurs puis disparaition quand la courbe rouge passe en dessous de la droite orange.\nEn fonction de où coupe la courbe rouge par rapport à la droite orange nous pourrions avoir une déflation constante du système.\nNous pouvons observer des résultats assez différents du modèle simplifié, mais qui illustre bien l’effet attendu d’un prédateur sur un système inflationniste (une baisse de cet effet et éventuellement un passage à une déflation).\n\n\nInflation du système sans prédateurs\nIntéressons nous maitenant à un cas d’inflation constante du modèle sans prédateurs pour voir l’effet de ceux-ci:\n\n\nCode\n#Définition des paramètres\n#4:\nrx4 = 2\nry4 = 1\nKx4 = 1\nKy4 = 1.25\ngx4 = 0.5\ngy4 = 1\npx4 = 3\npy4 = 0.5\nnx4 = 0.5\nny4 = 1\nm41 = 1.4\nm42 = 1.82\n\nparam41p = np.array([rx4, Kx4, ry4, Ky4, gx4, gy4, px4, py4, nx4, ny4, m41])\nparam41sp = param41p[0:6]\nparam42p = np.array([rx4, Kx4, ry4, Ky4, gx4, gy4, px4, py4, nx4, ny4, m42])\nparam42sp = param42p[0:6]\n\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1,2,figsize=(8,5))\nplt.subplots_adjust(wspace=0.3)\n\nxt = np.arange(0, 4, 0.01)\n\n#Boucle pour plot en fonction de beta:\nfor i in np.arange(0, 4, 0.01):\n    s4p = odeint(a, e0p, t, args = (param41p, i)) #Nous calculons pour chaque beta l'équilibre\n    s4sp = odeint(aug2, e0sp, t, args = (param41sp, i))\n   \n    ax.plot(i, s4p[-1][0] + s4p[-1][1], marker = '.', markersize = 2, color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n    ax.plot(i, nx4 * s4sp[-1][0] + ny4 * s4sp[-1][1], marker = '.', markersize = 1, color = 'r')\n    \n    ax.plot(i, s4sp[-1][0] + s4sp[-1][1], marker = '.', markersize = 1, color = '0.8')\n    \n\n    s4p = odeint(a, e0p, t, args = (param42p, i)) #Nous calculons pour chaque beta l'équilibre\n    s4sp = odeint(aug2, e0sp, t, args = (param42sp, i))\n    \n    ax1.plot(i, s4p[-1][0] + s4p[-1][1], marker = '.', markersize = 2, color = 'C0') #Nous représentons un point qui correspond à la valeur de la somme des éq. en fonction de beta\n\n    ax1.plot(i, nx4 * s4sp[-1][0] + ny4 * s4sp[-1][1], marker = '.', markersize = 1, color = 'r')\n    \n    ax1.plot(i, s4sp[-1][0] + s4sp[-1][1], marker = '.', markersize = 1, color = '0.8')\n\n#Plot de Kx+Ky:\nax.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed',  color = 'k', markersize = '6')\nax1.plot(xt, (Kx4 + Ky4) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\n\n#Plot de m:\nax.plot(xt, m41 * np.ones_like(xt), linestyle = \"dashed\", color = 'C1')\nax1.plot(xt, m42 * np.ones_like(xt), linestyle = \"dashed\", color = 'C1')\n\n#Légendes:\nax.set_xlabel('β')\nax1.set_xlabel('β')\n\nax.set_ylabel('Population')\nax.plot(0, Kx4 + Ky4, color = '0.8', label = 'Somme des équilibres sans prédateurs')\nax.plot(0, Kx4 + Ky4, color = 'C0', label = 'Somme des équilibres avec prédateurs')\nax.plot(0, Kx4 + Ky4, linestyle = 'dashed', color = 'r', markersize = '6', label = 'nx*x0+ny*y0')\nax.plot(0, Kx4 + Ky4, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm')\nax.plot(0, Kx4 + Ky4, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n#Nous déplaçons la légende hors de la figure:\nax.legend(bbox_to_anchor = (0.5, -0.6, 0.5, 0.5), fontsize = 10);\n\n#Titres:\nax.set_title('Déflation');\nax1.set_title('Les deux');\n\n\n\n\n\nFigure 9: Somme des équilibres du système avec et sans prédateurs dans des conditions d’inflation sans prédateurs\n\n\n\n\nCette fois nous observons que la courbe rouge est croissante.\nA gauche nous avons encore une fois que pour un m constamment en dessous de n_xx^*_0+n_yy^*_0 nous avons un système déflationiste.\nA droite cette fois ci comme la courbe rouge est croissante nous allons d’abord avoir celle-ci en dessous de m et donc pas de présence de prédateurs alors que quand \\beta augmente nous avons invasion des prédateurs. Cette invasion est caractérisé dans notre cas par une population totale qui devient déflationniste contrairement au modèle sans prédateurs.\nOn voit à travers ces 3 figures que l’analyse est plus complexe. En fonction de si n_xx^*_0+n_yy^*_0 est croissante ou décroissante nous allons avoir (si m croise n_xx^*_0+n_yy^*_0) une invasion puis une disparition ou inversement.\nLa position des courbes devient très dépendante des paramètres. En particulier le taux de mortalité des prédateurs joue un rôle crucial et il serait intéressant de l’analyser plus en détail.\nNéanmoins, et de manière similaire à précédemment, les prédateurs semblent jouer un rôle clair sur la population totale de ravageur dans le système en la faisant baisser. Ceci peut faire passer un système infaltionniste sans prédateurs à déflationniste avec.\n\n\n\nEquilibre de la culture en fonction de \\gamma_y\nNous allons, en tracant la somme des équilibres dans la culture puis l’équilibre dans la culture seul, voir si les résultats coincindent avec ceux trouvés précédemment pour le modèle simplifié.\nLe taux de fuite est crucial dans la question de l’augmentorium.\n\n\nCode\n#Nous définissons un nouveau modèle qui prend en compte le changement de gy\ndef a2(etat, t, param, i):\n    x, y, z = etat\n    gy = i\n    rx, Kx, ry, Ky, gx, b, px, py, nx, ny, m = param\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx) - px * z * x, \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy) - py * y * z, \n    z *(nx * x + ny * y - m)]\n    return s\n\n#Définition de l'ancien modèle qui prend en compte le changement de gy:\ndef aug3(etat, t, param, h):\n    rx, ry, Kx, Ky, gx, b = param\n    gy = h\n    x, y = etat\n    s = [rx * x * (1 - x/Kx) + b * (y/gy - x/gx), \n    ry * y * (1 - y/Ky) + b * (x/gx - y/gy)]\n    return s \n\n#Définition des paramètres:\n#1:\nrx1 = 0.5\nry1 = 1  \nKx1 = 1\nKy1 = 2\ngx1 = 0.5\nb = 1\npx = 0.75\npy = 1\nnx = 0.75\nny = 1\nm = 2.5\n\nparam1 = np.array([rx1, ry1, Kx1, Ky1, gx1, b, px, py, nx, ny, m])\n\n#Temps d'intégration assez large pour atteindre l'éq :\nt = np.arange(0, 100, 0.01)\n\n#Conditions initiales:\ne0 = [1, 1, 1]\n\n#Figure:\nfig, (ax, ax1) = plt.subplots(1, 2, figsize = (9, 4))\n\n#Droite de la somme des capacités:\nxt = np.arange(0, 4, 0.01)\n\nax.plot(xt, (Kx1 + Ky1) * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax.text(3.15, Kx1 + Ky1 - 0.1, '$K_x+K_y$')\n\nax1.plot(xt, Kx1 * np.ones_like(xt), linestyle = 'dashed', color = 'k', markersize = '6')\nax1.text(3.5, Kx1 - 0.1, '$K_x$')\n\n#Plot de m:\nax.plot(xt, m * np.ones_like(xt), linestyle = 'dashed', color = 'C1', markersize = '6')\nax.text(3.15, m - 0.1, 'm/n')\n\n\n#Boucle qui calcule l'équilibre et qui plot un point en fonction des valeurs du taux de fuite:\nfor i in np.arange(0.01, 4, 0.001):\n    s = odeint(a2, e0, t, args = (param1, i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = 'C0')\n    ax1.plot(i, s[-1][0], marker = '.', color = 'C0')\n\n    s = odeint(aug3, e0[0:2], t, args = (param1[0:6], i))\n    ax.plot(i, s[-1][0] + s[-1][1], marker = '.', color = '0.8', markersize = 1)\n    ax.plot(i, nx * s[-1][0] + ny * s[-1][1], marker = '.', color = 'r', markersize = 1)\n    ax1.plot(i, s[-1][0], marker = '.', color = '0.8', markersize = 1)\n\n#Légendes:\nax1.set_xlabel('Ɣy, Fuite')\nax.set_xlabel('Ɣy, Fuite')\nax.plot(0, Kx1 + Ky1, color = 'C0', label = 'Somme des équilibres avec prédateurs')\nax1.plot(0, Kx1, color = 'C0', label = 'Eq. culture avec prédateurs ($x^*$)')\n\nax.plot(0, Kx1 + Ky1, color = '0.8', label = 'Somme des équilibres sans prédateurs')\nax1.plot(0, Kx1, color = '0.8', label = 'Somme des équilibres sans prédateurs')\n\nax.plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'r', markersize = '6', label = 'nx*x0+ny*y0')\nax.plot(0, Kx1 + Ky1, linestyle = 'dashed', color = 'C1', markersize = '6', label = 'm')\nax.plot(0, Kx4 + Ky4, linestyle = 'dashed', color = 'k', markersize = '6', label = 'Kx+Ky')\n\n\n\n\nax.set_title('Somme des équilibres en fonction du taux de fuite', fontsize = 7)\nax1.set_title('Equilibre de la culture en fonction du taux de fuite', fontsize = 7)   \nax.legend(fontsize = 7, loc = \"lower right\");\nax1.legend(fontsize = 7, loc = \"upper right\");\nax.set_ylabel(\"Densité de pop.\"); \n\n\n\n\n\nFigure 10: Equilibres en fonction du taux de fuite sur modèle complet\n\n\n\n\nNous observons des résultats similaires au système simplifié. On voit bien sur les figures quand est-ce que les prédateurs envahissent le système ou pas (si la courbe bleue est confondue avec la courbe grise nous avons disparition des prédateurs et inversement).\nA gauche nous observons que quelque soit le taux de fuite la somme des équilibres est déflationniste grâce à l’invasion de prédateurs qui baisse la population totale de ravageurs.\nNéanmoins nous observons qu’en repésentant l’équilibre dans la culture seul, c’est à dire x^* nous avons enfaite une inflation par rapport à K_x. Cette inflation est réduite plus rapidement avec prédateurs que sans prédateurs comme nous le montre la scission entre la courbe bleue et grise.\nNous avons donc obtenus des résultats intéressants qui peuvent mettre en lumière le rôle des prédateurs sur un système de ravageurs.\nNéanmoins par manque de temps nous n’avons pas pu exploiter pleinement le potentiel des équilibres en fonction des paramètres du modèle complet.\nUne analyse plus poussée nous paraîtrait intéressante.\nNous allons maintenant terminer ce rapport avec des perspectives sur un modèle à quatres populations et discuter des arguments qui pourraient appuyer une efficacité de l’augmentorium."
  },
  {
    "objectID": "conclusion.html#perspectives",
    "href": "conclusion.html#perspectives",
    "title": "Perspectives et conclusion",
    "section": "Perspectives:",
    "text": "Perspectives:\nCe stage a permis de préciser certaines propriétés du modèle proie-prédateur de L-V en deux classes (uniquement pour les ravageurs) avec migration asymétrique.\nPar manque de temps nous n’avons pas pu traiter une de nos premières idées qui était de traiter le modèle susnommé avec les prédateurs aussi répartis en deux classes. Ce modèle est plus général mais surtout plus difficile à traiter.\nNous allons rapidement avancer quelques idées en perspectives pour des hypothétiques travaux futurs.\n\nDéfinition du modèle\nDans ce modèle nous allons considérer 4 populations correspondant aux proies et aux prédateurs dans l’augmentorium et dans la culture.\nVoici le modèle:\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_1xz_1 \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_2yz_2 \\\\\n\\dot z_1 = z_1\\left(n_1x - m_1 \\right) + \\delta\\left(\\frac{z_2}{\\mu _2}-\\frac{z_1}{\\mu _1}\\right) \\\\\n\\dot z_2 = z_2\\left(n_2y - m_2 \\right) + \\delta\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\\end{array}\\right.\n\\tag{1}\n\n\nRéduction du modèle\nL’augmentorium permet aux prédateurs de circuler presque librement entre les l’intérieur et l’extérieur. Nous allons donc considérer que \\delta \\to +\\infty et voir si nous pouvons se rapporter à un modèle plus simple.\nOn considère \\frac{\\dot z_1}{\\mu _1} - \\frac{\\dot z_2}{\\mu _2}:\n\n\\frac{\\dot z_1}{\\mu _1} - \\frac{\\dot z_2}{\\mu _2} = \\frac{z_1}{\\mu _1}(n_1x-m_1)-\\frac{z_2}{\\mu_2}(n_2y-m_2) - \\delta\\left(\\frac{1}{\\mu _1} + \\frac{1}{\\mu _2}\\right)\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\nLorsque \\delta \\to +\\infty nous avons \\frac{\\dot z_1}{\\mu _1} - \\frac{\\dot z_2}{\\mu _2} qui devient: \n\\frac{\\dot z_1}{\\mu _1} - \\frac{\\dot z_2}{\\mu _2} = - \\delta\\left(\\frac{1}{\\mu _1} + \\frac{1}{\\mu _2}\\right)\\left(\\frac{z_1}{\\mu _1}-\\frac{z_2}{\\mu _2}\\right)\n\net donc nous avons \\frac{\\dot z_1}{\\mu _1} - \\frac{\\dot z_2}{\\mu _2} \\to 0 \\Leftrightarrow \\frac{z_1}{\\mu _1} = \\frac{z_2}{\\mu _2}.\nEn posant z=z_1+z_2 alors par la proposition précédente nous avons : \n\\frac{z}{\\mu _1+\\mu _2} = \\frac{\\frac{z_1\\mu _1}{\\mu _1}+\\frac{z_2\\mu _2}{\\mu _2}}{\\mu _1 +\\mu _2}=\\frac{z_1}{\\mu _1} = \\frac{z_2}{\\mu _2}\n\net donc : \n\\dot z = \\dot z_1 + \\dot z_2 = \\frac{z_1\\mu _1}{\\mu _1}\\left(n_1x - m_1 \\right) + \\frac{z_2\\mu _2}{\\mu _2}\\left(n_2y - m_2 \\right)\n \n\\Leftrightarrow\n \n\\dot z = \\frac{z}{\\mu _1 +\\mu _2}\\left(\\mu _1(n_1x-m_1)+\\mu _2(n_y-m_2)\\right)\n \n\\Leftrightarrow\n \n\\dot z = z \\left(\\underbrace{\\frac{\\mu _1n_1}{\\mu _1 +\\mu _2}}_{n_x}x + \\underbrace{\\frac{\\mu _2n_2}{\\mu _1 +\\mu _2}}_{n_y}y - \\underbrace{\\frac{\\mu _1m_1 + \\mu _2m_2}{\\mu _1 +\\mu _2}}_{m}\\right)\n\nNous avons alors : \n\\dot z = z(n_xx+n_yy-m)\n\nMaintenant considérons les proies :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-\\frac{p_1xz_1\\mu _1}{\\mu _1} \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-\\frac{p_2yz_2\\mu _2}{\\mu _2} \\\\\n\\end{array}\\right.\n \n\\Leftrightarrow\n \n\\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-\\overbrace{\\frac{p_1xz\\mu _1}{\\mu _1+\\mu _2}}^{p_x} \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-\\underbrace{\\frac{p_2yz\\mu _2}{\\mu _1+\\mu _2}}_{p_y}\n\\end{array}\\right.\n\nCeci donne donc le modèle d’augmentorium de la partie précédente :\n \\left\\{\\begin{array}{l}\n\\dot x = r_xx\\left(1-\\frac{x}{K_x}\\right)+\\beta\\left(\\frac{y}{\\gamma_y}-\\frac{x}{\\gamma_x}\\right)-p_xxz \\\\\n\\dot y = r_yy\\left(1-\\frac{y}{K_y}\\right)+\\beta\\left(\\frac{x}{\\gamma_x}-\\frac{y}{\\gamma_y}\\right)-p_yyz \\\\\n\\dot z = z\\left(n_xx+n_yy - m\\right)\n\\end{array}\\right.\n\\tag{2}\nL’analyse de ce modèle est faite ici et toutes les propositions vues sont aussi applicables dans ce modèle.\nNous allons faire quelques simulations pour voir si le modèle suit les modèles précédents et voir son comportement pour des \\delta \\ne \\infty.\n\n\nDynamique du modèle non réduit :\nNous allons voir la dynamique des 4 populations dans un premier temps :\n\n\nCode\n#Définition du modèle avec prédateurs:\n\ndef aug3(etat, t, param):\n    x, y, z1, z2 = etat\n    rx,Kx,ry,Ky,gx,gy,b,px,py,nx,ny,mx,my,d,mux,muy = param\n    s=[rx*x*(1-x/Kx)+b*(y/gy-x/gx)-px*z1*x,\n    ry*y*(1-y/Ky)+b*(x/gx-y/gy)-py*y*z2,\n    z1*(nx*x-mx)+d*(z2/muy-z1/mux),\n    z2*(ny*x-my)+d*(z1/mux-z2/muy)]\n    return s\n\n#Paramètres Simulation 1 : \nrx1=1\nry1=1.5\nKx1=3\nKy1=2\ngx1=0.5\ngy1=3\nb1=1\npx1=1\npy1=1.5\nnx1=1.5\nny1=2\nmx1=0.5\nmy1=0.5\nd1=1\nmux1=1.5\nmuy1=0.5\n\nparam_a1=np.array([rx1,Kx1,ry1,Ky1,gx1,gy1,b1,px1,py1,nx1,ny1,mx1,my1,d1,mux1,muy1])\n\n#Paramètres Simulation 2 : \nrx2=0.5\nry2=1\nKx2=3\nKy2=2\ngx2=0.5\ngy2=3\nb2=1\npx2=1\npy2=1.5\nnx2=1\nny2=1.5\nmx2=0.5\nmy2=0.5\nd2=1\nmux2=1.5\nmuy2=0.5\n\nparam_a2=np.array([rx2,Kx2,ry2,Ky2,gx2,gy2,b2,px2,py2,nx2,ny2,mx2,my2,d2,mux2,muy2])\n\n#Temps d'intégration 1:\nt=np.arange(0,100,0.01)\n\n#Condition initiale de 1:\nx0=2\ny0=0\nz10=0.5\nz20=0\nc0=np.array([x0,y0,z10,z20])\n\n#Simulation 1:\ns1=odeint(aug3,c0,t,args=(param_a1,))\ns2=odeint(aug3,c0,t,args=(param_a2,))\n\n#Plot de la figure: \nfig,(ax,ax1) = plt.subplots(1,2,figsize=(14,5))\nfig.suptitle('Simulation du modèle final d\\'augmentorium')\nplt.subplots_adjust(wspace=0.2)\n\n#Plot de l'axe 1:\nax.plot(t,s1[:,0],color='C0',label='Ravageurs dans la culture')\nax.plot(t,s1[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax.plot(t,s1[:,2],color='C6',label='Prédateurs dans la culture')\nax.plot(t,s1[:,3],color='C9',label='Prédateurs dans l\\'augmentorium')\n\n#Plot de l'axe 1:\nax1.plot(t,s2[:,0],color='C0',label='Ravageurs dans la culture')\nax1.plot(t,s2[:,1],color='C1',label='Ravageurs dans l\\'augmentorium')\nax1.plot(t,s2[:,2],color='C6',label='Prédateurs dans la culture')\nax1.plot(t,s2[:,3],color='C9',label='Prédateurs dans l\\'augmentorium')\n\n#Légendes et titres:\nax.set_ylabel('Population, x,y,z1,z2')\nax.legend(fontsize=8)\nax.grid()\nax.set_xlabel('Temps, t')\nax.set_title('Coexistence des quatres populations',fontsize=7.5)\n\nax1.set_ylabel('Population, x,y,z1,z2')\nax1.legend(fontsize=8)\nax1.grid()\nax1.set_xlabel('Temps, t')\nax1.set_title('Disparition des prédateurs',fontsize=7.5)\n\n\nText(0.5, 1.0, 'Disparition des prédateurs')\n\n\n\n\n\nNous observons deux situations, l’une avec un équilibre de coexistence des quatres populations et l’autre avec disparition des preédateurs.\n\n\nComparaison du modèle réduit et non réduit\nSur une idée d’Arditi R. (2015) nous allons représenter…."
  }
]